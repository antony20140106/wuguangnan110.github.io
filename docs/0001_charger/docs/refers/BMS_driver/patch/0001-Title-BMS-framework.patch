From cba88f37cd76225e0405ae516c866998ad31048c Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?=E5=B1=88=E6=98=8E=E6=9C=88?= <qumy@paxsz.com>
Date: Tue, 22 Jun 2021 17:19:30 +0800
Subject: [PATCH] =?UTF-8?q?[Title]:=E5=A2=9E=E5=8A=A0BMS=E5=8A=9F=E8=83=BD?=
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

[Summary]: 测试BMS功能，有三种模式：自动模式，桌面模式和移动模式：
        1.自动模式：根据之前3天的当前时间后6个小时的数据判断当前机器的模式，①充电数据量多于不充电，则是桌面模式；否则是移动模式
        2.桌面模式：回充电量为：65；满充电量为80；
        3.移动模式：回充电量为：85；满充电量为100；
        在机器插充电器的状态下，每30s记录一次充电数据；不插充电器则不记录数据；
        插充电器状态下，每30min检查一下状态；
        如果当前电量低于回充电量则不切换状态；
        机器会只保留7天的数据量；
        在设置中可以设置机器的充电模式：Battery->Battery Manager -> Select
        Charge Mode
        如果不设置机器充电状态，则默认为自动模式；
        通过设置persist.sys.battery.type属性设置电池工作模式；
        通过写persist.sys.bms.db属性为1，重启机器即可清空数据库数据；
        在data/system/tmp/why_not_charging文件中写停止充电的原因，取值为：RECHARGEMECHANISM，null
        persist.sys.battery.autotype属性，取值范围：1,2；只有在persist.sys.battery.type属性为0(自动模式)时有效，
        1：自动模式下移动模式；2，自动模式

[Test Plan]: 测试该功能

[Module]: BMS

[Model]: M50 11

[author]: qumy@paxsz.com

[date]: 2020-06-22
---
 device/mediatek/mt6765/init.mt6765.rc         |   2 +-
 .../basic/neverallows/non_plat/neverallows.te |   1 +
 .../sepolicy/basic/non_plat/system_server.te  |   6 +-
 .../com/android/server/BatteryTermInfo.java   |  92 +++
 .../com/android/server/DatabaseHelper.java    |  40 +
 .../server/PaxBatteryManagerService.java      | 750 ++++++++++++++++++
 .../com/android/server/PaxSystemServer.java   |   4 +
 .../prebuilts/api/29.0/private/coredomain.te  |   1 +
 .../prebuilts/api/30.0/private/coredomain.te  |   1 +
 system/sepolicy/private/coredomain.te         |   1 +
 .../apps/MtkSettings/res/values/strings.xml   |   6 +
 .../res/xml/smart_battery_detail.xml          |  10 +-
 .../MtkSettings/res_ext/values/mtk_arrays.xml |  14 +
 ...ChargeBatteryModePreferenceController.java | 131 +++
 14 files changed, 1056 insertions(+), 3 deletions(-)
 mode change 100644 => 100755 device/mediatek/mt6765/init.mt6765.rc
 mode change 100644 => 100755 device/mediatek/sepolicy/basic/non_plat/system_server.te
 create mode 100755 paxdroid/frameworks/base/services/core/java/com/android/server/BatteryTermInfo.java
 create mode 100755 paxdroid/frameworks/base/services/core/java/com/android/server/DatabaseHelper.java
 create mode 100755 paxdroid/frameworks/base/services/core/java/com/android/server/PaxBatteryManagerService.java
 mode change 100644 => 100755 system/sepolicy/prebuilts/api/29.0/private/coredomain.te
 mode change 100644 => 100755 system/sepolicy/prebuilts/api/30.0/private/coredomain.te
 mode change 100644 => 100755 system/sepolicy/private/coredomain.te
 mode change 100644 => 100755 vendor/mediatek/proprietary/packages/apps/MtkSettings/res/values/strings.xml
 mode change 100644 => 100755 vendor/mediatek/proprietary/packages/apps/MtkSettings/res/xml/smart_battery_detail.xml
 mode change 100644 => 100755 vendor/mediatek/proprietary/packages/apps/MtkSettings/res_ext/values/mtk_arrays.xml
 create mode 100755 vendor/mediatek/proprietary/packages/apps/MtkSettings/src/com/android/settings/fuelgauge/ChargeBatteryModePreferenceController.java

diff --git a/device/mediatek/mt6765/init.mt6765.rc b/device/mediatek/mt6765/init.mt6765.rc
old mode 100644
new mode 100755
index ebf85e73d25..4728f99b571
--- a/device/mediatek/mt6765/init.mt6765.rc
+++ b/device/mediatek/mt6765/init.mt6765.rc
@@ -30,7 +30,7 @@ on init
     chown root system /dev/stune/io
     chown root system /dev/stune/io/tasks
     chmod 0664 /dev/stune/io/tasks
-
+    chmod 0666 /sys/devices/platform/charger/charge_enable
     # Support legacy paths
     symlink /sdcard /mnt/sdcard
 
diff --git a/device/mediatek/sepolicy/basic/neverallows/non_plat/neverallows.te b/device/mediatek/sepolicy/basic/neverallows/non_plat/neverallows.te
index e224a20df81..d06794f896b 100755
--- a/device/mediatek/sepolicy/basic/neverallows/non_plat/neverallows.te
+++ b/device/mediatek/sepolicy/basic/neverallows/non_plat/neverallows.te
@@ -39,6 +39,7 @@ full_treble_only(`
     btlfpserver
     factory
     hal_paxservice_default
+    system_server
     } sysfs:file *;
 
   neverallow {
diff --git a/device/mediatek/sepolicy/basic/non_plat/system_server.te b/device/mediatek/sepolicy/basic/non_plat/system_server.te
old mode 100644
new mode 100755
index 1936e1cf569..29d0b799639
--- a/device/mediatek/sepolicy/basic/non_plat/system_server.te
+++ b/device/mediatek/sepolicy/basic/non_plat/system_server.te
@@ -265,4 +265,8 @@ dontaudit system_server kernel:process sigkill;
 # Date : 2020/10/22
 # Operation: R Migration
 # Purpose : dontaudit systemserver is not allowed to perform append operations on "/data"
-dontaudit system_server system_data_root_file:file append;
\ No newline at end of file
+dontaudit system_server system_data_root_file:file append;
+
+# Date : 2021/04/15
+# Operation : Pax qumy
+allow system_server sysfs:file { open read write getattr };
\ No newline at end of file
diff --git a/paxdroid/frameworks/base/services/core/java/com/android/server/BatteryTermInfo.java b/paxdroid/frameworks/base/services/core/java/com/android/server/BatteryTermInfo.java
new file mode 100755
index 00000000000..e045b4a0293
--- /dev/null
+++ b/paxdroid/frameworks/base/services/core/java/com/android/server/BatteryTermInfo.java
@@ -0,0 +1,92 @@
+package com.android.server;
+
+import android.os.SystemProperties;
+
+public class BatteryTermInfo {
+    private String model;
+    private int save_data_min;
+    private int curmode;
+    private int predicted_hours;
+    private int recharge;
+    private int fullcharge;
+    public static int TIMEOUT_X_SEC	= 30;
+    public static int TIMEOUT_X_MIN	= 1800;	// 30min = 30*60s
+    public static int TIMEOUT_X_HOUR = 86400;	// 24h = 24*60*60s
+    public static int TIMEOUT_1_MIN	= 60;	// 60s
+    public static int SAVE_DAYS	= 7;
+    public static int PREDICTED_DAYS_MIN = 3;
+    public static int PREDICTED_HOURS_DEFAULT = 6;
+
+    public int AUTO_MODE = 0;
+    public int MOBILE_MODE = 1;
+    public int COUNTER_TOP_MODE = 2;
+    public int saveday = SAVE_DAYS;
+	public static int MOBILE_MODE_RECHARGE = 85;
+	public static int COUNTER_TOP_MODE_RECHARGE = 65;
+	public static int MOBILE_MODE_FULLCHARGE = 100;
+	public static int COUNTER_TOP_MODE_FULLCHARGE = 80;
+	
+
+    public BatteryTermInfo(int curmode){
+        this.model = SystemProperties.get("ro.product.model","");
+        if(model.equals("M50") || model.equals("A800")){//M50,3, , 5
+            this.curmode = curmode;
+            this.predicted_hours = PREDICTED_HOURS_DEFAULT;
+            this.save_data_min =  (60 * 60 *this.predicted_hours * PREDICTED_DAYS_MIN * 1000) * 95 / 100;//至少3天的数据
+            if(curmode == COUNTER_TOP_MODE){
+                this.recharge = COUNTER_TOP_MODE_RECHARGE;
+                this.fullcharge = COUNTER_TOP_MODE_FULLCHARGE;
+            }else {
+                this.recharge = MOBILE_MODE_RECHARGE;
+                this.fullcharge = MOBILE_MODE_FULLCHARGE;
+            }
+            this.saveday = SAVE_DAYS;
+        }
+
+    }
+
+    public BatteryTermInfo(int save_data_min,int curmode,int predicted_hours){
+        this.model = SystemProperties.get("ro.product.model","");
+        this.predicted_hours = predicted_hours;
+        this.save_data_min =  (60 * 60 *this.predicted_hours * PREDICTED_DAYS_MIN * 1000) * 95 / 100;
+        this.curmode = curmode;
+    }
+
+    public String getModel(){
+        return model;
+    }
+    public int getSave_data_min(){
+        return save_data_min;
+    }
+    public int getCurmode(){
+        return curmode;
+    }
+    public int getPredicted_hour(){
+        return predicted_hours;
+    }
+    public int getSaveDays(){
+        return saveday;
+    }
+    public void setSaveday(int days){
+        this.saveday = days;
+    }
+
+    public void setCurmode(int batterymode){
+        this.curmode = batterymode;
+        if(batterymode == COUNTER_TOP_MODE){
+			this.recharge = COUNTER_TOP_MODE_RECHARGE;
+            this.fullcharge = COUNTER_TOP_MODE_FULLCHARGE;
+            
+        }else {
+            this.recharge = MOBILE_MODE_RECHARGE;
+            this.fullcharge = MOBILE_MODE_FULLCHARGE;
+        }
+    }
+    public int getRecharge(){
+        return recharge;
+    }
+    public int getFullcharge(){
+        return fullcharge;
+    }
+
+}
diff --git a/paxdroid/frameworks/base/services/core/java/com/android/server/DatabaseHelper.java b/paxdroid/frameworks/base/services/core/java/com/android/server/DatabaseHelper.java
new file mode 100755
index 00000000000..4f22475667e
--- /dev/null
+++ b/paxdroid/frameworks/base/services/core/java/com/android/server/DatabaseHelper.java
@@ -0,0 +1,40 @@
+package com.android.server;
+
+import android.content.Context;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteOpenHelper;
+
+public class DatabaseHelper extends SQLiteOpenHelper {
+
+    //private static final String NAME = "batterylog.db";
+    private static final int VERSION = 1;
+    private static final String batterylog_NAME = "batterylog.db";
+    private static final String StartupShutdownlog_NAME = "StartupShutdownlog.db";
+    private String CREATETABLE_BATTERYLOG = "create table if not exists batterylog(power int NOT NULL,createTime Text DEFAULT (strftime('%Y-%m-%d %H:%M:%S','now','localtime')));";
+    private String CREATETABLE_STARTUPSHUTDOWN = "create table if not exists StartupShutdownlog(poweron int NOT NULL,createTime Text DEFAULT (strftime('%Y-%m-%d %H:%M:%S','now','localtime')));";
+    String name;
+
+
+    public DatabaseHelper(Context context,String NAME) {
+        super(context, NAME, null, VERSION);
+        this.name = NAME;
+    }
+
+    @Override
+    public void onCreate(SQLiteDatabase db) {
+        String createtable_sql = "";
+        if(this.name.equals(batterylog_NAME)){
+            createtable_sql = CREATETABLE_BATTERYLOG;
+        }else if(this.name.equals(StartupShutdownlog_NAME)){
+            createtable_sql = CREATETABLE_STARTUPSHUTDOWN;
+        }
+        db.execSQL(createtable_sql);
+    }
+
+
+
+    @Override
+    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
+
+    }
+}
diff --git a/paxdroid/frameworks/base/services/core/java/com/android/server/PaxBatteryManagerService.java b/paxdroid/frameworks/base/services/core/java/com/android/server/PaxBatteryManagerService.java
new file mode 100755
index 00000000000..22063cebcca
--- /dev/null
+++ b/paxdroid/frameworks/base/services/core/java/com/android/server/PaxBatteryManagerService.java
@@ -0,0 +1,750 @@
+/*
+ * Copyright (C) 2006 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server;
+
+
+import android.app.AlarmManager;
+import android.app.PendingIntent;
+import android.app.Service;
+import android.content.BroadcastReceiver;
+import android.content.ContentValues;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.database.Cursor;
+import android.database.sqlite.SQLiteDatabase;
+import android.os.BatteryManager;
+import android.os.BatteryManagerInternal;
+import android.os.Handler;
+import android.os.HandlerThread;
+import android.os.IBinder;
+import android.os.Message;
+import android.os.OsProtoEnums;
+import android.os.PowerManager;
+import android.os.SystemClock;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.text.DateFormat;
+import java.text.ParseException;
+import java.text.SimpleDateFormat;
+import java.util.Date;
+import java.util.Timer;
+import java.util.TimerTask;
+import java.util.Random;
+import android.os.ServiceManager;
+import java.util.Calendar;
+import java.io.File;
+
+
+
+//import android.os.Handler;
+//import android.os.Message;
+
+import android.util.Log;
+import android.os.SystemProperties;
+
+import static android.content.Context.ALARM_SERVICE;
+
+public final class PaxBatteryManagerService extends SystemService {
+    private static final String TAG = PaxBatteryManagerService.class.getSimpleName();
+
+    private static final boolean DEBUG = false;
+	private String BatteryType = "persist.sys.battery.type";
+	private String AUTO_BatteryType = "persist.sys.battery.autotype";
+	private String ResetBMSDB = "persist.sys.bms.db";
+	public String Shutdown_time = "persist.sys.shutdowntime";
+	public int AUTO_MODE = 0;
+	public int MOBILE_MODE = 1;
+	public int COUNTER_TOP_MODE = 2;
+	
+	public int AUTO_NULL_MODE = 0;
+	public int AUTO_MOBILE_MODE = 1;
+	public int AUTO_COUNTER_TOP_MODE = 2;
+
+	public static int TIMEOUT_X_SEC	= 10000;
+	public static int TIMEOUT_X_MIN	= 1800000;//3min 180000	// 30min = 30*60s
+	public static int TIMEOUT_X_HOUR = 86400000;	// 24h = 24*60*60s  5min = 5*60  86400000
+	public static long ONE_DAY = 24*60*60*1000;
+	public static int TIMEOUT_1_MIN	= 60000;	// 60s
+	public static int SAVE_DAYS	= 7;
+	public static int RECORD_TIME = 30000;//30s
+
+    private static final int BATTERY_SCALE = 100;    // battery capacity is a percentage
+    private BatteryManagerInternal mBatteryManagerInternal;
+	private int mBatteryLevel;
+	private Context mContext;
+	private final String path = "sys/devices/platform/charger/charge_enable";
+	private final String disable_charge_reason = "data/system/tmp/why_not_charging";
+	public int reChargeLevel = 0;
+	public int fullChageLevel = 100;
+	public int chargeState = -1;
+	SQLiteDatabase batterylog_db = null;
+	SQLiteDatabase StartupShutdownlog_db = null;
+
+	private static final String batterylog_NAME = "batterylog.db";
+	private static final String StartupShutdownlog_NAME = "StartupShutdownlog.db";
+
+
+	DatabaseHelper database1;
+	DatabaseHelper database2;
+	int power = -1;
+	int initcurMode;
+	BatteryTermInfo batteryTermInfo;
+	AlarmManager am;
+	public static final String  broadcastDel_DB = "paxbatteryAlarm.operation.delDB";
+	public static final String  broadcastCheck_Mode = "paxbatteryAlarm.operation.checkMode";
+	BatteryReceiver myReceiver;
+	PowerManager.WakeLock wl;
+	public static final int CHARGEING = 1;
+	public static final int DISCHARGE = 0;
+	public static int MOBILE_MODE_RECHARGE = 85;
+	public static int COUNTER_TOP_MODE_RECHARGE = 65;
+	public static int MOBILE_MODE_FULLCHARGE = 100;
+	public static int COUNTER_TOP_MODE_FULLCHARGE = 80;
+	public int sleeptime = 0;
+	int poweron = 1;
+	int poweroff = 0;
+	String predicted_starttime;
+	String predicted_endtime;
+	public static int recodetime = 30000;
+	DateFormat df = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
+	SimpleDateFormat df_str = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
+
+
+	public PaxBatteryManagerService(Context context) {
+        super(context);
+		Log.d(TAG,"PaxBatteryManagerService");
+
+        mContext = context;
+        mBatteryManagerInternal = getLocalService(BatteryManagerInternal.class);
+        myReceiver = new BatteryReceiver();
+		mContext.registerReceiver(myReceiver, new IntentFilter(broadcastDel_DB));
+		mContext.registerReceiver(myReceiver, new IntentFilter(Intent.ACTION_BOOT_COMPLETED));//监听开机广播
+		mContext.registerReceiver(myReceiver, new IntentFilter(Intent.ACTION_SHUTDOWN));//监听关机广播
+	}
+
+	public void onStart() {
+		Log.d(TAG,"onStart");
+		am = (AlarmManager)mContext.getSystemService(ALARM_SERVICE);
+		PowerManager pm = (PowerManager) mContext.getSystemService(Context.POWER_SERVICE);
+		wl = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, TAG);
+		wl.acquire();
+		PaxBatteryThread pbthread = new PaxBatteryThread();
+		pbthread.start();
+	}
+
+	public int getInitcurMode(){
+		int mode = -1;
+		if(SystemProperties.get(BatteryType).isEmpty()){
+			mode = 0;
+			SystemProperties.set(BatteryType,"0");
+			SystemProperties.set(AUTO_BatteryType,String.valueOf(AUTO_MOBILE_MODE));
+		}else{
+			mode = Integer.valueOf(SystemProperties.get(BatteryType));
+		}
+		Log.d(TAG,"mode = "+mode);
+		return mode;
+	}
+
+	public void initBatterylogDB(){
+		database1 = new DatabaseHelper(mContext,batterylog_NAME);//传入一个上下文参数
+		batterylog_db = database1.getWritableDatabase();
+		Log.d(TAG,"batterylog_db path = "+batterylog_db.getPath());
+	}
+
+	public void initStartupShutdownlogDB(){
+		database2 = new DatabaseHelper(mContext,StartupShutdownlog_NAME);//传入一个上下文参数
+		StartupShutdownlog_db = database2.getWritableDatabase();
+		Log.d(TAG,"StartupShutdownlog_db path = "+StartupShutdownlog_db.getPath());
+	}
+
+	public void init(){
+		Log.d(TAG,"PaxBatteryManagerService init");
+		initBatterylogDB();
+		initStartupShutdownlogDB();
+		initcurMode = getInitcurMode();//
+		batteryTermInfo = new BatteryTermInfo(initcurMode);//初始化模式
+		batteryTermInfo.setSaveday(SAVE_DAYS);
+
+		if(SystemProperties.get(ResetBMSDB,"0").equals("1")){
+			delDB(-1);//
+		}else{
+			delDB(batteryTermInfo.getSaveDays());
+		}
+		//mTimer_DelData.schedule(mTask_DelDB,TIMEOUT_X_HOUR,TIMEOUT_X_HOUR);
+		mContext.registerReceiver(myReceiver, new IntentFilter(Intent.ACTION_BATTERY_CHANGED));//监听电池变化的广播
+	}
+//1.休眠测试，
+	class PaxBatteryThread extends Thread {
+			@Override
+			public void run() {
+				Log.d(TAG, "PaxBatteryThread run1");
+				init();
+				sleeptime = 3000;
+				setAlarm(TIMEOUT_X_HOUR);//24h,删除数据
+				Log.d(TAG, "mBatteryManagerInternal.getPlugType() = " + mBatteryManagerInternal.getPlugType());
+				int count_times = 0;
+				int PLUGGED_flag = 0;
+				while (true) {
+					//count_times++;
+					Log.d(TAG, "count_times = " + count_times);
+					if(mBatteryManagerInternal.getPlugType() != OsProtoEnums.BATTERY_PLUGGED_NONE){//机器插入电源线
+						if(PLUGGED_flag == 0){
+							PLUGGED_flag = 1;
+							count_times = count_times/3;
+						}
+						if (!wl.isHeld()) {
+							Log.d(TAG, "acquire LOCK");
+							wl.acquire();
+						}
+						Log.d(TAG, "power = " + power);
+						Log.d(TAG, "mBatteryLevel = " + mBatteryLevel);
+						power = 1;
+						insertDB(power);//只写power = 1
+						sleeptime = 30000;
+					}else {
+						if(wl.isHeld()){
+							Log.d(TAG,"RELEASE LOCK");
+							wl.release();
+						}
+						if(PLUGGED_flag == 1){
+							PLUGGED_flag = 0;
+							count_times = count_times*3;
+						}
+						sleeptime = 10000;
+					}
+					initcurMode = getInitcurMode();
+					if(initcurMode != batteryTermInfo.getCurmode()){
+						batteryTermInfo.setCurmode(initcurMode);
+						if(mBatteryManagerInternal.getPlugType() != OsProtoEnums.BATTERY_PLUGGED_NONE && mBatteryManagerInternal.getBatteryLevel() >= batteryTermInfo.getFullcharge() && chargeState == CHARGEING){
+							setChargeState(DISCHARGE);
+							chargeState = DISCHARGE;
+						}
+					}
+					if (batteryTermInfo.getCurmode() == AUTO_MODE) {//自动模式去切换模式
+						if(mBatteryLevel >= COUNTER_TOP_MODE_RECHARGE){
+							if (count_times == 0) {//电量高于桌面模式回充电量，再去检测切换模式
+								int mode = checkMode();
+								batteryTermInfo.setCurmode(mode);
+							    SystemProperties.set(AUTO_BatteryType,String.valueOf(mode));
+								count_times = TIMEOUT_X_MIN / sleeptime;
+							}else{
+								count_times--;
+								if(count_times < 0){
+									count_times = TIMEOUT_X_MIN / sleeptime;
+								}
+							}
+						}else{
+							count_times = 0;
+						}
+					}else{
+						count_times = 0;
+					}
+					SystemClock.sleep(sleeptime);
+				}
+			}
+	}
+
+
+	public int checkMode(){
+    	Log.d(TAG,"checkMode");
+		int mode = -1;
+		long total = batteryTermInfo.getSaveDays()*batteryTermInfo.getPredicted_hour()*60*60*1000;
+		Log.d(TAG,"checkMode total = "+total);
+		Log.d(TAG,"save_data_min = "+batteryTermInfo.getSave_data_min());
+		long validTime = total - getInvalidTime();
+		Log.d(TAG,"validTime = "+validTime);
+		if(validTime >=batteryTermInfo.getSave_data_min()){
+			int PA = queryDB(1);//插适配器
+			Log.d(TAG,"PA = "+PA);
+			long PA_time = PA * recodetime;
+			long PB_time = validTime - PA_time;
+			if(PA_time > PB_time){
+				// 历时记录中当前时间段插适配器多于不插适配器数据，桌面模式
+				mode = COUNTER_TOP_MODE;
+			}else{
+				//batteryTermInfo.setCurmode(MOBILE_MODE);
+				mode = MOBILE_MODE;
+			}
+		} else{
+			mode = MOBILE_MODE;//数据量不够时，默认移动模式
+		}
+		Log.d(TAG,"checkMode mode = "+mode);
+		return mode;
+	}
+
+    public int setChargeState(int state){
+        try {
+            Log.d(TAG,"setChargeState: "+state);
+            FileOutputStream out = new FileOutputStream(path);//enable_charge
+            out.write(state+'0');
+            out.close();
+			writeWhynotCharingFile(state);
+            Log.d(TAG,"setChargeState over");
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+        return 0;
+    }
+
+	public String getDBFirstOrLast(boolean First){
+		String createTime = null;
+		Cursor cursor = batterylog_db.query("batterylog", null, null, null, null, null, null);
+		if (cursor != null) {
+			if(First){
+				if(cursor.moveToFirst()){
+					createTime = cursor.getString(cursor.getColumnIndex("createTime"));
+				}
+			}else {
+				if(cursor.moveToLast()){
+					createTime = cursor.getString(cursor.getColumnIndex("createTime"));
+				}
+			}
+			
+		}
+		cursor.close();
+		return createTime;
+	}
+	public int getDiffTime(){
+		int diffTime = -1;
+		String FirstTime = getDBFirstOrLast(true);
+		String LastTime = getDBFirstOrLast(false);
+		if( null == FirstTime || null == LastTime || FirstTime.isEmpty() || LastTime.isEmpty()){
+			return diffTime;
+		}else{
+			DateFormat df = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
+			try {
+				Date first = df.parse(FirstTime);
+				Date last = df.parse(LastTime);
+				long diff = last.getTime() - first.getTime();
+				diffTime = (int)(diff/(1000*60*60*24));
+				Log.d(TAG,"diffTime = "+diffTime);
+			} catch (ParseException e) {
+				e.printStackTrace();
+			}
+		}
+		return diffTime;
+	}
+
+	public long  getInvalidTime(){
+		long total = 0;
+		int status = -1;
+		int nhour = 1;
+		String tmp = df_str.format(getBeforeDays(batteryTermInfo.SAVE_DAYS));//start time
+		Log.d(TAG,"tmp = "+tmp);
+		String start = tmp;
+		String t1 = String.format("strftime('%%H','now','localtime','+%d hour')",nhour);
+		String t2 = String.format("strftime('%%H','now','localtime','+%d hour')",nhour+batteryTermInfo.getPredicted_hour());
+		String t3 = String.format("strftime('%%H','now','localtime','+%d hour')",batteryTermInfo.getPredicted_hour());
+		int laststatus = 0;//关机
+		String queryStartup_time = String.format("select * from StartupShutdownlog where " +
+						"( case when %s < %s" +
+						"then strftime('%%H', createTime) between %s and %s" +
+						"else strftime('%%H', createTime) not between %s and strftime('%%H','now','localtime')end ) ORDER by createTime asc;"
+				,t1,t2,t1,t3,t2);
+		Cursor cursor = StartupShutdownlog_db.rawQuery(queryStartup_time,null);
+		if(cursor != null && cursor.getCount() !=0){
+			while (cursor.moveToNext()){
+				status = cursor.getInt(cursor.getColumnIndex("poweron"));
+				String createTime = cursor.getString(cursor.getColumnIndex("createTime"));
+				Log.d(TAG,"createTime = "+createTime);
+				try{
+					Date createTime1 = df.parse(createTime);
+					if(createTime1.after(getBeforeDays(batteryTermInfo.SAVE_DAYS))){
+						Log.d(TAG,"createTime1 = "+createTime1.toString());
+						if(poweron == status && laststatus == 0 ){//开机，计算无效时间
+						    laststatus = 1;
+							total = total + transTime(tmp,createTime,start);//加无效时间
+							Log.d(TAG,"total0 = "+total);
+						}else if(poweroff == status){ //如果StartupShutdownlog_db中有两个1连在一起则不计算该时间为无效时间
+							laststatus = 0;
+						}
+						tmp = createTime;
+					}
+				}catch (ParseException e) {
+					e.printStackTrace();
+				}
+				
+			}
+		}else{
+			String qureyStr = "select * FROM StartupShutdownlog Order By createTime ASC";
+			Cursor cursor1 = StartupShutdownlog_db.rawQuery(qureyStr,null);
+			Date tmp_createTime1;
+			Date createTime1;
+			int tmp_status = -1;
+			int flag = 0;
+			Date firstTime = getBeforeDays(batteryTermInfo.SAVE_DAYS);
+			int days = batteryTermInfo.SAVE_DAYS;
+			int days_flag = 0;
+			if(cursor1 != null && cursor1.getCount() !=0){
+				//if(cursor1.moveToFirst()){
+					while(cursor1.moveToNext()){
+						status = cursor1.getInt(cursor1.getColumnIndex("poweron"));
+						String createTime = cursor1.getString(cursor1.getColumnIndex("createTime"));
+						Log.d(TAG,"createTime = "+createTime);
+						Log.d(TAG,"status = "+status);
+						try{
+							createTime1 = df.parse(createTime);
+							if(createTime1.before(firstTime)){
+								tmp_createTime1 = createTime1;
+								tmp_status = status;
+							}else {
+								days_flag = days;
+								while(createTime1.after(firstTime) && days > 0){
+									days-=1;
+									firstTime = getBeforeDays(days);
+								}
+								if(tmp_status == 0 || tmp_status == -1){//关机时间有从0-1；或者第一条数据是1则表示之前都是关机
+									if(status == 1){
+										Log.d(TAG,"days = "+days);
+										total += (days_flag - days)*6*60*60*1000;
+									}else{
+										continue;
+									}
+								}
+								tmp_createTime1 = createTime1;
+								tmp_status = status;
+							}
+						}catch (ParseException e) {
+							e.printStackTrace();
+						}
+					}
+					if(tmp_status == 0 && days > 0 ){
+						Log.d(TAG,"remain days = "+days);
+						total += days*6*60*60*1000;
+					}
+				//}
+			}else{
+				total = batteryTermInfo.getSaveDays()*batteryTermInfo.getPredicted_hour()*60*60*1000;
+			}
+		}
+		Log.d(TAG,"total = "+total);
+		return total;
+	}
+
+
+	public Date getBeforeDays(int days){
+		if(days < 0 ) days=0;
+		Calendar calendar = Calendar.getInstance();
+		calendar.add(Calendar.DAY_OF_YEAR, -days);
+		calendar.add(Calendar.HOUR_OF_DAY, +1);
+		Date newDate = calendar.getTime();
+		newDate.setMinutes(0);
+        newDate.setSeconds(0);
+		return newDate;
+	}
+
+	public long transTime(String startTime,String endTime,String start){
+		long startTime1;
+		long endTime1;
+		long start1;//第一个时间段最开始的时间
+		long end1;//第一个时间段最末尾的时间
+		long diffTime = 0;
+		long prehour = batteryTermInfo.getPredicted_hour()*60*60*1000;
+
+		Log.d(TAG,"startTime = "+startTime);
+		Log.d(TAG,"endTime = "+endTime);
+		Log.d(TAG,"start = "+start);
+		if(startTime.isEmpty() || endTime.isEmpty() || start.isEmpty())
+			return diffTime;
+
+		try {
+			startTime1 = df.parse(startTime).getTime();
+			endTime1 = df.parse(endTime).getTime();
+			start1 = df.parse(start).getTime();//时间段最开始的时间
+			end1 = start1+prehour;//第一个时间段最末尾的时间
+
+			if(startTime1 < start1 || endTime1 < start1 || endTime1 < startTime1 )
+				return 0;
+
+			if(endTime1 - startTime1 <= prehour){//关机开机时间在同一段时间，间隔不超过6h
+				diffTime = endTime1 - startTime1;
+				return diffTime;
+			}
+
+			while(startTime1 > end1){
+				start1 += ONE_DAY;
+				end1 += ONE_DAY;
+			}
+			while(endTime1 > end1){//
+				if(startTime1 > start1){
+					diffTime += end1 - startTime1;
+					Log.d(TAG,"diffTime0 = "+diffTime);
+				}else{
+					Date date = new Date(end1);
+					String datestr = df_str.format(date);
+					int status = -1;
+					Log.d(TAG,"datestr = "+datestr);
+					String querystr = String.format("select * from StartupShutdownlog where createTime > '%s'",datestr);//找出开始时间所在的时间段前的最后一个数据
+					Cursor cursor = StartupShutdownlog_db.rawQuery(querystr,null);
+					if(cursor != null && cursor.getCount() > 0){
+						Log.d(TAG,"cursor.getCount() = "+cursor.getCount());
+						if(cursor.moveToFirst()){
+							status = cursor.getInt(cursor.getColumnIndex("poweron"));
+							String time = cursor.getString(cursor.getColumnIndex("createTime"));
+							Log.d(TAG,"after end1 first time = "+time + "   status = "+status);
+							if(status == 1){//开机，说明之前是关机，所以无效数据
+								Log.d(TAG,"diffTime1 = "+diffTime);
+								diffTime+=prehour;
+							}
+						}
+					}else{
+						diffTime+=prehour;
+						Log.d(TAG,"diffTime2 = "+diffTime);
+					}
+				}
+				start1+=ONE_DAY;
+				end1+=ONE_DAY;
+				startTime1 = start1;
+			}
+			diffTime += endTime1-startTime1;
+			
+		} catch (ParseException e) {
+			e.printStackTrace();
+		}
+		Log.d(TAG,"diffTime = "+diffTime);
+		return diffTime;
+	}
+
+	public void insertDB(int power){
+		Log.d(TAG," power = "+power);
+		ContentValues cv = new ContentValues();
+		cv.put("power",power); //添加充电类型
+		if(batterylog_db == null){
+			initBatterylogDB();
+		}
+		batterylog_db.insert("batterylog",null,cv);//执行插入操作
+	}
+
+	public int queryDB(int powered){
+    	Log.d(TAG,"queryDB");
+		int nhour = 1;
+		int count = 0;
+    	String equ = "=";
+    	if(powered != 1){
+			equ = "!=";
+		}
+		String t1 = String.format("strftime('%%H','now','localtime','+%d hour')",nhour);
+		String t2 = String.format("strftime('%%H','now','localtime','+%d hour')",nhour+batteryTermInfo.getPredicted_hour());
+		String t3 = String.format("strftime('%%H','now','localtime','+%d hour')",batteryTermInfo.getPredicted_hour());
+		String querystr_test1 = String.format("select * from batterylog where power %s 1 and" +
+						"( case when %s < %s" +
+						"then strftime('%%H', createTime) between %s and %s" +
+						"else strftime('%%H', createTime) not between %s and strftime('%%H','now','localtime')end );"
+				,equ,t1,t2,t1,t3, t2);
+		Cursor cursor = batterylog_db.rawQuery(querystr_test1,null);
+		if(cursor != null){
+			Log.d(TAG,"cursor count = "+cursor.getCount());
+			count = cursor.getCount();
+		}
+		cursor.close();
+		return count;
+	}
+
+	public void delDB(int days){
+    	Log.d(TAG,"delDB days= "+days);
+		String str;
+		String str1;
+		String str3;
+		long count = 0;
+        if(days > 0){
+			Log.d(TAG,"delDB days0= "+days);
+			str = String.format("delete from batterylog where date(createTime) < date('now','-%d day','localtime') " +
+					"or createTime > datetime('now','localtime');vacuum;",days);
+			batterylog_db.execSQL(str);
+
+
+			str1 = String.format("delete from StartupShutdownlog where date(createTime) < date('now','-%d day','localtime') " +
+								"or createTime > datetime('now','localtime');vacuum;",days);
+			str3 = "select count(*) FROM StartupShutdownlog;";
+			Cursor cursor = StartupShutdownlog_db.rawQuery(str3, null);
+			if(cursor.moveToFirst()){
+				count = cursor.getLong(0);
+			}
+			Log.d(TAG,"delDB count = "+count);
+			cursor.close();
+			if(count > 3){
+				StartupShutdownlog_db.execSQL(str1);
+			}
+        }else if(days < 0){
+			File batterylogfile = new File("/data/system/batterylog.db");
+			File StartupShutdownlogfile = new File("/data/system/StartupShutdownlog.db");
+            if(batterylogfile.isFile()&&batterylogfile.exists()){
+                batterylogfile.delete();
+            }else {
+                Log.d(TAG,"batterylogfile is not exist");
+            }
+			if(StartupShutdownlogfile.isFile()&&StartupShutdownlogfile.exists()){
+                StartupShutdownlogfile.delete();
+            }else {
+                Log.d(TAG,"StartupShutdownlogfile is not exist");
+            }
+			initBatterylogDB();
+			initStartupShutdownlogDB();
+			SystemProperties.set(ResetBMSDB,"0");
+		}
+	}
+
+	public void setAlarm(long period){
+    	Log.d(TAG,"setAlarm0 period= "+period);
+		Intent intent = new Intent("paxbatteryAlarm.operation.null");
+		int rc = 0;
+		if(period == TIMEOUT_X_MIN){//30min
+			rc = 1;
+			intent = new Intent(broadcastCheck_Mode);
+		}else if(period == TIMEOUT_X_HOUR) {//24h
+			Log.d(TAG, "setAlarm0 delDB");
+			rc = 2;
+			intent = new Intent(broadcastDel_DB);
+		}else if(period == TIMEOUT_X_SEC){
+
+		}else if(period == TIMEOUT_1_MIN) {
+
+		}
+    	Log.d(TAG,"RC = "+rc);
+		PendingIntent pi = PendingIntent.getBroadcast(mContext,rc,intent,PendingIntent.FLAG_UPDATE_CURRENT);
+		//am.setExact(AlarmManager.RTC_WAKEUP,System.currentTimeMillis()+period,pi);
+		am.setAndAllowWhileIdle(AlarmManager.RTC_WAKEUP,System.currentTimeMillis()+period,pi);
+	}
+
+	class BatteryReceiver extends BroadcastReceiver{
+		@Override
+		public void onReceive(Context context, Intent intent) {
+			String action =intent.getAction();
+			//Message msg = Message.obtain(); // 实例化消息对象，
+			if(Intent.ACTION_BATTERY_CHANGED.equals(action)) {//每次收到广播记录下时间
+				int status=intent.getIntExtra("status", BatteryManager.BATTERY_STATUS_UNKNOWN);
+				int currLevel=intent.getIntExtra(BatteryManager.EXTRA_LEVEL,0);
+				int total=intent.getIntExtra(BatteryManager.EXTRA_SCALE,1);
+				int PLUG =intent.getIntExtra(BatteryManager.EXTRA_PLUGGED, -1);
+				mBatteryLevel=currLevel*100/total;//计算电量
+				//Log.d(TAG,"status = "+status);
+				//Log.d(TAG,"currLevel = "+currLevel);
+				//Log.d(TAG,"percent = "+mBatteryLevel);
+				int flag = 0;
+				if(status==BatteryManager.BATTERY_STATUS_CHARGING)
+				{
+					chargeState = CHARGEING;
+				}
+				else
+				{
+					chargeState = DISCHARGE;
+				}
+				initcurMode = getInitcurMode();
+				if(initcurMode != batteryTermInfo.getCurmode()){
+					batteryTermInfo.setCurmode(initcurMode);
+				}
+				Log.d(TAG,"batteryTermInfo.getFullcharge() = "+batteryTermInfo.getFullcharge());
+				Log.d(TAG,"batteryTermInfo.getRecharge() = "+batteryTermInfo.getRecharge());
+				if(PLUG > 0 && mBatteryLevel >= batteryTermInfo.getFullcharge() && chargeState == CHARGEING  ){
+					Log.d(TAG,"discharge");
+					setChargeState(DISCHARGE);
+					chargeState = DISCHARGE;
+					flag = 1;
+				}else if(PLUG > 0 && mBatteryLevel <= batteryTermInfo.getRecharge() && chargeState == DISCHARGE){
+					Log.d(TAG,"chargeing");
+					setChargeState(CHARGEING);
+					chargeState = CHARGEING;
+					flag = 1;
+				}
+				if(flag == 0 && chargeState == CHARGEING || PLUG == 0 ){//当机器充电状态或不接充电线，WhynotCharingFile都应该写null
+					writeWhynotCharingFile(CHARGEING);
+				}
+			} else if(broadcastCheck_Mode.equals(action)) {
+				Log.d(TAG, "onReceive checkMode");
+				cancelAlarm(broadcastCheck_Mode);
+				checkMode();
+				setAlarm(TIMEOUT_X_MIN);
+			} else if(broadcastDel_DB.equals(action)){
+				Log.d(TAG,"onReceive delDB");
+				cancelAlarm(broadcastDel_DB);
+				delDB(batteryTermInfo.getSaveDays());
+				setAlarm(TIMEOUT_X_HOUR);
+			}else if(Intent.ACTION_BOOT_COMPLETED.equals(action)){
+				Log.d(TAG,"ACTION_BOOT_COMPLETED");
+				String shutdown_time = SystemProperties.get(Shutdown_time,"");
+				if(shutdown_time != null && !shutdown_time.isEmpty()){
+					Log.d(TAG,"record ACTION_SHUTDOWN");
+					insertShartupShutDownDB(poweroff,shutdown_time);
+					SystemProperties.set(Shutdown_time,"");
+				}
+				insertShartupShutDownDB(poweron,null);
+
+			}else if(Intent.ACTION_SHUTDOWN.equals(action)){
+				Log.d(TAG,"ACTION_SHUTDOWN");
+				SimpleDateFormat formatte = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");     
+  				Date curDate = new Date(System.currentTimeMillis());
+				String time = formatte.format(curDate); 
+				SystemProperties.set(Shutdown_time,time);
+				Log.d(TAG,"record ACTION_SHUTDOWN time = "+time);
+				//insertShartupShutDownDB(poweroff);
+			}
+		}
+	}
+
+	public void writeWhynotCharingFile(int state){
+		try {
+			
+			File reason_file = new File(disable_charge_reason);
+			if(!reason_file.exists()){
+				File dir  = new File("data/system/tmp/");
+				if(!dir.exists()){
+					dir.mkdirs();
+				}
+				reason_file.createNewFile();
+			}
+            FileOutputStream reason_out = new FileOutputStream(reason_file);
+            if(state == 0){
+                reason_out.write("RECHARGE MECHANISM\0".getBytes());
+            }else{
+                reason_out.write("\0".getBytes());
+            }
+			reason_out.close();
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+	}
+
+	public void insertShartupShutDownDB(int on,String time){
+		Log.d(TAG," power = "+power);
+		ContentValues cv = new ContentValues();
+		cv.put("poweron",on);//添加机器状态：开机或者关机
+		if(null != time  && !time.isEmpty() ){
+			cv.put("createTime",time);
+		} 
+		if(StartupShutdownlog_db==null){
+			initStartupShutdownlogDB();
+		}
+		StartupShutdownlog_db.insert("StartupShutdownlog",null,cv);//执行插入操作
+	}
+
+	public void cancelAlarm(String broadcast_Str){
+		Intent intent = new Intent("paxbatteryAlarm.operation.null");
+		int rc = -1;
+		if(broadcast_Str.equals(broadcastCheck_Mode)){
+			intent = new Intent(broadcastCheck_Mode);
+			rc = 1;
+		}else if(broadcast_Str.equals(broadcastDel_DB)){
+			intent = new Intent(broadcastDel_DB);
+			rc = 2;
+		}
+		PendingIntent pi = PendingIntent.getBroadcast(mContext,rc,intent,PendingIntent.FLAG_UPDATE_CURRENT);
+		AlarmManager am = (AlarmManager)mContext.getSystemService(ALARM_SERVICE);
+		am.cancel(pi);
+		Log.d(TAG, "关闭了提醒");
+	}
+}
diff --git a/paxdroid/frameworks/base/services/java/com/android/server/PaxSystemServer.java b/paxdroid/frameworks/base/services/java/com/android/server/PaxSystemServer.java
index 632bcc508c8..1bc39447241 100755
--- a/paxdroid/frameworks/base/services/java/com/android/server/PaxSystemServer.java
+++ b/paxdroid/frameworks/base/services/java/com/android/server/PaxSystemServer.java
@@ -107,6 +107,10 @@ public class PaxSystemServer {
         //     reportWtf("starting pax ethernet", e);
         //}
         //traceEnd();
+		traceBeginAndSlog("Start PaxBatteryService Service");
+		mSystemServiceManager.startService(PaxBatteryManagerService.class);
+		traceEnd();
+
     }
 
     private SystemService startService(String className) {
diff --git a/system/sepolicy/prebuilts/api/29.0/private/coredomain.te b/system/sepolicy/prebuilts/api/29.0/private/coredomain.te
old mode 100644
new mode 100755
index 169f6b249a1..f78874e1b0c
--- a/system/sepolicy/prebuilts/api/29.0/private/coredomain.te
+++ b/system/sepolicy/prebuilts/api/29.0/private/coredomain.te
@@ -102,6 +102,7 @@ full_treble_only(`
     -init
     -ueventd
     -vold
+    -system_server
   } sysfs:file no_rw_file_perms;
 
   # /dev
diff --git a/system/sepolicy/prebuilts/api/30.0/private/coredomain.te b/system/sepolicy/prebuilts/api/30.0/private/coredomain.te
old mode 100644
new mode 100755
index ab731f1228f..57f72d59516
--- a/system/sepolicy/prebuilts/api/30.0/private/coredomain.te
+++ b/system/sepolicy/prebuilts/api/30.0/private/coredomain.te
@@ -108,6 +108,7 @@ full_treble_only(`
     -init
     -ueventd
     -vold
+    -system_server
   } sysfs:file no_rw_file_perms;
 
   # /dev
diff --git a/system/sepolicy/private/coredomain.te b/system/sepolicy/private/coredomain.te
old mode 100644
new mode 100755
index ab731f1228f..57f72d59516
--- a/system/sepolicy/private/coredomain.te
+++ b/system/sepolicy/private/coredomain.te
@@ -108,6 +108,7 @@ full_treble_only(`
     -init
     -ueventd
     -vold
+    -system_server
   } sysfs:file no_rw_file_perms;
 
   # /dev
diff --git a/vendor/mediatek/proprietary/packages/apps/MtkSettings/res/values/strings.xml b/vendor/mediatek/proprietary/packages/apps/MtkSettings/res/values/strings.xml
old mode 100644
new mode 100755
index 1fcef2041f1..2369b23edf5
--- a/vendor/mediatek/proprietary/packages/apps/MtkSettings/res/values/strings.xml
+++ b/vendor/mediatek/proprietary/packages/apps/MtkSettings/res/values/strings.xml
@@ -12193,4 +12193,10 @@
     <string name="media_controls_no_players">No players available</string>
     <!-- Keywords for the media controls setting [CHAR LIMIT=NONE]-->
     <string name="keywords_media_controls">media</string>
+
+
+    <!-- [FEATURE]-Add-BEGIN by (qumy@paxsz.com), 2021/05/08 for add chargemode -->
+    <string name = "battery_charge_mode_summary">charge mode</string>
+    <string name = "selet_chargemode">Select Charge Mode</string>
+    <!-- [FEATURE]-Add-END by (qumy@paxsz.com), 2021/05/08 for add chargemode -->
 </resources>
diff --git a/vendor/mediatek/proprietary/packages/apps/MtkSettings/res/xml/smart_battery_detail.xml b/vendor/mediatek/proprietary/packages/apps/MtkSettings/res/xml/smart_battery_detail.xml
old mode 100644
new mode 100755
index 87eeb8621ba..42c0c969c16
--- a/vendor/mediatek/proprietary/packages/apps/MtkSettings/res/xml/smart_battery_detail.xml
+++ b/vendor/mediatek/proprietary/packages/apps/MtkSettings/res/xml/smart_battery_detail.xml
@@ -41,7 +41,15 @@
         android:title="@string/battery_auto_restriction_title"
         android:summary="@string/battery_auto_restriction_summary"
         settings:controller="com.android.settings.fuelgauge.AutoRestrictionPreferenceController"/>
-
+	<!-- [FEATURE]-Add-BEGIN by (qumy@paxsz.com), 2021/05/08 for add chargemode -->
+    <ListPreference
+        android:key="charge_mode"
+        android:title="@string/selet_chargemode"
+        android:entries="@array/charge_mode_entries"
+        android:entryValues="@array/charge_mode_entries_value"
+        android:summary="@string/battery_charge_mode_summary"
+        settings:controller="com.android.settings.fuelgauge.ChargeBatteryModePreferenceController"/>
+    	<!-- [FEATURE]-Add-END by (qumy@paxsz.com), 2021/05/08 for add chargemode -->
     <Preference
         android:key="restricted_app"
         android:title="@string/restricted_app_title"/>
diff --git a/vendor/mediatek/proprietary/packages/apps/MtkSettings/res_ext/values/mtk_arrays.xml b/vendor/mediatek/proprietary/packages/apps/MtkSettings/res_ext/values/mtk_arrays.xml
old mode 100644
new mode 100755
index 8cf4261c6ca..2edd9366e94
--- a/vendor/mediatek/proprietary/packages/apps/MtkSettings/res_ext/values/mtk_arrays.xml
+++ b/vendor/mediatek/proprietary/packages/apps/MtkSettings/res_ext/values/mtk_arrays.xml
@@ -230,4 +230,18 @@
     </string-array>
     <!--OP12 Verizon Wifi Settings end[SKIP COMMENT] -->
 
+    <!-- [FEATURE]-Add-BEGIN by (qumy@paxsz.com), 2021/05/08 for add chargemode -->
+    <string-array name="charge_mode_entries">
+        <item>AUTO_MODE</item>
+        <item>MOBILE_MODE</item>
+        <item>COUNTER_TOP_MODE</item>
+    </string-array>
+
+    <string-array name="charge_mode_entries_value" translatable="false">
+        <item>0</item>
+        <item>1</item>
+        <item>2</item>
+    </string-array>
+    <!-- [FEATURE]-Add-END by (qumy@paxsz.com), 2021/05/08 for add chargemode -->
+
 </resources>
diff --git a/vendor/mediatek/proprietary/packages/apps/MtkSettings/src/com/android/settings/fuelgauge/ChargeBatteryModePreferenceController.java b/vendor/mediatek/proprietary/packages/apps/MtkSettings/src/com/android/settings/fuelgauge/ChargeBatteryModePreferenceController.java
new file mode 100755
index 00000000000..2cbba5b9146
--- /dev/null
+++ b/vendor/mediatek/proprietary/packages/apps/MtkSettings/src/com/android/settings/fuelgauge/ChargeBatteryModePreferenceController.java
@@ -0,0 +1,131 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.settings.fuelgauge;
+
+import android.content.Context;
+import android.content.DialogInterface;
+import android.os.Bundle;
+import androidx.preference.ListPreference;
+import android.preference.PreferenceActivity;
+import android.preference.PreferenceScreen;
+import android.provider.Settings;
+
+import androidx.preference.Preference;
+import com.android.settings.R;
+import com.android.settings.RestrictedListPreference;
+import com.android.settings.core.BasePreferenceController;
+import android.os.SystemProperties;
+import android.util.Log;
+
+/**
+ * Controller to change and update the auto restriction toggle
+ */
+public class ChargeBatteryModePreferenceController extends BasePreferenceController implements
+        Preference.OnPreferenceChangeListener {
+	private String BatteryType = "persist.sys.battery.type";
+	private static final String KEY_CHARGE_MODE = "charge_mode";
+	public static final int AUTO_MODE = 0;
+	public static final int MOBILE_MODE = 1;
+	public static final int COUNTER_TOP_MODE = 2;
+	CharSequence[] entries;
+	CharSequence[] values;
+
+
+    public static final String TAG = "ChargeBatteryMode";
+	private Context mContext;
+
+    public ChargeBatteryModePreferenceController(Context context) {
+		super(context, KEY_CHARGE_MODE);
+        mContext = context;
+		Log.d(TAG,"ChargeBatteryModePreferenceController0");
+    }
+
+    @Override
+    public int getAvailabilityStatus() {
+        return AVAILABLE;
+    }
+
+    @Override
+    public void updateState(Preference preference) {
+        super.updateState(preference);
+        Log.d(TAG,"ChargeBatteryModePreferenceController updateState");
+        entries = ((ListPreference)preference).getEntries();
+        values = ((ListPreference)preference).getEntryValues();
+        String type = SystemProperties.get(BatteryType, null);
+        int index = 0;
+        if (!type.isEmpty()){
+            index = Integer.valueOf(type);
+        }
+        Log.d(TAG,"updateState value = "+values[index].toString());
+        ((ListPreference)preference).setValue(values[index].toString());
+        updatePreferenceDescription(preference,index);
+    }
+
+    @Override
+    public boolean onPreferenceChange(Preference preference, Object newValue) {
+        Log.d(TAG,"ChargeBatteryModePreferenceController onPreferenceChange");
+
+        int index = Integer.parseInt((String) newValue);
+        Log.d(TAG,"onPreferenceChange index = "+index);
+        updatePreferenceDescription(preference,index);
+        return true;
+    }
+
+	public void setChargeMode(String mode){
+		SystemProperties.set(BatteryType, mode);
+	}
+
+	private void updatePreferenceDescription(Preference preference, int index){
+        entries = ((ListPreference)preference).getEntries();
+        final String summary;
+        switch (index) {
+            case AUTO_MODE:
+                setChargeMode("0");
+                break;
+            case MOBILE_MODE:
+                setChargeMode("1");
+                break;
+            case COUNTER_TOP_MODE:
+                setChargeMode("2");
+                break;
+            default:
+                break;
+        }
+        Log.d(TAG,"updatePreferenceDescription index = "+index);
+        ((ListPreference)preference).setSummary(entries[index]);
+    }
+    public static CharSequence getChargeDescription(
+            int index, CharSequence[] entries, CharSequence[] values) {
+        if (index < 0 || entries == null || values == null
+                || values.length != entries.length) {
+            Log.d(TAG,"getChargeDescription null");
+            return null;
+        }
+		
+
+        for (int i = 0; i < values.length; i++) {
+            int in = Integer.parseInt(values[i].toString());
+			Log.d(TAG,"getChargeDescription in = "+in);
+            if (index == in) {
+				Log.d(TAG,"getChargeDescription");
+                return entries[i];
+            }
+        }
+		Log.d(TAG,"getChargeDescription null2");
+        return null;
+    }
+
+}
-- 
2.17.1

