<!DOCTYPE html>
<html class="writer-html5" lang="zh-CN" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>wugn</title>

      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/default.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/translations.js"></script>
        <script src="../../../_static/js/baidutongji.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="索引" href="../../../genindex.html" />
    <link rel="search" title="搜索" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../index.html" class="icon icon-home"> wugn_note
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="在文档中搜索" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <!-- Local TOC -->
              <div class="local-toc"><ul>
<li><a class="reference internal" href="#">README</a></li>
<li><a class="reference internal" href="#refers">refers</a></li>
<li><a class="reference internal" href="#id1">名词解释</a></li>
<li><a class="reference internal" href="#id2">整体架构</a></li>
<li><a class="reference internal" href="#cfg">cfg信息</a></li>
<li><a class="reference internal" href="#id3">软件流程</a><ul>
<li><a class="reference internal" href="#musb-core">musb_core注册过程</a></li>
<li><a class="reference internal" href="#usb20musb-hdrc-musb-core-platform-device">usb20注册musb-hdrc（musb_core）的platform device</a></li>
<li><a class="reference internal" href="#musb-core-cmusb20-cprobe">musb_core.c和musb20.c关系及probe流程</a></li>
<li><a class="reference internal" href="#musb-core-musb-core-init">musb_core musb_core_init流程</a><ul>
<li><a class="reference internal" href="#mt-usb-interrupt">mt_usb_interrupt中断函数</a></li>
<li><a class="reference internal" href="#otg-mt-usb-otg-init">otg初始化(mt_usb_otg_init)</a></li>
<li><a class="reference internal" href="#do-register-otg-worknotifytcpc">do_register_otg_work注册notify监听tcpc</a><ul>
<li><a class="reference internal" href="#host-device">host/device切换底层原理</a><ul>
<li><a class="reference internal" href="#device">1.device切换原理</a></li>
<li><a class="reference internal" href="#host">2.host切换原理</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#mt-usb-psy-init">mt_usb_psy_init</a></li>
</ul>
</li>
<li><a class="reference internal" href="#musb-core-musb-init-controller">musb_core musb_init_controller简要分析</a><ul>
<li><a class="reference internal" href="#usb-add-hcdhcd-host-controller-device">1. usb_add_hcd注册主控制器HCD(host controller device/主)</a></li>
<li><a class="reference internal" href="#musb-gadget-setupudc-usb-device-controllerr">2.musb_gadget_setup注册从控制器UDC(usb device controllerr/从)</a><ul>
<li><a class="reference internal" href="#gadget">gadget驱动框架</a></li>
<li><a class="reference internal" href="#id4">gadget驱动架构图</a></li>
<li><a class="reference internal" href="#id5">gadget相关数据结构体关系</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">wugn_note</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs"> 
<li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
<li>README</li>
<li style="float: right;margin-left: 10px;"><a href="javascript:history.forward()">Forward</a></li>
<li style="float: right;margin-left: 10px;"><a href="javascript:history.back()">Go Back</a> | </li>
<li style="float: right;margin-left: 10px;"><a href="/index.html">Home</a> | </li>

      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="readme">
<h1>README<a class="headerlink" href="#readme" title="此标题的永久链接"></a></h1>
<p>musb驱动分析。</p>
</section>
<section id="refers">
<h1>refers<a class="headerlink" href="#refers" title="此标题的永久链接"></a></h1>
<ul class="simple">
<li><p><a class="reference external" href="https://blog.csdn.net/mike8825/article/details/103756462">USB驱动之二控制器驱动(musb)</a></p></li>
<li><p><a class="reference external" href="https://blog.csdn.net/Decisiveness/article/details/51714871">musb 0619</a></p></li>
<li><p><a class="reference external" href="https://www.cnblogs.com/wen123456/p/14036543.html">mtk OTG驱动分析</a></p></li>
<li><p><a class="reference external" href="https://blog.csdn.net/metuu/article/details/17227285">musb_core.c 是usb_general.c 调用进musb模块的核心函数</a></p></li>
<li><p><a class="reference external" href="https://blog.csdn.net/fang_yang_wa/article/details/112618516">Linux设备模型(8)——platform设备</a></p></li>
<li><p><a class="reference external" href="https://blog.csdn.net/weixin_46485500/article/details/118752708?spm=1001.2101.3001.6650.6&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-6-118752708-blog-78184395.pc_relevant_antiscanv2&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-6-118752708-blog-78184395.pc_relevant_antiscanv2&amp;utm_relevant_index=8">devm_ioremap_resource devm_ioremap 区别</a></p></li>
<li><p><a class="reference external" href="https://blog.csdn.net/u013836909/category_9808058.html">Linux USB</a></p></li>
<li><p>Multipoint USB Highspeed Dual-Role Controller (MUSB HDRC)</p></li>
<li><p>HCD(host controller device/主)</p>
<ul>
<li><p>OHCI(open host controller inferface)</p></li>
<li><p>UHCI(universal host controller interface)</p></li>
<li><p>EHCI(enhanced host controller interface)</p></li>
<li><p>xHCI(eXtensible Host Controller Interface)</p></li>
</ul>
</li>
<li><p>UDC(usb device controllerr/从)</p></li>
</ul>
</section>
<section id="id1">
<h1>名词解释<a class="headerlink" href="#id1" title="此标题的永久链接"></a></h1>
<p>这里就简单列一下各种xHCI（也包括真正的xHCI）的基本含义吧。</p>
<p>简单地讲，OHCI、UHCI都是USB1.1的接口标准，而EHCI是对应USB2.0的接口标准，最新的xHCI是USB3.0的接口标准。</p>
<ul class="simple">
<li><ol class="arabic simple">
<li><p>OHCI（Open Host Controller Interface）是支持USB1.1的标准，但它不仅仅是针对USB，还支持其他的一些接口，比如它还支持Apple的火线（Firewire，IEEE 1394）接口。与UHCI相比，OHCI的硬件复杂，硬件做的事情更多，所以实现对应的软件驱动的任务，就相对较简单。主要用于非x86的USB，如扩展卡、嵌入式开发板的USB主控。</p></li>
</ol>
</li>
<li><ol class="arabic simple" start="2">
<li><p>UHCI（Universal Host Controller Interface），是Intel主导的对USB1.0、1.1的接口标准，与OHCI不兼容。UHCI的软件驱动的任务重，需要做得比较复杂，但可以使用较便宜、较简单的硬件的USB控制器。Intel和VIA使用UHCI，而其余的硬件提供商使用OHCI。</p></li>
</ol>
</li>
<li><ol class="arabic simple" start="3">
<li><p>EHCI（Enhanced Host Controller Interface），是Intel主导的USB2.0的接口标准。EHCI仅提供USB2.0的高速功能，而依靠UHCI或OHCI来提供对全速（full-speed）或低速（low-speed）设备的支持。</p></li>
</ol>
</li>
<li><ol class="arabic simple" start="4">
<li><p>xHCI（eXtensible Host Controller Interface），是最新最火的USB3.0的接口标准，它在速度、节能、虚拟化等方面都比前面3中有了较大的提高。xHCI 支持所有种类速度的USB设备（USB 3.0 SuperSpeed, USB 2.0 Low-, Full-, and High-speed, USB 1.1 Low- and Full-speed）。xHCI的目的是为了替换前面3中（UHCI/OHCI/EHCI）。</p></li>
</ol>
</li>
</ul>
</section>
<section id="id2">
<h1>整体架构<a class="headerlink" href="#id2" title="此标题的永久链接"></a></h1>
<p><img alt="0001_0001.png" src="../../../_images/0001_00012.png" />
<img alt="0001_0002.png" src="../../../_images/0001_00023.png" /></p>
<p>整个 USB 系统的通讯模型如上图所示，</p>
</section>
<section id="cfg">
<h1>cfg信息<a class="headerlink" href="#cfg" title="此标题的永久链接"></a></h1>
<ul class="simple">
<li><p>cfg:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">CONFIG_USB_MTK_HDRC</span><span class="o">=</span><span class="n">y</span>
<span class="n">CONFIG_MTK_MUSB_QMU_SUPPORT</span><span class="o">=</span><span class="n">y</span>
<span class="n">CONFIG_MTK_MUSB_QMU_PURE_ZLP_SUPPORT</span><span class="o">=</span><span class="n">y</span>
<span class="n">CONFIG_MTK_MUSB_DRV_36BIT</span><span class="o">=</span><span class="n">y</span>
<span class="n">CONFIG_USB_MTK_OTG</span><span class="o">=</span><span class="n">y</span>
</pre></div>
</div>
<ul class="simple">
<li><p>Kconfig:</p></li>
</ul>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>涉及文件：
wugn@jcrj-tf-compile:kernel-4.19$ <span class="nb">cd</span> drivers/misc/mediatek/usb20/
wugn@jcrj-tf-compile:usb20$ tree
.
├── Kconfig
├── Makefile
├── mt6765
│   ├── Makefile
│   ├── mtk-phy-a60810.h
│   ├── otg.c
│   ├── usb20.c
│   ├── usb20.h
│   ├── usb20_host.c
│   ├── usb20_otg_if.c
│   ├── usb20_phy.c
│   └── usb20_phy_debugfs.c
├── mtk_dual_role.c
├── mtk_musb.h
├── mtk_musb_reg.h
├── mtk_qmu.c
├── mtk_qmu.h
├── musb_core.c //入口驱动
├── musb_core.h
├── musb_debugfs.c
├── musb_debug.h
├── musb_dma.h
├── musb_gadget.c //从控制器
├── musb_gadget_ep0.c
├── musb_gadget.h
├── musb.h
├── musb_host.c //主控制器
├── musb_host.h
├── musbhsdma.c
├── musbhsdma.h
├── musb_io.h
├── musb_qmu.c
├── musb_qmu.h
└── musb_virthub.c

<span class="c1">#Platform</span>
obj-<span class="k">$(</span>CONFIG_MACH_MT6765<span class="k">)</span> +<span class="o">=</span> <span class="k">$(</span>subst <span class="s2">&quot;,,</span><span class="k">$(</span>CONFIG_MTK_PLATFORM<span class="k">)</span><span class="s2">)/    就是mt6765文件</span>

<span class="s2">#Driver</span>
<span class="s2">obj-</span><span class="k">$(</span>CONFIG_USB_MTK_HDRC<span class="k">)</span><span class="s2"> += musb_hdrc.o</span>
<span class="s2">musb_hdrc-</span><span class="k">$(</span>CONFIG_USB_MTK_HDRC<span class="k">)</span><span class="s2"> := musb_core.o</span>
<span class="s2">musb_hdrc-</span><span class="k">$(</span>CONFIG_USB_MTK_HDRC<span class="k">)</span><span class="s2"> += musb_gadget_ep0.o musb_gadget.o</span>
<span class="s2">musb_hdrc-</span><span class="k">$(</span>CONFIG_USB_MTK_HDRC<span class="k">)</span><span class="s2"> += musb_virthub.o musb_host.o</span>
<span class="s2">musb_hdrc-</span><span class="k">$(</span>CONFIG_USB_MTK_HDRC<span class="k">)</span><span class="s2"> += musbhsdma.o</span>

<span class="s2"># QMU Realted</span>
<span class="s2">obj-</span><span class="k">$(</span>CONFIG_MTK_MUSB_QMU_SUPPORT<span class="k">)</span><span class="s2"> += mtk_qmu.o musb_qmu.o</span>
<span class="s2">ifeq (</span><span class="k">$(</span>CONFIG_MTK_MUSB_QMU_SUPPORT<span class="k">)</span><span class="s2">,y)</span>
<span class="s2">subdir-ccflags-</span><span class="k">$(</span>CONFIG_MACH_MT8163<span class="k">)</span><span class="s2"> += -DMUSB_QMU_LIMIT_SUPPORT -DMUSB_QMU_LIMIT_RXQ_NUM=4 -DMUSB_QMU_LIMIT_TXQ_NUM=4</span>
<span class="s2">endif</span>
<span class="s2">ifeq (</span><span class="k">$(</span>CONFIG_MTK_MUSB_QMU_SUPPORT<span class="k">)</span><span class="s2">,y)</span>
<span class="s2">subdir-ccflags-</span><span class="k">$(</span>CONFIG_MACH_MT8167<span class="k">)</span><span class="s2"> += -DMUSB_QMU_LIMIT_SUPPORT -DMUSB_QMU_LIMIT_RXQ_NUM=4 -DMUSB_QMU_LIMIT_TXQ_NUM=4</span>
<span class="s2">endif</span>
</pre></div>
</div>
<ul class="simple">
<li><p>dts：</p></li>
</ul>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span>usb: usb0@11200000 {
        compatible = &quot;mediatek,mt6765-usb20&quot;;
        reg = &lt;0 0x11200000 0 0x10000&gt;,
                &lt;0 0x11CC0000 0 0x10000&gt;;
        interrupts = &lt;GIC_SPI 73 IRQ_TYPE_LEVEL_LOW&gt;;
        mode = &lt;2&gt;;
        multipoint = &lt;1&gt;;
        num_eps = &lt;16&gt;;
        clocks = &lt;&amp;infracfg_ao CLK_IFR_ICUSB&gt;,
                &lt;&amp;topckgen CLK_TOP_USB_TOP_SEL&gt;,
                &lt;&amp;topckgen CLK_TOP_UNIVPLL3_D4&gt;;
        clock-names = &quot;usb0&quot;,
                &quot;usb0_clk_top_sel&quot;,
                &quot;usb0_clk_univpll3_d4&quot;;
        charger = &lt;&amp;mt6370_chg&gt;;
};

修改usb驱动能力：
&amp;usb {
    usb_tuning {
        compatible = &quot;mediatek,phy_tuning&quot;;
        u2_vrt_ref = &lt;7&gt;;
        u2_term_ref = &lt;0&gt;;
    };
};

默认host模式：
&amp;usb {
        bootmode = &lt;&amp;chosen&gt;;
        default_mode = &lt;1&gt;; //0-device mode, 1-host mode
        pogo_dev_detect_type = &lt;2&gt;;
};
</pre></div>
</div>
</section>
<section id="id3">
<h1>软件流程<a class="headerlink" href="#id3" title="此标题的永久链接"></a></h1>
<p>总体流程图如下：</p>
<p><img alt="0001_0006.png" src="../../../_images/0001_00062.png" /></p>
<section id="musb-core">
<h2>musb_core注册过程<a class="headerlink" href="#musb-core" title="此标题的永久链接"></a></h2>
<p><code class="docutils literal notranslate"><span class="pre">musb_core.c</span></code>platform driver注册如下，名称为musb-hdrc:</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#define MUSB_DRIVER_NAME &quot;musb-hdrc&quot;</span>
<span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">musb_driver_name</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MUSB_DRIVER_NAME</span><span class="p">;</span><span class="w"></span>
<span class="k">static</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">platform_driver</span><span class="w"> </span><span class="n">musb_driver</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="p">.</span><span class="n">driver</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		   </span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">musb_driver_name</span><span class="p">,</span><span class="w"></span>
<span class="w">		   </span><span class="p">.</span><span class="n">bus</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">platform_bus_type</span><span class="p">,</span><span class="w"></span>
<span class="cp">#if (!defined(CONFIG_MACH_MT2701)) &amp;&amp; (!defined(CONFIG_ARCH_MT7623))</span>
<span class="w">			</span><span class="p">.</span><span class="n">of_match_table</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">apusb_of_ids</span><span class="p">,</span><span class="w"></span>
<span class="cp">#endif</span>
<span class="w">			</span><span class="p">.</span><span class="n">owner</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">THIS_MODULE</span><span class="p">,</span><span class="w"></span>
<span class="w">		   </span><span class="p">.</span><span class="n">pm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MUSB_DEV_PM_OPS</span><span class="p">,</span><span class="w"></span>
<span class="w">		   </span><span class="p">},</span><span class="w"></span>
<span class="w">	</span><span class="p">.</span><span class="n">probe</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">musb_probe</span><span class="p">,</span><span class="w"></span>
<span class="w">	</span><span class="p">.</span><span class="n">remove</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">musb_remove</span><span class="p">,</span><span class="w"></span>
<span class="w">	</span><span class="p">.</span><span class="n">shutdown</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">musb_shutdown</span><span class="p">,</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="cm">/*-------------------------------------------------------------------------*/</span><span class="w"></span>

<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">__init</span><span class="w"> </span><span class="nf">musb_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">usb_disabled</span><span class="p">())</span><span class="w"></span>
<span class="w">		</span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="w">	</span><span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%s: version &quot;</span><span class="w"> </span><span class="n">MUSB_VERSION</span><span class="w"> </span><span class="s">&quot;, ?dma?, otg (peripheral+host)</span><span class="se">\n</span><span class="s">&quot;</span><span class="w"></span>
<span class="w">		</span><span class="p">,</span><span class="w"> </span><span class="n">musb_driver_name</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="k">return</span><span class="w"> </span><span class="n">platform_driver_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">musb_driver</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="usb20musb-hdrc-musb-core-platform-device">
<h2>usb20注册musb-hdrc（musb_core）的platform device<a class="headerlink" href="#usb20musb-hdrc-musb-core-platform-device" title="此标题的永久链接"></a></h2>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span>首先注册platform驱动为mt_usb：

static struct platform_driver mt_usb_driver = {
	.remove = mt_usb_remove,
	.probe = mt_usb_probe,
	.driver = {
		.name = &quot;mt_usb&quot;,
		.of_match_table = apusb_of_ids,
	},
};

static int __init usb20_init(void)
{
	int ret;

	DBG(0, &quot;usb20 init\n&quot;);

#ifdef CONFIG_MTK_USB2JTAG_SUPPORT
	if (usb2jtag_mode()) {
		pr_notice(&quot;[USB2JTAG] in usb2jtag mode, not to initialize usb driver\n&quot;);
		return 0;
	}
#endif

	ret = platform_driver_register(&amp;mt_usb_driver);

#ifdef FPGA_PLATFORM
	add_usb_i2c_driver();
#endif

	DBG(0, &quot;usb20 init ret:%d\n&quot;, ret);
	return ret;
}
</pre></div>
</div>
<p>probe中注册musb-hdrc驱动(usb_core)的platform_device，最主要目的是让musb-hdrc驱动能够调用mt_usb_ops操作mtk平台usb：</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span>发现mt_usb platform_device包含有musb-hdrc的platform_device:
PAYPHONEM50:/sys/devices/platform/mt_usb/musb-hdrc # ls -l
total 0
-rw-rw-r-- 1 root system 4096 2010-01-01 00:00 cmode
lrwxrwxrwx 1 root root      0 2022-06-24 08:06 driver -&gt; ../../../../bus/platform/drivers/musb-hdrc
-rw-r--r-- 1 root root   4096 2022-06-24 08:06 driver_override
drwxr-xr-x 3 root root      0 2010-01-01 00:00 gadget
-r--r--r-- 1 root root   4096 2022-06-24 08:06 modalias
-r--r--r-- 1 root root   4096 2022-06-24 08:06 pools
drwxr-xr-x 2 root root      0 2010-01-01 00:00 power
lrwxrwxrwx 1 root root      0 2022-06-24 08:06 subsystem -&gt; ../../../../bus/platform
drwxr-xr-x 3 root root      0 2010-01-01 00:00 udc
-rw-r--r-- 1 root root   4096 2010-01-01 00:00 uevent
drwxr-xr-x 5 root root      0 2010-01-01 00:00 usb1

static const struct musb_platform_ops mt_usb_ops = {
	.init = mt_usb_init,
	.exit = mt_usb_exit,
	/*.set_mode     = mt_usb_set_mode, */
#if defined(CONFIG_MTK_BASE_POWER)
	.try_idle = mt_usb_try_idle,
#endif
	.enable = mt_usb_enable,
	.disable = mt_usb_disable,
	/* .set_vbus = mt_usb_set_vbus, */
	.vbus_status = mt_usb_get_vbus_status,
	.enable_clk =  mt_usb_enable_clk,
	.disable_clk =  mt_usb_disable_clk,
	.prepare_clk = mt_usb_prepare_clk,
	.unprepare_clk = mt_usb_unprepare_clk,
};

static int mt_usb_probe(struct platform_device *pdev)
{
    struct musb_hdrc_platform_data *pdata = pdev-&gt;dev.platform_data;

    musb = platform_device_alloc(&quot;musb-hdrc&quot;, PLATFORM_DEVID_NONE); //动态分配musb-hdrcd的一个struct platform_device变量。
	if (!musb) {
		dev_notice(&amp;pdev-&gt;dev, &quot;failed to allocate musb device\n&quot;);
		goto err1;
	}

	usb_phy_base = of_iomap(np, 1);
	pdata = devm_kzalloc(&amp;pdev-&gt;dev, sizeof(*pdata), GFP_KERNEL);
	if (!pdata) {
		dev_notice(&amp;pdev-&gt;dev, &quot;failed to allocate musb platform data\n&quot;);
		goto err2;
	}

	config = devm_kzalloc(&amp;pdev-&gt;dev, sizeof(*config), GFP_KERNEL);
	if (!config) {
		/* dev_notice(&amp;pdev-&gt;dev,
		 * &quot;failed to allocate musb hdrc config\n&quot;);
		 */
		goto err2;
	}

	pdata-&gt;config = config;

	musb-&gt;dev.parent = &amp;pdev-&gt;dev;
	musb-&gt;dev.dma_mask = &amp;mt_usb_dmamask;
	musb-&gt;dev.coherent_dma_mask = mt_usb_dmamask;

	pdev-&gt;dev.dma_mask = &amp;mt_usb_dmamask;
	pdev-&gt;dev.coherent_dma_mask = mt_usb_dmamask;
	arch_setup_dma_ops(&amp;musb-&gt;dev, 0, mt_usb_dmamask, NULL, 0);

	glue-&gt;dev = &amp;pdev-&gt;dev;
	glue-&gt;musb = musb; //glue作为

	pdata-&gt;platform_ops = &amp;mt_usb_ops;

	ret = device_rename(&amp;pdev-&gt;dev, &quot;mt_usb&quot;); //名字改回来了
	if (ret)
		dev_notice(&amp;pdev-&gt;dev, &quot;failed to rename\n&quot;);
	/*
	 * fix uaf(use afer free) issue:backup pdev-&gt;name,
	 * device_rename will free pdev-&gt;name
	 */
	pdev-&gt;name = pdev-&gt;dev.kobj.name;

	platform_set_drvdata(pdev, glue);

	ret = platform_device_add_resources(musb,
				pdev-&gt;resource, pdev-&gt;num_resources); //向platform device中增加资源描述。
	if (ret) {
		dev_notice(&amp;pdev-&gt;dev, &quot;failed to add resources\n&quot;);
		goto err2;
	}

	ret = platform_device_add_data(musb, pdata, sizeof(*pdata)); //向platform device中添加自定义的数据，最主要是的mt_usb_ops
	if (ret) {
		dev_notice(&amp;pdev-&gt;dev, &quot;failed to add platform_data\n&quot;);
		goto err2;
	}

	ret = platform_device_add(musb);// 注册musb-hdrc的platform device

	if (ret) {
		dev_notice(&amp;pdev-&gt;dev, &quot;failed to register musb device\n&quot;);
		goto err2;
	}
}
</pre></div>
</div>
</section>
<section id="musb-core-cmusb20-cprobe">
<h2>musb_core.c和musb20.c关系及probe流程<a class="headerlink" href="#musb-core-cmusb20-cprobe" title="此标题的永久链接"></a></h2>
<p>1.在mt6765目录下的usb20.c中的mt_usb_probe函数中,musb_hdrc_platform_data类型的结构中的指针成员platform_ops指向musb_platform_ops类型的mt_usb_ops结构。
2.之后通过platform_device_add_data函数将platform device结构中的device结构中的指针platform_data成员指向musb_hdrc_platform_data类型的结构。</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">mt_usb_probe</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">platform_device</span><span class="w"> </span><span class="o">*</span><span class="n">pdev</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">musb_hdrc_platform_data</span><span class="w"> </span><span class="o">*</span><span class="n">pdata</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">platform_data</span><span class="p">;</span><span class="w"></span>

<span class="n">pdata</span><span class="o">-&gt;</span><span class="n">platform_ops</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">mt_usb_ops</span><span class="p">;</span><span class="w"></span>
<span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">platform_device_add_data</span><span class="p">(</span><span class="n">musb</span><span class="p">,</span><span class="w"> </span><span class="n">pdata</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">pdata</span><span class="p">));</span><span class="w"> </span><span class="c1">//向platform device中添加自定义的数据，最主要是的mt_usb_ops</span>

<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>3.在musb core驱动的musb_probe中根据platform_device结构（就是usb20.c中的mt musb controller），获得这个结构中的device类型结构给musb_init_controller，在这个函数中，根据参数device类型的结构中的platform_data指针得到一个musb_hdrc_platform_data类型的结构，这个结构中有一个musb_hdrc_config类型的成员，根据这个成员和musb controller寄存器起始地址，通过allocate_instance创建一个musb结构。创建这个musb结构时，设置musb中的mregs成员为参数中的musb controller寄存器base address。然后在musb_init_controller函数中，将分配得到的musb结构中的musb_platform_ops类型的成员ops设置为musb_hdrc_platform_data中的platform_ops指针。然后根据musb执行musb_platform_init。</p>
<p>在这个函数中，执行musb中的musb_platform_ops类型的成员ops中的init函数。</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="o">*</span><span class="w"> </span><span class="n">musb_probe</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">platform_device</span><span class="w"> </span><span class="o">*</span><span class="n">pdev</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="o">*</span><span class="w"> </span><span class="n">iomem</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">platform_get_resource</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span><span class="w"> </span><span class="n">IORESOURCE_MEM</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="o">*</span><span class="w"> </span><span class="n">base</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">devm_ioremap</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="n">iomem</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span><span class="w"> </span><span class="n">resource_size</span><span class="p">(</span><span class="n">iomem</span><span class="p">));</span><span class="w"> </span><span class="c1">//上面两段程序能够获取usb20.c驱动里面的ops，也就是申请并映射usb20.c驱动的device resource</span>
<span class="w">  </span><span class="o">*</span><span class="w"> </span><span class="n">musb_init_controller</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="n">irq</span><span class="p">,</span><span class="w"> </span><span class="n">base</span><span class="p">,</span><span class="w"> </span><span class="n">pbase</span><span class="p">);</span><span class="w"> </span><span class="c1">//获得这个结构中的device类型结构dev给musb_init_controller</span>
<span class="w">    </span><span class="o">*</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">musb_hdrc_platform_data</span><span class="w"> </span><span class="o">*</span><span class="n">plat</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">platform_data</span><span class="p">;</span><span class="w"> </span><span class="c1">//根据参数device类型的结构中的platform_data指针得到一个musb_hdrc_platform_data类型的结构</span>
<span class="w">    </span><span class="o">*</span><span class="w"> </span><span class="n">musb</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">allocate_instance</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="n">plat</span><span class="o">-&gt;</span><span class="n">config</span><span class="p">,</span><span class="w"> </span><span class="n">ctrl</span><span class="p">);</span><span class="w"> </span><span class="c1">//创建musb结构？？</span>
<span class="w">      </span><span class="o">*</span><span class="w"> </span><span class="n">hcd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">usb_create_hcd</span><span class="p">(</span><span class="o">&amp;</span><span class="n">musb_hc_driver</span><span class="p">,</span><span class="w"> </span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="n">dev_name</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span><span class="w">  </span><span class="c1">//实例化主控制器，musb_host.c</span>
<span class="w">      </span><span class="o">*</span><span class="w"> </span><span class="n">musb</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">hcd_to_musb</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="o">*</span><span class="w"> </span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">mregs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mbase</span><span class="p">;</span><span class="w"> </span><span class="c1">//设置musb中的mregs成员为参数中的musb controller寄存器base address</span>
<span class="w">    </span><span class="o">*</span><span class="w"> </span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">ops</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">plat</span><span class="o">-&gt;</span><span class="n">platform_ops</span><span class="p">;</span><span class="w"> </span><span class="c1">//将分配得到的musb结构中的musb_platform_ops类型的成员ops设置为musb_hdrc_platform_data中的platform_ops指针</span>
<span class="w">    </span><span class="o">*</span><span class="w"> </span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">default_mode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">plat</span><span class="o">-&gt;</span><span class="n">default_mode</span><span class="p">;</span><span class="w"> </span><span class="c1">//设置默认模式</span>
<span class="w">    </span><span class="o">*</span><span class="w"> </span><span class="n">musb_platform_prepare_clk</span><span class="p">(</span><span class="n">musb</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="o">*</span><span class="w"> </span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">prepare_clk</span><span class="p">(</span><span class="n">musb</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="o">*</span><span class="w"> </span><span class="p">.</span><span class="n">prepare_clk</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mt_usb_prepare_clk</span><span class="p">,</span><span class="w"> </span><span class="c1">//usb20.c mt_usb_ops</span>
<span class="w">    </span><span class="o">*</span><span class="w"> </span><span class="n">musb_core_init</span><span class="p">(</span><span class="n">plat</span><span class="o">-&gt;</span><span class="n">config</span><span class="o">-&gt;</span><span class="n">multipoint</span><span class="o">?</span><span class="w"> </span><span class="n">MUSB_CONTROLLER_MHDRC</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">MUSB_CONTROLLER_HDRC</span><span class="p">,</span><span class="w"> </span><span class="n">musb</span><span class="p">);</span><span class="cm">/* setup musb parts of the core (especially endpoints) */</span><span class="w"></span>
<span class="w">      </span><span class="o">*</span><span class="w"> </span><span class="p">.</span><span class="n">init</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mt_usb_init</span><span class="p">,</span><span class="c1">//usb20.c mt_usb_ops 非常重要</span>
<span class="w">    </span><span class="o">*</span><span class="w"> </span><span class="n">musb_platform_enable</span><span class="p">(</span><span class="n">musb</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="o">*</span><span class="w"> </span><span class="p">.</span><span class="n">enable</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mt_usb_enable</span><span class="p">,</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="musb-core-musb-core-init">
<h2>musb_core musb_core_init流程<a class="headerlink" href="#musb-core-musb-core-init" title="此标题的永久链接"></a></h2>
<p>前面讲了usb20注册musb-hdrc（musb_core）的platform device，这样musb_core就能调用到usb20的ops，musb_core_init就是调用musb20驱动里面的mt_usb_init函数，具体看看：</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">__init</span><span class="w"> </span><span class="nf">mt_usb_init</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">musb</span><span class="w"> </span><span class="o">*</span><span class="n">musb</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="kt">int</span><span class="w"> </span><span class="n">ret</span><span class="p">;</span><span class="w"></span>

<span class="w">	</span><span class="n">DBG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">__func__</span><span class="p">);</span><span class="w"></span>

<span class="w">	</span><span class="n">usb_phy_generic_register</span><span class="p">();</span><span class="w"></span>
<span class="w">	</span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">xceiv</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">usb_get_phy</span><span class="p">(</span><span class="n">USB_PHY_TYPE_USB2</span><span class="p">);</span><span class="w"></span>

<span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">IS_ERR_OR_NULL</span><span class="p">(</span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">xceiv</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="n">DBG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;[MUSB] usb_get_phy error!!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="n">EPROBE_DEFER</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>

<span class="w">	</span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">dma_irq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">SHARE_IRQ</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">fifo_cfg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fifo_cfg</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">fifo_cfg_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">fifo_cfg</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">dyn_fifo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">power</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">is_host</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">fifo_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">1024</span><span class="p">;</span><span class="w"></span>
<span class="cp">#ifndef FPGA_PLATFORM</span>
<span class="w">	</span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">usb_rev6_setting</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">usb_rev6_setting</span><span class="p">;</span><span class="w"></span>
<span class="cp">#endif</span>

<span class="w">	</span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">usb_lock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">wakeup_source_register</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;USB suspend lock&quot;</span><span class="p">);</span><span class="w"></span>

<span class="cp">#ifndef FPGA_PLATFORM</span>
<span class="w">	</span><span class="n">reg_vusb</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">regulator_get</span><span class="p">(</span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">controller</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;vusb&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">reg_vusb</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="cp">#ifdef NEVER</span>
<span class="cp">#define	VUSB33_VOL_MIN 3070000</span>
<span class="cp">#define	VUSB33_VOL_MAX 3070000</span>
<span class="w">		</span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">regulator_set_voltage</span><span class="p">(</span><span class="n">reg_vusb</span><span class="p">,</span><span class="w"></span>
<span class="w">					</span><span class="n">VUSB33_VOL_MIN</span><span class="p">,</span><span class="w"> </span><span class="n">VUSB33_VOL_MAX</span><span class="p">);</span><span class="w"> </span><span class="c1">//设置usb vbus电压范围</span>
<span class="w">		</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ret</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">			</span><span class="n">pr_notice</span><span class="p">(</span><span class="s">&quot;regulator set vol failed: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">ret</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="k">else</span><span class="w"></span>
<span class="w">			</span><span class="n">DBG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;regulator set vol ok, &lt;%d,%d&gt;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">					</span><span class="n">VUSB33_VOL_MIN</span><span class="p">,</span><span class="w"> </span><span class="n">VUSB33_VOL_MAX</span><span class="p">);</span><span class="w"></span>
<span class="cp">#endif </span><span class="cm">/* NEVER */</span><span class="cp"></span>
<span class="w">		</span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">regulator_enable</span><span class="p">(</span><span class="n">reg_vusb</span><span class="p">);</span><span class="w"> </span><span class="c1">//使能</span>
<span class="w">		</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ret</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">			</span><span class="n">pr_notice</span><span class="p">(</span><span class="s">&quot;regulator_enable vusb failed: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">ret</span><span class="p">);</span><span class="w"></span>
<span class="w">			</span><span class="n">regulator_put</span><span class="p">(</span><span class="n">reg_vusb</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="p">}</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"></span>
<span class="w">		</span><span class="n">pr_notice</span><span class="p">(</span><span class="s">&quot;regulator_get vusb failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>


<span class="w">	</span><span class="n">reg_va12</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">regulator_get</span><span class="p">(</span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">controller</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;va12&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">reg_va12</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">regulator_enable</span><span class="p">(</span><span class="n">reg_va12</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ret</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">			</span><span class="n">pr_notice</span><span class="p">(</span><span class="s">&quot;regulator_enable va12 failed: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">ret</span><span class="p">);</span><span class="w"></span>
<span class="w">			</span><span class="n">regulator_put</span><span class="p">(</span><span class="n">reg_va12</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="p">}</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"></span>
<span class="w">		</span><span class="n">pr_notice</span><span class="p">(</span><span class="s">&quot;regulator_get va12 failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>

<span class="cp">#endif</span>

<span class="w">	</span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">device_create_file</span><span class="p">(</span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">controller</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">dev_attr_cmode</span><span class="p">);</span><span class="w"></span>

<span class="w">	</span><span class="cm">/* mt_usb_enable(musb); */</span><span class="w"></span>

<span class="w">	</span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">isr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mt_usb_interrupt</span><span class="p">;</span><span class="w">  </span><span class="c1">//配置usb中断函数</span>
<span class="w">	</span><span class="n">musb_writel</span><span class="p">(</span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">mregs</span><span class="p">,</span><span class="w"></span>
<span class="w">			</span><span class="n">MUSB_HSDMA_INTR</span><span class="p">,</span><span class="w"> </span><span class="mh">0xff</span><span class="w"> </span><span class="o">|</span><span class="w"></span>
<span class="w">			</span><span class="p">(</span><span class="mh">0xff</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">DMA_INTR_UNMASK_SET_OFFSET</span><span class="p">));</span><span class="w"></span>
<span class="w">	</span><span class="n">DBG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;musb platform init %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">			</span><span class="n">musb_readl</span><span class="p">(</span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">mregs</span><span class="p">,</span><span class="w"> </span><span class="n">MUSB_HSDMA_INTR</span><span class="p">));</span><span class="w"></span>

<span class="cp">#ifdef CONFIG_MTK_MUSB_QMU_SUPPORT</span>
<span class="w">	</span><span class="cm">/* FIXME, workaround for device_qmu + host_dma */</span><span class="w"></span>
<span class="w">	</span><span class="n">musb_writel</span><span class="p">(</span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">mregs</span><span class="p">,</span><span class="w"></span>
<span class="w">			</span><span class="n">USB_L1INTM</span><span class="p">,</span><span class="w"></span>
<span class="w">		    </span><span class="n">TX_INT_STATUS</span><span class="w"> </span><span class="o">|</span><span class="w"></span>
<span class="w">		    </span><span class="n">RX_INT_STATUS</span><span class="w"> </span><span class="o">|</span><span class="w"></span>
<span class="w">		    </span><span class="n">USBCOM_INT_STATUS</span><span class="w"> </span><span class="o">|</span><span class="w"></span>
<span class="w">		    </span><span class="n">DMA_INT_STATUS</span><span class="w"> </span><span class="o">|</span><span class="w"></span>
<span class="w">		    </span><span class="n">QINT_STATUS</span><span class="p">);</span><span class="w"></span>
<span class="cp">#else</span>
<span class="w">	</span><span class="n">musb_writel</span><span class="p">(</span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">mregs</span><span class="p">,</span><span class="w"></span>
<span class="w">			</span><span class="n">USB_L1INTM</span><span class="p">,</span><span class="w"></span>
<span class="w">		    </span><span class="n">TX_INT_STATUS</span><span class="w"> </span><span class="o">|</span><span class="w"></span>
<span class="w">		    </span><span class="n">RX_INT_STATUS</span><span class="w"> </span><span class="o">|</span><span class="w"></span>
<span class="w">		    </span><span class="n">USBCOM_INT_STATUS</span><span class="w"> </span><span class="o">|</span><span class="w"></span>
<span class="w">		    </span><span class="n">DMA_INT_STATUS</span><span class="p">);</span><span class="w"></span>
<span class="cp">#endif</span>
<span class="cp">#if defined(CONFIG_MTK_BASE_POWER)</span>
<span class="w">	</span><span class="n">timer_setup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">idle_timer</span><span class="p">,</span><span class="w"> </span><span class="n">musb_do_idle</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_USB_MTK_OTG</span>
<span class="w">	</span><span class="n">mt_usb_otg_init</span><span class="p">(</span><span class="n">musb</span><span class="p">);</span><span class="w"> </span><span class="c1">//这里很重要，使能otg功能，也就是根据cc/id脚切换device/host</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_MACH_MT6761</span>
<span class="w">	</span><span class="cm">/* only for mt6761 */</span><span class="w"></span>
<span class="w">	</span><span class="n">usb_sram_init</span><span class="p">();</span><span class="w"></span>
<span class="cp">#endif</span>
<span class="w">	</span><span class="n">mt_usb_psy_init</span><span class="p">(</span><span class="n">musb</span><span class="p">);</span><span class="w"> </span><span class="c1">//这里也是</span>
<span class="w">	</span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<section id="mt-usb-interrupt">
<h3>mt_usb_interrupt中断函数<a class="headerlink" href="#mt-usb-interrupt" title="此标题的永久链接"></a></h3>
<p>这里是处理usb中断的，包括irq sources (phy, dma, etc)，这块暂时没研究。</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="n">irqreturn_t</span><span class="w"> </span><span class="nf">mt_usb_interrupt</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">irq</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">dev_id</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="n">irqreturn_t</span><span class="w"> </span><span class="n">tmp_status</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">irqreturn_t</span><span class="w"> </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">IRQ_NONE</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="k">struct</span><span class="w"> </span><span class="nc">musb</span><span class="w"> </span><span class="o">*</span><span class="n">musb</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">musb</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">dev_id</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">u32</span><span class="w"> </span><span class="n">usb_l1_ints</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">flags</span><span class="p">;</span><span class="w"></span>

<span class="w">	</span><span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span><span class="w"> </span><span class="n">flags</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="n">usb_l1_ints</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">musb_readl</span><span class="p">(</span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">mregs</span><span class="p">,</span><span class="w"> </span><span class="n">USB_L1INTS</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"></span>
<span class="w">		</span><span class="n">musb_readl</span><span class="p">(</span><span class="n">mtk_musb</span><span class="o">-&gt;</span><span class="n">mregs</span><span class="p">,</span><span class="w"> </span><span class="n">USB_L1INTM</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="n">DBG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;usb interrupt assert %x %x  %x %x %x %x %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">usb_l1_ints</span><span class="p">,</span><span class="w"></span>
<span class="w">	    </span><span class="n">musb_readl</span><span class="p">(</span><span class="n">mtk_musb</span><span class="o">-&gt;</span><span class="n">mregs</span><span class="p">,</span><span class="w"> </span><span class="n">USB_L1INTM</span><span class="p">),</span><span class="w"></span>
<span class="w">	    </span><span class="n">musb_readb</span><span class="p">(</span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">mregs</span><span class="p">,</span><span class="w"> </span><span class="n">MUSB_INTRUSBE</span><span class="p">),</span><span class="w"></span>
<span class="w">		</span><span class="n">musb_readw</span><span class="p">(</span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">mregs</span><span class="p">,</span><span class="w"> </span><span class="n">MUSB_INTRTX</span><span class="p">),</span><span class="w"></span>
<span class="w">		</span><span class="n">musb_readw</span><span class="p">(</span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">mregs</span><span class="p">,</span><span class="w"> </span><span class="n">MUSB_INTRTXE</span><span class="p">),</span><span class="w"></span>
<span class="w">		</span><span class="n">musb_readw</span><span class="p">(</span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">mregs</span><span class="p">,</span><span class="w"> </span><span class="n">MUSB_INTRRX</span><span class="p">),</span><span class="w"></span>
<span class="w">		</span><span class="n">musb_readw</span><span class="p">(</span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">mregs</span><span class="p">,</span><span class="w"> </span><span class="n">MUSB_INTRRXE</span><span class="p">));</span><span class="w"></span>

<span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">usb_l1_ints</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">TX_INT_STATUS</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">(</span><span class="n">usb_l1_ints</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">RX_INT_STATUS</span><span class="p">)</span><span class="w"></span>
<span class="w">	    </span><span class="o">||</span><span class="w"> </span><span class="p">(</span><span class="n">usb_l1_ints</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">USBCOM_INT_STATUS</span><span class="p">)</span><span class="w"></span>
<span class="cp">#ifdef CONFIG_MTK_MUSB_QMU_SUPPORT</span>
<span class="w">	    </span><span class="o">||</span><span class="w"> </span><span class="p">(</span><span class="n">usb_l1_ints</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">QINT_STATUS</span><span class="p">)</span><span class="w"></span>
<span class="cp">#endif</span>
<span class="w">	   </span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="n">tmp_status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">generic_interrupt</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span><span class="w"> </span><span class="n">musb</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">tmp_status</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">IRQ_NONE</span><span class="p">)</span><span class="w"></span>
<span class="w">			</span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tmp_status</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>
<span class="w">	</span><span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span><span class="w"> </span><span class="n">flags</span><span class="p">);</span><span class="w"></span>

<span class="w">	</span><span class="cm">/* FIXME, workaround for device_qmu + host_dma */</span><span class="w"></span>
<span class="cm">/* #ifndef CONFIG_MTK_MUSB_QMU_SUPPORT */</span><span class="w"></span>
<span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">usb_l1_ints</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">DMA_INT_STATUS</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="n">tmp_status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dma_controller_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span><span class="w"> </span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">dma_controller</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">tmp_status</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">IRQ_NONE</span><span class="p">)</span><span class="w"></span>
<span class="w">			</span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tmp_status</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>

<span class="w">	</span><span class="k">return</span><span class="w"> </span><span class="n">status</span><span class="p">;</span><span class="w"></span>

<span class="p">}</span><span class="w"></span>

<span class="o">*</span><span class="w"> </span><span class="n">generic_interrupt</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">irq</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">__hci</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="o">*</span><span class="w"> </span><span class="n">musb_interrupt</span><span class="p">(</span><span class="n">musb</span><span class="p">);</span><span class="w"></span>

<span class="cm">/*</span>
<span class="cm"> * handle all the irqs defined by the HDRC core. for now we expect:  other</span>
<span class="cm"> * irq sources (phy, dma, etc) will be handled first, musb-&gt;int_* values</span>
<span class="cm"> * will be assigned, and the irq will already have been acked.</span>
<span class="cm"> *</span>
<span class="cm"> * called in irq context with spinlock held, irqs blocked</span>
<span class="cm"> */</span><span class="w"></span>
<span class="n">irqreturn_t</span><span class="w"> </span><span class="nf">musb_interrupt</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">musb</span><span class="w"> </span><span class="o">*</span><span class="n">musb</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="n">irqreturn_t</span><span class="w"> </span><span class="n">retval</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">IRQ_NONE</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">u8</span><span class="w"> </span><span class="n">devctl</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="kt">int</span><span class="w"> </span><span class="n">ep_num</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">u32</span><span class="w"> </span><span class="n">reg</span><span class="p">;</span><span class="w"></span>

<span class="w">	</span><span class="n">devctl</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">musb_readb</span><span class="p">(</span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">mregs</span><span class="p">,</span><span class="w"> </span><span class="n">MUSB_DEVCTL</span><span class="p">);</span><span class="w"></span>
<span class="cp">#ifdef CONFIG_MTK_MUSB_QMU_SUPPORT</span>
<span class="w">	</span><span class="n">DBG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;usb(%x) tx(%x) rx(%x) queue(%x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">		</span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">int_usb</span><span class="p">,</span><span class="w"> </span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">int_tx</span><span class="p">,</span><span class="w"> </span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">int_rx</span><span class="p">,</span><span class="w"> </span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">int_queue</span><span class="p">);</span><span class="w"></span>
<span class="cp">#else</span>
<span class="w">	</span><span class="n">DBG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;** IRQ %s usb%04x tx%04x rx%04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">	    </span><span class="p">(</span><span class="n">devctl</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">MUSB_DEVCTL_HM</span><span class="p">)</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="s">&quot;host&quot;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="s">&quot;peripheral&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">	    </span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">int_usb</span><span class="p">,</span><span class="w"> </span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">int_tx</span><span class="p">,</span><span class="w"> </span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">int_rx</span><span class="p">);</span><span class="w"></span>
<span class="cp">#endif</span>

<span class="w">	</span><span class="n">dumpTime</span><span class="p">(</span><span class="n">funcInterrupt</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>

<span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">softconnect</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="n">devctl</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">MUSB_DEVCTL_HM</span><span class="p">)))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="n">DBG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;!softconnect, IRQ usb%04x tx%04x rx%04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">			</span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">int_usb</span><span class="p">,</span><span class="w"> </span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">int_tx</span><span class="p">,</span><span class="w"> </span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">int_rx</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="k">return</span><span class="w"> </span><span class="n">IRQ_HANDLED</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>

<span class="w">	</span><span class="cm">/* the core can interrupt us for multiple reasons; docs have</span>
<span class="cm">	 * a generic interrupt flowchart to follow</span>
<span class="cm">	 */</span><span class="w"></span>
<span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">int_usb</span><span class="p">)</span><span class="w"></span>
<span class="w">		</span><span class="n">retval</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">musb_stage0_irq</span><span class="p">(</span><span class="n">musb</span><span class="p">,</span><span class="w"> </span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">int_usb</span><span class="p">,</span><span class="w"> </span><span class="n">devctl</span><span class="p">);</span><span class="w"></span>

<span class="w">	</span><span class="cm">/* &quot;stage 1&quot; is handling endpoint irqs */</span><span class="w"></span>

<span class="w">	</span><span class="cm">/* handle endpoint 0 first */</span><span class="w"></span>
<span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">int_tx</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">devctl</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">MUSB_DEVCTL_HM</span><span class="p">)</span><span class="w"></span>
<span class="w">			</span><span class="n">retval</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">musb_h_ep0_irq</span><span class="p">(</span><span class="n">musb</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="k">else</span><span class="w"></span>
<span class="w">			</span><span class="n">retval</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">musb_g_ep0_irq</span><span class="p">(</span><span class="n">musb</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>

<span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">power</span><span class="p">))</span><span class="w"></span>
<span class="w">		</span><span class="k">return</span><span class="w"> </span><span class="n">IRQ_HANDLED</span><span class="p">;</span><span class="w"></span>

<span class="cp">#ifdef CONFIG_MTK_MUSB_QMU_SUPPORT</span>
<span class="w">	</span><span class="cm">/* process generic queue interrupt */</span><span class="w"></span>
<span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">int_queue</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="n">musb_q_irq</span><span class="p">(</span><span class="n">musb</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="n">retval</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">IRQ_HANDLED</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>
<span class="cp">#endif</span>

<span class="w">	</span><span class="cm">/* FIXME, workaround for device_qmu + host_dma */</span><span class="w"></span>
<span class="cm">/* #ifndef MUSB_QMU_SUPPORT */</span><span class="w"></span>
<span class="w">	</span><span class="cm">/* RX on endpoints 1-15 */</span><span class="w"></span>
<span class="w">	</span><span class="n">reg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">int_rx</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">ep_num</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">reg</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">reg</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">			</span><span class="cm">/* musb_ep_select(musb-&gt;mregs, ep_num); */</span><span class="w"></span>
<span class="w">			</span><span class="cm">/* REVISIT just retval = ep-&gt;rx_irq(...) */</span><span class="w"></span>
<span class="w">			</span><span class="n">retval</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">IRQ_HANDLED</span><span class="p">;</span><span class="w"></span>
<span class="w">			</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">devctl</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">MUSB_DEVCTL_HM</span><span class="p">)</span><span class="w"></span>
<span class="w">				</span><span class="n">musb_host_rx</span><span class="p">(</span><span class="n">musb</span><span class="p">,</span><span class="w"> </span><span class="n">ep_num</span><span class="p">);</span><span class="w"></span>
<span class="w">			</span><span class="k">else</span><span class="w"></span>
<span class="w">				</span><span class="n">musb_g_rx</span><span class="p">(</span><span class="n">musb</span><span class="p">,</span><span class="w"> </span><span class="n">ep_num</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="p">}</span><span class="w"></span>

<span class="w">		</span><span class="n">reg</span><span class="w"> </span><span class="o">&gt;&gt;=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">		</span><span class="n">ep_num</span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>

<span class="w">	</span><span class="cm">/* TX on endpoints 1-15 */</span><span class="w"></span>
<span class="w">	</span><span class="n">reg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">int_tx</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">ep_num</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">reg</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">reg</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">			</span><span class="cm">/* musb_ep_select(musb-&gt;mregs, ep_num); */</span><span class="w"></span>
<span class="w">			</span><span class="cm">/* REVISIT just retval |= ep-&gt;tx_irq(...) */</span><span class="w"></span>
<span class="w">			</span><span class="n">retval</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">IRQ_HANDLED</span><span class="p">;</span><span class="w"></span>
<span class="w">			</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">devctl</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">MUSB_DEVCTL_HM</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">				</span><span class="kt">bool</span><span class="w"> </span><span class="n">skip_tx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="w">				</span><span class="k">static</span><span class="w"> </span><span class="n">DEFINE_RATELIMIT_STATE</span><span class="p">(</span><span class="n">rlmt</span><span class="p">,</span><span class="w"> </span><span class="n">HZ</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span><span class="w"></span>
<span class="w">				</span><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">skip_cnt</span><span class="p">;</span><span class="w"></span>

<span class="w">				</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">musb_host_db_enable</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">host_tx_refcnt_dec</span><span class="p">(</span><span class="n">ep_num</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">					</span><span class="kt">int</span><span class="w"> </span><span class="n">ref_cnt</span><span class="p">;</span><span class="w"></span>

<span class="w">					</span><span class="n">musb_host_db_workaround_cnt</span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="w">					</span><span class="n">ref_cnt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">host_tx_refcnt_inc</span><span class="p">(</span><span class="n">ep_num</span><span class="p">);</span><span class="w"></span>

<span class="w">					</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">__ratelimit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rlmt</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">						</span><span class="n">DBG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"></span>
<span class="w">							</span><span class="s">&quot;unexpect TX &lt;%d,%d,%d&gt;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">							</span><span class="n">ep_num</span><span class="p">,</span><span class="w"> </span><span class="n">ref_cnt</span><span class="p">,</span><span class="w"></span>
<span class="w">							</span><span class="n">skip_cnt</span><span class="p">);</span><span class="w"></span>
<span class="w">						</span><span class="n">dump_tx_ops</span><span class="p">(</span><span class="n">ep_num</span><span class="p">);</span><span class="w"></span>
<span class="w">						</span><span class="n">skip_cnt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">					</span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"></span>
<span class="w">						</span><span class="n">skip_cnt</span><span class="o">++</span><span class="p">;</span><span class="w"></span>

<span class="w">					</span><span class="n">skip_tx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="w">				</span><span class="p">}</span><span class="w"></span>

<span class="w">				</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">skip_tx</span><span class="p">))</span><span class="w"></span>
<span class="w">					</span><span class="n">musb_host_tx</span><span class="p">(</span><span class="n">musb</span><span class="p">,</span><span class="w"> </span><span class="n">ep_num</span><span class="p">);</span><span class="w"></span>
<span class="w">			</span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"></span>
<span class="w">				</span><span class="n">musb_g_tx</span><span class="p">(</span><span class="n">musb</span><span class="p">,</span><span class="w"> </span><span class="n">ep_num</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="p">}</span><span class="w"></span>
<span class="w">		</span><span class="n">reg</span><span class="w"> </span><span class="o">&gt;&gt;=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">		</span><span class="n">ep_num</span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>

<span class="w">	</span><span class="k">return</span><span class="w"> </span><span class="n">retval</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="otg-mt-usb-otg-init">
<h3>otg初始化(mt_usb_otg_init)<a class="headerlink" href="#otg-mt-usb-otg-init" title="此标题的永久链接"></a></h3>
<p>接下来看看mt_usb_otg_init，使能otg功能，也就是根据cc/id脚切换device/host，这里定义了CONFIG_TCPC_CLASS，也就是用的typec的cc脚切主从，不会跑iddig_int_init函数，</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">mt_usb_otg_init</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">musb</span><span class="w"> </span><span class="o">*</span><span class="n">musb</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="cm">/* test */</span><span class="w"></span>
<span class="w">	</span><span class="n">INIT_DELAYED_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">host_plug_test_work</span><span class="p">,</span><span class="w"> </span><span class="n">do_host_plug_test_work</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="n">ktime_start</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ktime_get</span><span class="p">();</span><span class="w"></span>

<span class="w">	</span><span class="cm">/* CONNECTION MANAGEMENT*/</span><span class="w"></span>
<span class="cp">#ifdef CONFIG_MTK_USB_TYPEC</span>
<span class="w">	</span><span class="n">DBG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;host controlled by TYPEC</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="n">typec_control</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="cp">#ifdef CONFIG_TCPC_CLASS</span>
<span class="w">	</span><span class="n">INIT_DELAYED_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">register_otg_work</span><span class="p">,</span><span class="w"> </span><span class="n">do_register_otg_work</span><span class="p">);</span><span class="w"></span>
<span class="cm">/* Add-BEGIN by (shanliangliang@paxsz.com), 2021/08/27 fix notifier reigister too late */</span><span class="w"></span>
<span class="w">	</span><span class="n">schedule_delayed_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">register_otg_work</span><span class="p">,</span><span class="w"></span>
<span class="w">			</span><span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">REGISTER_OTG_WORK_DELAY</span><span class="p">));</span><span class="w"> </span><span class="c1">//重要，调用do_register_otg_work工作队列</span>
<span class="cm">/* Add-END by (shanliangliang@paxsz.com), 2021/08/27 fix notifier reigister too late */</span><span class="w"></span>
<span class="w">	</span><span class="n">vbus_control</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="cp">#endif</span>
<span class="cp">#else</span>
<span class="w">	</span><span class="n">DBG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;host controlled by IDDIG</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="n">iddig_int_init</span><span class="p">();</span><span class="w"></span>
<span class="w">	</span><span class="n">vbus_control</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="cp">#endif</span>

<span class="w">	</span><span class="cm">/* EP table */</span><span class="w"></span>
<span class="w">	</span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">fifo_cfg_host</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fifo_cfg_host</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">fifo_cfg_host_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">fifo_cfg_host</span><span class="p">);</span><span class="w"></span>

<span class="w">	</span><span class="cm">/* Add-BEGIN by (shanliangliang@paxsz.com), 2021/08/15 add for M8 usb otg */</span><span class="w"></span>
<span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">default_mode</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">MUSB_HOST</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="n">mt_usb_host_connect</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w">   </span><span class="c1">//默认dts如果定义了host，则使能host</span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>
<span class="w">	</span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">lcd_state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FB_BLANK_UNBLANK</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">fb_register_client</span><span class="p">(</span><span class="o">&amp;</span><span class="n">musb_fb_notifier</span><span class="p">);</span><span class="w"></span>

<span class="w">	</span><span class="n">musb_chg_dev_init</span><span class="p">(</span><span class="n">musb</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="cm">/* Add-END by (shanliangliang@paxsz.com), 2021/08/15 add for M8 usb otg */</span><span class="w"></span>

<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="do-register-otg-worknotifytcpc">
<h3>do_register_otg_work注册notify监听tcpc<a class="headerlink" href="#do-register-otg-worknotifytcpc" title="此标题的永久链接"></a></h3>
<p>1.获取typec设备名称type_c_port0，获取不到就反复schedule_delayed_work调用本身获取。
2.通过register_tcp_dev_notifier注册监听vbus和usb状态。</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#define TCPC_OTG_DEV_NAME &quot;type_c_port0&quot;</span>
<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">do_register_otg_work</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">work_struct</span><span class="w"> </span><span class="o">*</span><span class="n">data</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="cm">/* Add-BEGIN by (shanliangliang@paxsz.com), 2021/08/27 fix notifier reigister too late */</span><span class="w"></span>
<span class="cp">#define REGISTER_OTG_WORK_DELAY 200</span>
<span class="cm">/* Add-END by (shanliangliang@paxsz.com), 2021/08/27 fix notifier reigister too late */</span><span class="w"></span>
<span class="w">	</span><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">ret</span><span class="p">;</span><span class="w"></span>

<span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">otg_tcpc_dev</span><span class="p">)</span><span class="w"></span>
<span class="w">		</span><span class="n">otg_tcpc_dev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tcpc_dev_get_by_name</span><span class="p">(</span><span class="n">TCPC_OTG_DEV_NAME</span><span class="p">);</span><span class="w"></span>

<span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">otg_tcpc_dev</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="n">DBG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;get type_c_port0 fail</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="cm">/* Add-BEGIN by (shanliangliang@paxsz.com), 2021/08/27 fix notifier reigister too late */</span><span class="w"></span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">		queue_delayed_work(mtk_musb-&gt;st_wq, &amp;register_otg_work,</span>
<span class="c">				msecs_to_jiffies(REGISTER_OTG_WORK_DELAY));</span>
<span class="cp">#else</span>
<span class="w">		</span><span class="n">schedule_delayed_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">register_otg_work</span><span class="p">,</span><span class="w"></span>
<span class="w">				</span><span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">REGISTER_OTG_WORK_DELAY</span><span class="p">));</span><span class="w"></span>
<span class="cp">#endif</span>
<span class="cm">/* Add-END by (shanliangliang@paxsz.com), 2021/08/27 fix notifier reigister too late */</span><span class="w"></span>
<span class="w">		</span><span class="k">return</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>

<span class="w">	</span><span class="n">otg_nb</span><span class="p">.</span><span class="n">notifier_call</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">otg_tcp_notifier_call</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">register_tcp_dev_notifier</span><span class="p">(</span><span class="n">otg_tcpc_dev</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">otg_nb</span><span class="p">,</span><span class="w"></span>
<span class="w">		</span><span class="n">TCP_NOTIFY_TYPE_VBUS</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">TCP_NOTIFY_TYPE_USB</span><span class="w"> </span><span class="o">|</span><span class="w"></span>
<span class="w">		</span><span class="n">TCP_NOTIFY_TYPE_MISC</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ret</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="n">DBG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;register OTG &lt;%p&gt; fail</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">otg_tcpc_dev</span><span class="p">);</span><span class="w"></span>
<span class="cm">/* Add-BEGIN by (shanliangliang@paxsz.com), 2021/08/27 fix notifier reigister too late */</span><span class="w"></span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">		queue_delayed_work(mtk_musb-&gt;st_wq, &amp;register_otg_work,</span>
<span class="c">				msecs_to_jiffies(REGISTER_OTG_WORK_DELAY));</span>
<span class="cp">#else</span>
<span class="w">		</span><span class="n">schedule_delayed_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">register_otg_work</span><span class="p">,</span><span class="w"></span>
<span class="w">				</span><span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">REGISTER_OTG_WORK_DELAY</span><span class="p">));</span><span class="w"></span>
<span class="cp">#endif</span>
<span class="cm">/* Add-END by (shanliangliang@paxsz.com), 2021/08/27 fix notifier reigister too late */</span><span class="w"></span>
<span class="w">		</span><span class="k">return</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>

<span class="w">	</span><span class="n">DBG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;register OTG &lt;%p&gt; ok</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">otg_tcpc_dev</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>监听函数如下：</p>
<p>这个地方是就是根据cc状态控制usb vbus和otg功能的，具体解释可以参考文档</p>
<p><span class="xref myst">usb_switch</span></p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span>static int otg_tcp_notifier_call(struct notifier_block *nb,
		unsigned long event, void *data)
{
	struct tcp_notify *noti = data;

	switch (event) {
	case TCP_NOTIFY_SOURCE_VBUS:
		DBG(0, &quot;source vbus = %dmv\n&quot;, noti-&gt;vbus_state.mv);
		if (noti-&gt;vbus_state.mv)
			mt_usb_vbus_on(0);
		else
			mt_usb_vbus_off(0);
		break;
	case TCP_NOTIFY_TYPEC_STATE:
		DBG(0, &quot;TCP_NOTIFY_TYPEC_STATE, old_state=%d, new_state=%d\n&quot;,
				noti-&gt;typec_state.old_state,
				noti-&gt;typec_state.new_state);

		/* Add-BEGIN by (shanliangliang@paxsz.com), 2021/08/15 add for M8 usb otg */
		mtk_musb-&gt;typec_state = noti-&gt;typec_state.new_state;
		/* Add-END by (shanliangliang@paxsz.com), 2021/08/15 add for M8 usb otg */

		if (noti-&gt;typec_state.old_state == TYPEC_UNATTACHED &amp;&amp;
			noti-&gt;typec_state.new_state == TYPEC_ATTACHED_SRC) {
			DBG(0, &quot;OTG Plug in\n&quot;);
			mt_usb_dev_disconnect();
			mt_usb_host_connect(100);
		/* Add-BEGIN by (shanliangliang@paxsz.com), 2021/09/23 add for M8 usb otg */
		} else if (noti-&gt;typec_state.old_state == TYPEC_UNATTACHED &amp;&amp;
			noti-&gt;typec_state.new_state == TYPEC_ATTACHED_SNK) {
			if (!((mtk_musb-&gt;pogo_dev_detect_type == POGO_DETECT_BY_EXT_PIN) &amp;&amp; (mtk_musb-&gt;pogo_dev_state == POGO_DEV_STATE_ONLINE))) {
				mt_usb_host_disconnect(0);
				mt_usb_connect();
			}
		/* Add-END by (shanliangliang@paxsz.com), 2021/09/23 add for M8 usb otg */
		} else if ((noti-&gt;typec_state.old_state == TYPEC_ATTACHED_SRC ||
			noti-&gt;typec_state.old_state == TYPEC_ATTACHED_SNK ||
			noti-&gt;typec_state.old_state ==
					TYPEC_ATTACHED_NORP_SRC) &amp;&amp;
			noti-&gt;typec_state.new_state == TYPEC_UNATTACHED) {
			/* Add-BEGIN by (shanliangliang@paxsz.com), 2021/08/15 add for M8 usb otg */
				if (mtk_musb-&gt;default_mode != MUSB_HOST) {
					if (is_host_active(mtk_musb)) {
						DBG(0, &quot;OTG Plug out\n&quot;);
						mt_usb_host_disconnect(0);
					} else {
						DBG(0, &quot;USB Plug out\n&quot;);
						mt_usb_dev_disconnect();
					}

					if (mtk_musb-&gt;pogo_dev_detect_type != POGO_DETECT_BY_CC) {
						if (mtk_musb-&gt;r15_state == R15_STATUS_ONLINE) {
							mt_usb_host_connect(100);
						}
					}
				}
				else {
					if ((noti-&gt;typec_state.old_state != TYPEC_ATTACHED_SRC) &amp;&amp; 
							(noti-&gt;typec_state.new_state == TYPEC_UNATTACHED)) {
						if (is_host_active(mtk_musb)) {
							//DBG(0, &quot;OTG Plug out\n&quot;);
							//mt_usb_host_disconnect(0);
						} else {
							DBG(0, &quot;USB Plug out\n&quot;);
							mt_usb_dev_disconnect();
						}
						
						if (mtk_musb-&gt;lcd_state != FB_BLANK_POWERDOWN) {
							msleep(50);
							mt_usb_host_connect(100);
						}
					}
					else if ((noti-&gt;typec_state.old_state == TYPEC_ATTACHED_SRC) &amp;&amp; 
							(noti-&gt;typec_state.new_state == TYPEC_UNATTACHED)) {
						if (mtk_musb-&gt;lcd_state == FB_BLANK_POWERDOWN) {
							if (is_host_active(mtk_musb)) {
								DBG(0, &quot;OTG Plug out\n&quot;);
								mt_usb_host_disconnect(10000);
							} else {
								DBG(0, &quot;USB Plug out\n&quot;);
								mt_usb_dev_disconnect();
							}
						}
					}
				}

				if (mtk_musb-&gt;pogo_dev_detect_type == POGO_DETECT_BY_CC) {
					if (mtk_musb-&gt;r15_state == R15_STATUS_ONLINE) {
						mtk_musb-&gt;r15_state = R15_STATUS_OFFLINE;
					}
				}

		/* Add-END by (shanliangliang@paxsz.com), 2021/08/15 add for M8 usb otg */
#ifdef CONFIG_MTK_UART_USB_SWITCH
		} else if ((noti-&gt;typec_state.new_state ==
					TYPEC_ATTACHED_SNK ||
				noti-&gt;typec_state.new_state ==
					TYPEC_ATTACHED_CUSTOM_SRC ||
				noti-&gt;typec_state.new_state ==
					TYPEC_ATTACHED_NORP_SRC) &amp;&amp;
				in_uart_mode) {
			pr_info(&quot;%s USB cable plugged-in in UART mode.
					Switch to USB mode.\n&quot;, __func__);
			usb_phy_switch_to_usb();
#endif
		}
		break;
	case TCP_NOTIFY_DR_SWAP:
		DBG(0, &quot;TCP_NOTIFY_DR_SWAP, new role=%d\n&quot;,
				noti-&gt;swap_state.new_role);
		if (is_host_active(mtk_musb) &amp;&amp;
			noti-&gt;swap_state.new_role == PD_ROLE_UFP) {
			if (!((mtk_musb-&gt;default_mode == MUSB_HOST) &amp;&amp; (mtk_musb-&gt;usb_type == POWER_SUPPLY_USB_TYPE_DCP))) {
				DBG(0, &quot;switch role to device\n&quot;);
				mt_usb_host_disconnect(0);
				mt_usb_connect();
			}
		} else if (is_peripheral_active(mtk_musb) &amp;&amp;
			noti-&gt;swap_state.new_role == PD_ROLE_DFP) {
			DBG(0, &quot;switch role to host\n&quot;);
			mt_usb_dev_disconnect();
			mt_usb_host_connect(100);
		}
		break;
	}
	return NOTIFY_OK;
}
</pre></div>
</div>
<section id="host-device">
<h4>host/device切换底层原理<a class="headerlink" href="#host-device" title="此标题的永久链接"></a></h4>
<p>可以看到主要是以下几种切换逻辑：</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="n">dev</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">host</span><span class="w"></span>
<span class="n">mt_usb_dev_disconnect</span><span class="p">();</span><span class="w"></span>
<span class="n">mt_usb_host_connect</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span><span class="w"></span>

<span class="n">host</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">dev</span><span class="w"></span>
<span class="n">mt_usb_host_disconnect</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="n">mt_usb_connect</span><span class="p">();</span><span class="w"></span>

<span class="n">host</span><span class="w"> </span><span class="n">Plug</span><span class="w"> </span><span class="n">out</span><span class="o">:</span><span class="w"></span>
<span class="n">mt_usb_host_disconnect</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w"></span>

<span class="n">dev</span><span class="w"> </span><span class="n">Plog</span><span class="w"> </span><span class="n">out</span><span class="o">:</span><span class="w"></span>
<span class="n">mt_usb_dev_disconnect</span><span class="p">();</span><span class="w"></span>
</pre></div>
</div>
<section id="device">
<h5>1.device切换原理<a class="headerlink" href="#device" title="此标题的永久链接"></a></h5>
<p>device的connect和disconnect都是通过issue_connection_work(CONNECTION_OPS_CONN)实现的，看一下具体内容：</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span>usb操作主要有以下三种：
/* specific USB operation */
enum CONNECTION_OPS {
	CONNECTION_OPS_DISC = 0,
	CONNECTION_OPS_CHECK,
	CONNECTION_OPS_CONN
};
</pre></div>
</div>
<p>1.usb_prepare_clock初始化时钟。
2.usb_connected状态是读取charger bc1.2检测，如果检测到是dcp sdp则表示连接上，这个仅供检查使用(CONNECTION_OPS_CHECK)。
3.is_host，如果这个时候要切host，则立即返回。
4.如果是CONNECTION_OPS_CONN指令则enable interrupts, dma, etc，否则disable interrupts, dma, etc。</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">issue_connection_work</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">ops</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="k">struct</span><span class="w"> </span><span class="nc">mt_usb_work</span><span class="w"> </span><span class="o">*</span><span class="n">work</span><span class="p">;</span><span class="w"></span>

<span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">mtk_musb</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="n">DBG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;mtk_musb = NULL</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="k">return</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>
<span class="w">	</span><span class="cm">/* create and prepare worker */</span><span class="w"></span>
<span class="w">	</span><span class="n">work</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">mt_usb_work</span><span class="p">),</span><span class="w"> </span><span class="n">GFP_ATOMIC</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">work</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="n">DBG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;wrap is NULL, directly return</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="k">return</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>
<span class="w">	</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">ops</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ops</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">INIT_DELAYED_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">dwork</span><span class="p">,</span><span class="w"> </span><span class="n">do_connection_work</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="cm">/* issue connection work */</span><span class="w"></span>
<span class="w">	</span><span class="n">DBG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;issue work, ops&lt;%d&gt;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">ops</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="n">queue_delayed_work</span><span class="p">(</span><span class="n">mtk_musb</span><span class="o">-&gt;</span><span class="n">st_wq</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">dwork</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">do_connection_work</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">work_struct</span><span class="w"> </span><span class="o">*</span><span class="n">data</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">flags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="kt">int</span><span class="w"> </span><span class="n">usb_clk_state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NO_CHANGE</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="kt">bool</span><span class="w"> </span><span class="n">usb_on</span><span class="p">,</span><span class="w"> </span><span class="n">usb_connected</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="k">struct</span><span class="w"> </span><span class="nc">mt_usb_work</span><span class="w"> </span><span class="o">*</span><span class="n">work</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">		</span><span class="n">container_of</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">mt_usb_work</span><span class="p">,</span><span class="w"> </span><span class="n">dwork</span><span class="p">.</span><span class="n">work</span><span class="p">);</span><span class="w"></span>

<span class="w">	</span><span class="n">DBG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;is_host&lt;%d&gt;, power&lt;%d&gt;, ops&lt;%d&gt;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">		</span><span class="n">mtk_musb</span><span class="o">-&gt;</span><span class="n">is_host</span><span class="p">,</span><span class="w"> </span><span class="n">mtk_musb</span><span class="o">-&gt;</span><span class="n">power</span><span class="p">,</span><span class="w"> </span><span class="n">work</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">);</span><span class="w"></span>

<span class="w">	</span><span class="cm">/* always prepare clock and check if need to unprepater later */</span><span class="w"></span>
<span class="w">	</span><span class="cm">/* clk_prepare_cnt +1 here*/</span><span class="w"></span>
<span class="w">	</span><span class="n">usb_prepare_clock</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span><span class="w"> </span><span class="c1">//第一步</span>

<span class="w">	</span><span class="cm">/* be aware this could not be used in non-sleep context */</span><span class="w"></span>
<span class="w">	</span><span class="n">usb_connected</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">usb_cable_connected</span><span class="p">(</span><span class="n">mtk_musb</span><span class="p">);</span><span class="w"></span>

<span class="w">	</span><span class="cm">/* additional check operation here */</span><span class="w"></span>
<span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">musb_force_on</span><span class="p">)</span><span class="w"></span>
<span class="w">		</span><span class="n">usb_on</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">ops</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">CONNECTION_OPS_CHECK</span><span class="p">)</span><span class="w"></span>
<span class="w">		</span><span class="n">usb_on</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">usb_connected</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="k">else</span><span class="w"></span>
<span class="w">		</span><span class="n">usb_on</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">ops</span><span class="w"> </span><span class="o">==</span><span class="w"></span>
<span class="w">			</span><span class="n">CONNECTION_OPS_CONN</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="nb">true</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="nb">false</span><span class="p">);</span><span class="w"> </span><span class="c1">//一般是走这里</span>

<span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">cmode_effect_on</span><span class="p">())</span><span class="w"></span>
<span class="w">		</span><span class="n">usb_on</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="cm">/* additional check operation done */</span><span class="w"></span>

<span class="w">	</span><span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mtk_musb</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span><span class="w"> </span><span class="n">flags</span><span class="p">);</span><span class="w"></span>

<span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">mtk_musb</span><span class="o">-&gt;</span><span class="n">is_host</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="c1">//如果这个时候要切host，则立即返回</span>
<span class="w">		</span><span class="n">DBG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;is host, return</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="k">goto</span><span class="w"> </span><span class="n">exit</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>

<span class="cp">#ifdef CONFIG_MTK_UART_USB_SWITCH</span>
<span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">in_uart_mode</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="n">DBG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;in uart mode, return</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="k">goto</span><span class="w"> </span><span class="n">exit</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>
<span class="cp">#endif</span>

<span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">mtk_musb</span><span class="o">-&gt;</span><span class="n">power</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">usb_on</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">true</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="cm">/* enable usb */</span><span class="w"></span>
<span class="w">		</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">mtk_musb</span><span class="o">-&gt;</span><span class="n">usb_lock</span><span class="o">-&gt;</span><span class="n">active</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">			</span><span class="n">__pm_stay_awake</span><span class="p">(</span><span class="n">mtk_musb</span><span class="o">-&gt;</span><span class="n">usb_lock</span><span class="p">);</span><span class="w"></span>
<span class="w">			</span><span class="n">DBG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;lock</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">			</span><span class="n">DBG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;already lock</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="p">}</span><span class="w"></span>

<span class="w">		</span><span class="cm">/* note this already put SOFTCON */</span><span class="w"></span>
<span class="w">		</span><span class="n">musb_start</span><span class="p">(</span><span class="n">mtk_musb</span><span class="p">);</span><span class="w"> </span><span class="c1">//重要</span>
<span class="w">		</span><span class="n">usb_clk_state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">OFF_TO_ON</span><span class="p">;</span><span class="w"></span>

<span class="w">	</span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">mtk_musb</span><span class="o">-&gt;</span><span class="n">power</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">usb_on</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">false</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="cm">/* disable usb */</span><span class="w"></span>
<span class="w">		</span><span class="n">musb_stop</span><span class="p">(</span><span class="n">mtk_musb</span><span class="p">);</span><span class="w"> </span><span class="c1">//重要</span>
<span class="w">		</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">mtk_musb</span><span class="o">-&gt;</span><span class="n">usb_lock</span><span class="o">-&gt;</span><span class="n">active</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">			</span><span class="n">DBG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;unlock</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">			</span><span class="n">__pm_relax</span><span class="p">(</span><span class="n">mtk_musb</span><span class="o">-&gt;</span><span class="n">usb_lock</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">			</span><span class="n">DBG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;lock not active</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="p">}</span><span class="w"></span>
<span class="w">		</span><span class="n">usb_clk_state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ON_TO_OFF</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"></span>
<span class="w">		</span><span class="n">DBG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;do nothing, usb_on:%d, power:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">				</span><span class="n">usb_on</span><span class="p">,</span><span class="w"> </span><span class="n">mtk_musb</span><span class="o">-&gt;</span><span class="n">power</span><span class="p">);</span><span class="w"></span>
<span class="nl">exit</span><span class="p">:</span><span class="w"></span>
<span class="w">	</span><span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mtk_musb</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span><span class="w"> </span><span class="n">flags</span><span class="p">);</span><span class="w"></span>

<span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">usb_clk_state</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">ON_TO_OFF</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="cm">/* clock on -&gt; of: clk_prepare_cnt -2 */</span><span class="w"></span>
<span class="w">		</span><span class="n">usb_prepare_clock</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="n">usb_prepare_clock</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">usb_clk_state</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">NO_CHANGE</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="cm">/* clock no change : clk_prepare_cnt -1 */</span><span class="w"></span>
<span class="w">		</span><span class="n">usb_prepare_clock</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>

<span class="w">	</span><span class="cm">/* free mt_usb_work */</span><span class="w"></span>
<span class="w">	</span><span class="n">kfree</span><span class="p">(</span><span class="n">work</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">bool</span><span class="w"> </span><span class="nf">usb_cable_connected</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">musb</span><span class="w"> </span><span class="o">*</span><span class="n">musb</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="k">struct</span><span class="w"> </span><span class="nc">power_supply</span><span class="w"> </span><span class="o">*</span><span class="n">psy</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="k">union</span><span class="w"> </span><span class="nc">power_supply_propval</span><span class="w"> </span><span class="n">pval</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="k">union</span><span class="w"> </span><span class="nc">power_supply_propval</span><span class="w"> </span><span class="n">tval</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="kt">int</span><span class="w"> </span><span class="n">ret</span><span class="p">;</span><span class="w"></span>

<span class="w">	</span><span class="cm">/* workaround to register psy again */</span><span class="w"></span>
<span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">IS_ERR_OR_NULL</span><span class="p">(</span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">usb_psy</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="n">DBG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;usb_psy not ready</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">mt_usb_psy_init</span><span class="p">(</span><span class="n">musb</span><span class="p">))</span><span class="w"></span>
<span class="w">			</span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>

<span class="w">	</span><span class="n">psy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">usb_psy</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">power_supply_get_property</span><span class="p">(</span><span class="n">psy</span><span class="p">,</span><span class="w"></span>
<span class="w">				</span><span class="n">POWER_SUPPLY_PROP_ONLINE</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">pval</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ret</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="n">DBG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;failed to get psy prop, ret=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">ret</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>

<span class="w">	</span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">power_supply_get_property</span><span class="p">(</span><span class="n">psy</span><span class="p">,</span><span class="w"></span>
<span class="w">				</span><span class="n">POWER_SUPPLY_PROP_USB_TYPE</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">tval</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ret</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="n">DBG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;failed to get psy prop, ret=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">ret</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>

<span class="w">	</span><span class="n">DBG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;online=%d, type=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">pval</span><span class="p">.</span><span class="n">intval</span><span class="p">,</span><span class="w"> </span><span class="n">tval</span><span class="p">.</span><span class="n">intval</span><span class="p">);</span><span class="w"></span>

<span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">pval</span><span class="p">.</span><span class="n">intval</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">tval</span><span class="p">.</span><span class="n">intval</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">POWER_SUPPLY_USB_TYPE_SDP</span><span class="w"> </span><span class="o">||</span><span class="w"></span>
<span class="w">			</span><span class="n">tval</span><span class="p">.</span><span class="n">intval</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">POWER_SUPPLY_USB_TYPE_CDP</span><span class="p">))</span><span class="w"></span>
<span class="w">		</span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="k">else</span><span class="w"></span>
<span class="w">		</span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="cm">/*-------------------------------------------------------------------------*/</span><span class="w"></span>

<span class="cm">/*</span>
<span class="cm"> * Program the HDRC to start (enable interrupts, dma, etc.).</span>
<span class="cm"> */</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">musb_start</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">musb</span><span class="w"> </span><span class="o">*</span><span class="n">musb</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="kt">void</span><span class="w"> </span><span class="n">__iomem</span><span class="w"> </span><span class="o">*</span><span class="n">regs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">mregs</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="kt">int</span><span class="w"> </span><span class="n">vbusdet_retry</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"></span>

<span class="w">	</span><span class="n">u8</span><span class="w"> </span><span class="n">intrusbe</span><span class="p">;</span><span class="w"></span>

<span class="w">	</span><span class="n">DBG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;start, is_host=%d is_active=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">			</span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">is_host</span><span class="p">,</span><span class="w"> </span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">is_active</span><span class="p">);</span><span class="w"></span>

<span class="w">	</span><span class="n">musb_platform_enable</span><span class="p">(</span><span class="n">musb</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="n">musb_platform_reset</span><span class="p">(</span><span class="n">musb</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="n">musb_generic_disable</span><span class="p">(</span><span class="n">musb</span><span class="p">);</span><span class="w"></span>

<span class="w">	</span><span class="n">intrusbe</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">musb_readb</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span><span class="w"> </span><span class="n">MUSB_INTRUSBE</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">is_host</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">intrtxe</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0xffff</span><span class="p">;</span><span class="w"></span>
<span class="w">		</span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">intrrxe</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0xfffe</span><span class="p">;</span><span class="w"></span>
<span class="w">		</span><span class="n">intrusbe</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0xf7</span><span class="p">;</span><span class="w"></span>

<span class="w">		</span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">musb_platform_get_vbus_status</span><span class="p">(</span><span class="n">musb</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">//看原函数直接return true，没啥用</span>
<span class="w">			</span><span class="n">mdelay</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span><span class="w"></span>
<span class="w">			</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">vbusdet_retry</span><span class="o">--</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">				</span><span class="n">DBG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;VBUS detection fail!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">				</span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">			</span><span class="p">}</span><span class="w"></span>
<span class="w">		</span><span class="p">}</span><span class="w"></span>

<span class="w">	</span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">is_host</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="cm">/* enable ep0 interrupt */</span><span class="w"></span>
<span class="w">		</span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">intrtxe</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x1</span><span class="p">;</span><span class="w"></span>
<span class="w">		</span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">intrrxe</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">		</span><span class="cm">/* device mode enable reset interrupt */</span><span class="w"></span>
<span class="w">		</span><span class="n">intrusbe</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">MUSB_INTR_RESET</span><span class="p">;</span><span class="w"></span>
<span class="cp">#if defined(CONFIG_USBIF_COMPLIANCE)</span>
<span class="w">		</span><span class="cm">/* device mode enable connect interrupt */</span><span class="w"></span>
<span class="w">		</span><span class="n">intrusbe</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">MUSB_INTR_CONNECT</span><span class="p">;</span><span class="w"></span>
<span class="cp">#endif</span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>

<span class="w">	</span><span class="n">musb_writew</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span><span class="w"> </span><span class="n">MUSB_INTRTXE</span><span class="p">,</span><span class="w"> </span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">intrtxe</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="n">musb_writew</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span><span class="w"> </span><span class="n">MUSB_INTRRXE</span><span class="p">,</span><span class="w"> </span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">intrrxe</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="n">musb_writeb</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span><span class="w"> </span><span class="n">MUSB_INTRUSBE</span><span class="p">,</span><span class="w"> </span><span class="n">intrusbe</span><span class="p">);</span><span class="w"></span>

<span class="w">	</span><span class="cm">/* In U2 host mode, USB bus will issue</span>
<span class="cm">	 * Babble INT if it was interfered by</span>
<span class="cm">	 * external signal,ex:drill nosie.</span>
<span class="cm">	 * we need to keep session on and continue</span>
<span class="cm">	 * to seed SOF,and same time let hw don&#39;t</span>
<span class="cm">	 * care the babble signal</span>
<span class="cm">	 * remove babble: NOISE_STILL_SOF:1, BABBLE_CLR_EN:0</span>
<span class="cm">	 */</span><span class="w"></span>
<span class="w">	</span><span class="n">intrusbe</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">musb_readb</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span><span class="w"> </span><span class="n">MUSB_ULPI_REG_DATA</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="n">intrusbe</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">intrusbe</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="mh">0x80</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">intrusbe</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">intrusbe</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0xbf</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">musb_writeb</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span><span class="w"> </span><span class="n">MUSB_ULPI_REG_DATA</span><span class="p">,</span><span class="w"> </span><span class="n">intrusbe</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="n">DBG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;set ignore babble MUSB_ULPI_REG_DATA=%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">			</span><span class="n">musb_readb</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span><span class="w"> </span><span class="n">MUSB_ULPI_REG_DATA</span><span class="p">));</span><span class="w"></span>

<span class="w">	</span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="n">u8</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MUSB_POWER_ENSUSPEND</span><span class="p">;</span><span class="w"></span>

<span class="w">		</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">musb_speed</span><span class="p">)</span><span class="w"></span>
<span class="w">			</span><span class="n">val</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">MUSB_POWER_HSENAB</span><span class="p">;</span><span class="w"></span>
<span class="w">		</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">softconnect</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">			</span><span class="n">DBG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;add softconn</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">			</span><span class="n">val</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">MUSB_POWER_SOFTCONN</span><span class="p">;</span><span class="w"></span>
<span class="w">		</span><span class="p">}</span><span class="w"></span>
<span class="w">		</span><span class="n">musb_writeb</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span><span class="w"> </span><span class="n">MUSB_POWER</span><span class="p">,</span><span class="w"> </span><span class="n">val</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>

<span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">is_host</span><span class="p">)</span><span class="w"></span>
<span class="w">		</span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">is_active</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="k">else</span><span class="w"></span>
<span class="w">		</span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">is_active</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>

<span class="cp">#ifdef CONFIG_DUAL_ROLE_USB_INTF</span>
<span class="w">	</span><span class="n">mt_usb_dual_role_changed</span><span class="p">(</span><span class="n">musb</span><span class="p">);</span><span class="w"></span>
<span class="cp">#endif</span>
<span class="p">}</span><span class="w"></span>

<span class="cm">/*</span>
<span class="cm"> * Make the HDRC stop (disable interrupts, etc.);</span>
<span class="cm"> * reversible by musb_start</span>
<span class="cm"> * called on gadget driver unregister</span>
<span class="cm"> * with controller locked, irqs blocked</span>
<span class="cm"> * acts as a NOP unless some role activated the hardware</span>
<span class="cm"> */</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">musb_stop</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">musb</span><span class="w"> </span><span class="o">*</span><span class="n">musb</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="cm">/* stop IRQs, timers, ... */</span><span class="w"></span>
<span class="w">	</span><span class="n">musb_generic_disable</span><span class="p">(</span><span class="n">musb</span><span class="p">);</span><span class="w"></span>

<span class="w">	</span><span class="n">gadget_stop</span><span class="p">(</span><span class="n">musb</span><span class="p">);</span><span class="w"></span>

<span class="w">	</span><span class="n">musb_flush_dma_transcation</span><span class="p">(</span><span class="n">musb</span><span class="p">);</span><span class="w"></span>

<span class="w">	</span><span class="n">musb_platform_disable</span><span class="p">(</span><span class="n">musb</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">is_active</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">DBG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;HDRC disabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>

<span class="w">	</span><span class="cm">/* FIXME</span>
<span class="cm">	 *  - mark host and/or peripheral drivers unusable/inactive</span>
<span class="cm">	 *  - disable DMA (and enable it in HdrcStart)</span>
<span class="cm">	 *  - make sure we can musb_start() after musb_stop(); with</span>
<span class="cm">	 *    OTG mode, gadget driver module rmmod/modprobe cycles that</span>
<span class="cm">	 *  - ...</span>
<span class="cm">	 */</span><span class="w"></span>
<span class="w">	</span><span class="n">musb_platform_try_idle</span><span class="p">(</span><span class="n">musb</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>

<span class="cp">#ifdef CONFIG_DUAL_ROLE_USB_INTF</span>
<span class="w">	</span><span class="n">mt_usb_dual_role_changed</span><span class="p">(</span><span class="n">musb</span><span class="p">);</span><span class="w"></span>
<span class="cp">#endif</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="host">
<h5>2.host切换原理<a class="headerlink" href="#host" title="此标题的永久链接"></a></h5>
<p>host的connect和disconnect都是通过issue_host_work(CONNECTION_OPS_CONN)实现的，传入ops执行do_host_work工作队列：</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">mt_usb_host_connect</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">delay</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="n">typec_req_host</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">DBG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">typec_req_host</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="s">&quot;connect&quot;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="s">&quot;disconnect&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="n">issue_host_work</span><span class="p">(</span><span class="n">CONNECTION_OPS_CONN</span><span class="p">,</span><span class="w"> </span><span class="n">delay</span><span class="p">,</span><span class="w"> </span><span class="nb">true</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">mt_usb_host_disconnect</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">delay</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="n">typec_req_host</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">DBG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">typec_req_host</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="s">&quot;connect&quot;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="s">&quot;disconnect&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="n">issue_host_work</span><span class="p">(</span><span class="n">CONNECTION_OPS_DISC</span><span class="p">,</span><span class="w"> </span><span class="n">delay</span><span class="p">,</span><span class="w"> </span><span class="nb">true</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">issue_host_work</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">ops</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">delay</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">on_st</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="cm">/* Add-BEGIN by (shanliangliang@paxsz.com), 2021/10/28 modify for M8 usb host shedule work*/</span><span class="w"></span>
<span class="w">	</span><span class="k">struct</span><span class="w"> </span><span class="nc">mt_usb_work</span><span class="w"> </span><span class="o">*</span><span class="n">work</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>
<span class="cm">/* Add-END by (shanliangliang@paxsz.com), 2021/10/28 modify for M8 usb host shedule work*/</span><span class="w"></span>

<span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">mtk_musb</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="n">DBG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;mtk_musb = NULL</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="k">return</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>

<span class="cm">/* Add-BEGIN by (shanliangliang@paxsz.com), 2021/10/28 modify for M8 usb host shedule work*/</span><span class="w"></span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">	/* create and prepare worker */</span>
<span class="c">	work = kzalloc(sizeof(struct mt_usb_work), GFP_ATOMIC);</span>
<span class="c">	if (!work) {</span>
<span class="c">		DBG(0, &quot;work is NULL, directly return\n&quot;);</span>
<span class="c">		return;</span>
<span class="c">	}</span>
<span class="c">	work-&gt;ops = ops;</span>
<span class="c">	INIT_DELAYED_WORK(&amp;work-&gt;dwork, do_host_work);</span>
<span class="cp">#else</span>
<span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ops</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">CONNECTION_OPS_DISC</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">mt_host_disconnect_work</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">			</span><span class="n">mt_host_disconnect_work</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">mt_usb_work</span><span class="p">),</span><span class="w"> </span><span class="n">GFP_ATOMIC</span><span class="p">);</span><span class="w"></span>
<span class="w">			</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">mt_host_disconnect_work</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">				</span><span class="n">DBG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;work is NULL, directly return</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">				</span><span class="k">return</span><span class="p">;</span><span class="w"></span>
<span class="w">			</span><span class="p">}</span><span class="w"></span>
<span class="w">			</span><span class="n">INIT_DELAYED_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mt_host_disconnect_work</span><span class="o">-&gt;</span><span class="n">dwork</span><span class="p">,</span><span class="w"> </span><span class="n">do_host_work</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="p">}</span><span class="w"></span>

<span class="w">		</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">mt_host_connect_work</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">			</span><span class="n">cancel_delayed_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mt_host_connect_work</span><span class="o">-&gt;</span><span class="n">dwork</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="p">}</span><span class="w"></span>

<span class="w">		</span><span class="n">work</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mt_host_disconnect_work</span><span class="p">;</span><span class="w"></span>
<span class="w">		</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">ops</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ops</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>
<span class="w">	</span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">mt_host_connect_work</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">			</span><span class="n">mt_host_connect_work</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">mt_usb_work</span><span class="p">),</span><span class="w"> </span><span class="n">GFP_ATOMIC</span><span class="p">);</span><span class="w"></span>
<span class="w">			</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">mt_host_connect_work</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">				</span><span class="n">DBG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;work is NULL, directly return</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">				</span><span class="k">return</span><span class="p">;</span><span class="w"></span>
<span class="w">			</span><span class="p">}</span><span class="w"></span>
<span class="w">			</span><span class="n">INIT_DELAYED_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mt_host_connect_work</span><span class="o">-&gt;</span><span class="n">dwork</span><span class="p">,</span><span class="w"> </span><span class="n">do_host_work</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="p">}</span><span class="w"></span>

<span class="w">		</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">mt_host_disconnect_work</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">			</span><span class="n">cancel_delayed_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mt_host_disconnect_work</span><span class="o">-&gt;</span><span class="n">dwork</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="p">}</span><span class="w"></span>

<span class="w">		</span><span class="n">work</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mt_host_connect_work</span><span class="p">;</span><span class="w"></span>
<span class="w">		</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">ops</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ops</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>
<span class="cp">#endif</span>
<span class="cm">/* Add-END by (shanliangliang@paxsz.com), 2021/10/28 modify for M8 usb host shedule work*/</span><span class="w"></span>

<span class="w">	</span><span class="cm">/* issue connection work */</span><span class="w"></span>
<span class="w">	</span><span class="n">DBG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;issue work, ops&lt;%d&gt;, delay&lt;%d&gt;, on_st&lt;%d&gt;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">		</span><span class="n">ops</span><span class="p">,</span><span class="w"> </span><span class="n">delay</span><span class="p">,</span><span class="w"> </span><span class="n">on_st</span><span class="p">);</span><span class="w"></span>

<span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">on_st</span><span class="p">)</span><span class="w"></span>
<span class="w">		</span><span class="n">queue_delayed_work</span><span class="p">(</span><span class="n">mtk_musb</span><span class="o">-&gt;</span><span class="n">st_wq</span><span class="p">,</span><span class="w"></span>
<span class="w">					</span><span class="o">&amp;</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">dwork</span><span class="p">,</span><span class="w"> </span><span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">delay</span><span class="p">));</span><span class="w"></span>
<span class="w">	</span><span class="k">else</span><span class="w"></span>
<span class="w">		</span><span class="n">schedule_delayed_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">dwork</span><span class="p">,</span><span class="w"></span>
<span class="w">					</span><span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">delay</span><span class="p">));</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>具体切换工作如下：</p>
<p>1.准备时钟usb_prepare_clock。
2.如果是切host，is_host先标记为1.
3.调用ep_config_from_table_for_host函数setup fifo for host mode
4.mt_usb_set_vbus(mtk_musb, 1)打开vbus，sleep一下，等vbus上电完成。
5.set_usb_phy_mode(PHY_IDLE_MODE)将phy雀环为idle模式。
6.set_usb_phy_mode(PHY_HOST_ACTIVE)切换成host模式。
7.musb_start(mtk_musb)使能enable interrupts, dma, etc。
8.断开host则2~7步骤相反。</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">do_host_work</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">work_struct</span><span class="w"> </span><span class="o">*</span><span class="n">data</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="n">u8</span><span class="w"> </span><span class="n">devctl</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">flags</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">inited</span><span class="p">,</span><span class="w"> </span><span class="n">timeout</span><span class="p">;</span><span class="w"> </span><span class="cm">/* default to 0 */</span><span class="w"></span>
<span class="w">	</span><span class="k">static</span><span class="w"> </span><span class="n">s64</span><span class="w"> </span><span class="n">diff_time</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="kt">bool</span><span class="w"> </span><span class="n">host_on</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="kt">int</span><span class="w"> </span><span class="n">usb_clk_state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NO_CHANGE</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="k">struct</span><span class="w"> </span><span class="nc">mt_usb_work</span><span class="w"> </span><span class="o">*</span><span class="n">work</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">		</span><span class="n">container_of</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">mt_usb_work</span><span class="p">,</span><span class="w"> </span><span class="n">dwork</span><span class="p">.</span><span class="n">work</span><span class="p">);</span><span class="w"></span>

<span class="w">	</span><span class="cm">/* kernel_init_done should be set in</span>
<span class="cm">	 * early-init stage through init.$platform.usb.rc</span>
<span class="cm">	 */</span><span class="w"></span>
<span class="w">	</span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">inited</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">!</span><span class="n">kernel_init_done</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"></span>
<span class="w">		   </span><span class="o">!</span><span class="n">mtk_musb</span><span class="o">-&gt;</span><span class="n">is_ready</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">!</span><span class="n">timeout</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="n">ktime_end</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ktime_get</span><span class="p">();</span><span class="w"></span>
<span class="w">		</span><span class="n">diff_time</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ktime_to_ms</span><span class="p">(</span><span class="n">ktime_sub</span><span class="p">(</span><span class="n">ktime_end</span><span class="p">,</span><span class="w"> </span><span class="n">ktime_start</span><span class="p">));</span><span class="w"></span>

<span class="w">		</span><span class="n">DBG_LIMIT</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"></span>
<span class="w">			</span><span class="s">&quot;init_done:%d, is_ready:%d, inited:%d, TO:%d, diff:%lld&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">			</span><span class="n">kernel_init_done</span><span class="p">,</span><span class="w"></span>
<span class="w">			</span><span class="n">mtk_musb</span><span class="o">-&gt;</span><span class="n">is_ready</span><span class="p">,</span><span class="w"></span>
<span class="w">			</span><span class="n">inited</span><span class="p">,</span><span class="w"></span>
<span class="w">			</span><span class="n">timeout</span><span class="p">,</span><span class="w"></span>
<span class="w">			</span><span class="n">diff_time</span><span class="p">);</span><span class="w"></span>

<span class="w">		</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">diff_time</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">ID_PIN_WORK_BLOCK_TIMEOUT</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">			</span><span class="n">DBG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;diff_time:%lld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">diff_time</span><span class="p">);</span><span class="w"></span>
<span class="w">			</span><span class="n">timeout</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">		</span><span class="p">}</span><span class="w"></span>
<span class="w">		</span><span class="n">msleep</span><span class="p">(</span><span class="n">ID_PIN_WORK_RECHECK_TIME</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>

<span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">inited</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="n">DBG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;PASS,init_done:%d,is_ready:%d,inited:%d, TO:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">				</span><span class="n">kernel_init_done</span><span class="p">,</span><span class="w">  </span><span class="n">mtk_musb</span><span class="o">-&gt;</span><span class="n">is_ready</span><span class="p">,</span><span class="w"></span>
<span class="w">				</span><span class="n">inited</span><span class="p">,</span><span class="w"> </span><span class="n">timeout</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="n">inited</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>

<span class="w">	</span><span class="cm">/* always prepare clock and check if need to unprepater later */</span><span class="w"></span>
<span class="w">	</span><span class="cm">/* clk_prepare_cnt +1 here */</span><span class="w"></span>
<span class="w">	</span><span class="n">usb_prepare_clock</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span><span class="w"></span>

<span class="w">	</span><span class="n">down</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mtk_musb</span><span class="o">-&gt;</span><span class="n">musb_lock</span><span class="p">);</span><span class="w"></span>

<span class="w">	</span><span class="n">host_on</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">ops</span><span class="w"> </span><span class="o">==</span><span class="w"></span>
<span class="w">			</span><span class="n">CONNECTION_OPS_CONN</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="nb">true</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="nb">false</span><span class="p">);</span><span class="w"></span>

<span class="w">	</span><span class="n">DBG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;work start, is_host=%d, host_on=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">		</span><span class="n">mtk_musb</span><span class="o">-&gt;</span><span class="n">is_host</span><span class="p">,</span><span class="w"> </span><span class="n">host_on</span><span class="p">);</span><span class="w"></span>

<span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">host_on</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">!</span><span class="n">mtk_musb</span><span class="o">-&gt;</span><span class="n">is_host</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="cm">/* switch to HOST state before turn on VBUS */</span><span class="w"></span>
<span class="w">		</span><span class="n">MUSB_HST_MODE</span><span class="p">(</span><span class="n">mtk_musb</span><span class="p">);</span><span class="w"></span>

<span class="w">		</span><span class="cm">/* to make sure all event clear */</span><span class="w"></span>
<span class="w">		</span><span class="n">msleep</span><span class="p">(</span><span class="mi">32</span><span class="p">);</span><span class="w"></span>
<span class="cp">#ifdef CONFIG_MTK_UAC_POWER_SAVING</span>
<span class="w">		</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">usb_on_sram</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">			</span><span class="kt">int</span><span class="w"> </span><span class="n">ret</span><span class="p">;</span><span class="w"></span>

<span class="w">			</span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">gpd_switch_to_sram</span><span class="p">(</span><span class="n">mtk_musb</span><span class="o">-&gt;</span><span class="n">controller</span><span class="p">);</span><span class="w"></span>
<span class="w">			</span><span class="n">DBG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;gpd_switch_to_sram, ret&lt;%d&gt;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">ret</span><span class="p">);</span><span class="w"></span>
<span class="w">			</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ret</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">				</span><span class="n">usb_on_sram</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">		</span><span class="p">}</span><span class="w"></span>
<span class="cp">#endif</span>
<span class="w">		</span><span class="cm">/* setup fifo for host mode */</span><span class="w"></span>
<span class="w">		</span><span class="n">ep_config_from_table_for_host</span><span class="p">(</span><span class="n">mtk_musb</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="n">__pm_stay_awake</span><span class="p">(</span><span class="n">mtk_musb</span><span class="o">-&gt;</span><span class="n">usb_lock</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="n">mt_usb_set_vbus</span><span class="p">(</span><span class="n">mtk_musb</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>

<span class="w">		</span><span class="cm">/* this make PHY operation workable */</span><span class="w"></span>
<span class="w">		</span><span class="n">musb_platform_enable</span><span class="p">(</span><span class="n">mtk_musb</span><span class="p">);</span><span class="w"></span>

<span class="w">		</span><span class="cm">/* for no VBUS sensing IP*/</span><span class="w"></span>

<span class="w">		</span><span class="cm">/* wait VBUS ready */</span><span class="w"></span>
<span class="w">		</span><span class="n">msleep</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="cm">/* clear session*/</span><span class="w"></span>
<span class="w">		</span><span class="n">devctl</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">musb_readb</span><span class="p">(</span><span class="n">mtk_musb</span><span class="o">-&gt;</span><span class="n">mregs</span><span class="p">,</span><span class="w"> </span><span class="n">MUSB_DEVCTL</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="n">musb_writeb</span><span class="p">(</span><span class="n">mtk_musb</span><span class="o">-&gt;</span><span class="n">mregs</span><span class="p">,</span><span class="w"></span>
<span class="w">				</span><span class="n">MUSB_DEVCTL</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">devctl</span><span class="o">&amp;</span><span class="p">(</span><span class="o">~</span><span class="n">MUSB_DEVCTL_SESSION</span><span class="p">)));</span><span class="w"></span>
<span class="w">		</span><span class="n">set_usb_phy_mode</span><span class="p">(</span><span class="n">PHY_IDLE_MODE</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="cm">/* wait */</span><span class="w"></span>
<span class="w">		</span><span class="n">mdelay</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="cm">/* restart session */</span><span class="w"></span>
<span class="w">		</span><span class="n">devctl</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">musb_readb</span><span class="p">(</span><span class="n">mtk_musb</span><span class="o">-&gt;</span><span class="n">mregs</span><span class="p">,</span><span class="w"> </span><span class="n">MUSB_DEVCTL</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="n">musb_writeb</span><span class="p">(</span><span class="n">mtk_musb</span><span class="o">-&gt;</span><span class="n">mregs</span><span class="p">,</span><span class="w"></span>
<span class="w">				</span><span class="n">MUSB_DEVCTL</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">devctl</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">MUSB_DEVCTL_SESSION</span><span class="p">));</span><span class="w"></span>
<span class="w">		</span><span class="n">set_usb_phy_mode</span><span class="p">(</span><span class="n">PHY_HOST_ACTIVE</span><span class="p">);</span><span class="w"></span>

<span class="w">		</span><span class="n">musb_start</span><span class="p">(</span><span class="n">mtk_musb</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">typec_control</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">!</span><span class="n">host_plug_test_triggered</span><span class="p">)</span><span class="w"></span>
<span class="w">			</span><span class="n">switch_int_to_device</span><span class="p">(</span><span class="n">mtk_musb</span><span class="p">);</span><span class="w"></span>

<span class="w">		</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">host_plug_test_enable</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">!</span><span class="n">host_plug_test_triggered</span><span class="p">)</span><span class="w"></span>
<span class="w">			</span><span class="n">queue_delayed_work</span><span class="p">(</span><span class="n">mtk_musb</span><span class="o">-&gt;</span><span class="n">st_wq</span><span class="p">,</span><span class="w"></span>
<span class="w">						</span><span class="o">&amp;</span><span class="n">host_plug_test_work</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="n">usb_clk_state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">OFF_TO_ON</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w">  </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">host_on</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">mtk_musb</span><span class="o">-&gt;</span><span class="n">is_host</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="cm">/* switch from host -&gt; device */</span><span class="w"></span>
<span class="w">		</span><span class="cm">/* for device no disconnect interrupt */</span><span class="w"></span>
<span class="w">		</span><span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mtk_musb</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span><span class="w"> </span><span class="n">flags</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">mtk_musb</span><span class="o">-&gt;</span><span class="n">is_active</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">			</span><span class="n">DBG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;for not receiving disconnect interrupt</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">			</span><span class="n">usb_hcd_resume_root_hub</span><span class="p">(</span><span class="n">musb_to_hcd</span><span class="p">(</span><span class="n">mtk_musb</span><span class="p">));</span><span class="w"></span>
<span class="w">			</span><span class="n">musb_root_disconnect</span><span class="p">(</span><span class="n">mtk_musb</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="p">}</span><span class="w"></span>
<span class="w">		</span><span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mtk_musb</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span><span class="w"> </span><span class="n">flags</span><span class="p">);</span><span class="w"></span>

<span class="w">		</span><span class="n">DBG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;devctl is %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">				</span><span class="n">musb_readb</span><span class="p">(</span><span class="n">mtk_musb</span><span class="o">-&gt;</span><span class="n">mregs</span><span class="p">,</span><span class="w"> </span><span class="n">MUSB_DEVCTL</span><span class="p">));</span><span class="w"></span>
<span class="w">		</span><span class="n">musb_writeb</span><span class="p">(</span><span class="n">mtk_musb</span><span class="o">-&gt;</span><span class="n">mregs</span><span class="p">,</span><span class="w"> </span><span class="n">MUSB_DEVCTL</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">mtk_musb</span><span class="o">-&gt;</span><span class="n">usb_lock</span><span class="o">-&gt;</span><span class="n">active</span><span class="p">)</span><span class="w"></span>
<span class="w">			</span><span class="n">__pm_relax</span><span class="p">(</span><span class="n">mtk_musb</span><span class="o">-&gt;</span><span class="n">usb_lock</span><span class="p">);</span><span class="w"></span>

<span class="w">		</span><span class="n">mt_usb_set_vbus</span><span class="p">(</span><span class="n">mtk_musb</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>

<span class="w">		</span><span class="cm">/* for no VBUS sensing IP */</span><span class="w"></span>
<span class="w">		</span><span class="n">set_usb_phy_mode</span><span class="p">(</span><span class="n">PHY_IDLE_MODE</span><span class="p">);</span><span class="w"></span>

<span class="w">		</span><span class="n">musb_stop</span><span class="p">(</span><span class="n">mtk_musb</span><span class="p">);</span><span class="w"></span>

<span class="w">		</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">typec_control</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">!</span><span class="n">host_plug_test_triggered</span><span class="p">)</span><span class="w"></span>
<span class="w">			</span><span class="n">switch_int_to_host</span><span class="p">(</span><span class="n">mtk_musb</span><span class="p">);</span><span class="w"></span>

<span class="cp">#ifdef CONFIG_MTK_UAC_POWER_SAVING</span>
<span class="w">		</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">usb_on_sram</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">			</span><span class="n">gpd_switch_to_dram</span><span class="p">(</span><span class="n">mtk_musb</span><span class="o">-&gt;</span><span class="n">controller</span><span class="p">);</span><span class="w"></span>
<span class="w">			</span><span class="n">usb_on_sram</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">		</span><span class="p">}</span><span class="w"></span>
<span class="cp">#endif</span>
<span class="w">		</span><span class="cm">/* to make sure all event clear */</span><span class="w"></span>
<span class="w">		</span><span class="n">msleep</span><span class="p">(</span><span class="mi">32</span><span class="p">);</span><span class="w"></span>

<span class="w">		</span><span class="n">mtk_musb</span><span class="o">-&gt;</span><span class="n">xceiv</span><span class="o">-&gt;</span><span class="n">otg</span><span class="o">-&gt;</span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">OTG_STATE_B_IDLE</span><span class="p">;</span><span class="w"></span>
<span class="w">		</span><span class="cm">/* switch to DEV state after turn off VBUS */</span><span class="w"></span>
<span class="w">		</span><span class="n">MUSB_DEV_MODE</span><span class="p">(</span><span class="n">mtk_musb</span><span class="p">);</span><span class="w"></span>

<span class="w">		</span><span class="n">usb_clk_state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ON_TO_OFF</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>
<span class="w">	</span><span class="n">DBG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;work end, is_host=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">mtk_musb</span><span class="o">-&gt;</span><span class="n">is_host</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="n">up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mtk_musb</span><span class="o">-&gt;</span><span class="n">musb_lock</span><span class="p">);</span><span class="w"></span>

<span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">usb_clk_state</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">ON_TO_OFF</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="cm">/* clock on -&gt; of: clk_prepare_cnt -2 */</span><span class="w"></span>
<span class="w">		</span><span class="n">usb_prepare_clock</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="n">usb_prepare_clock</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">usb_clk_state</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">NO_CHANGE</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="cm">/* clock no change : clk_prepare_cnt -1 */</span><span class="w"></span>
<span class="w">		</span><span class="n">usb_prepare_clock</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>

<span class="cm">/* Add-BEGIN by (shanliangliang@paxsz.com), 2021/10/28 modify for M8 usb host shedule work*/</span><span class="w"></span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">	/* free mt_usb_work */</span>
<span class="c">	kfree(work);</span>
<span class="cp">#endif</span>
<span class="cm">/* Add-END by (shanliangliang@paxsz.com), 2021/10/28 modify for M8 usb host shedule work*/</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
</section>
<section id="mt-usb-psy-init">
<h3>mt_usb_psy_init<a class="headerlink" href="#mt-usb-psy-init" title="此标题的永久链接"></a></h3>
<p>这里主要是notify监听charger bc1.2检测到sdp或者dcp时执行mt_usb_connect或者mt_usb_disconnect操作。</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">mt_usb_psy_init</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">musb</span><span class="w"> </span><span class="o">*</span><span class="n">musb</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="kt">int</span><span class="w"> </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="k">struct</span><span class="w"> </span><span class="nc">device</span><span class="w"> </span><span class="o">*</span><span class="n">dev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">controller</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span><span class="w"></span>

<span class="w">	</span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">usb_psy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">devm_power_supply_get_by_phandle</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;charger&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">IS_ERR_OR_NULL</span><span class="p">(</span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">usb_psy</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="n">DBG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;couldn&#39;t get usb_psy</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>

<span class="w">	</span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">psy_nb</span><span class="p">.</span><span class="n">notifier_call</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mt_usb_psy_notifier</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">power_supply_reg_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">psy_nb</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ret</span><span class="p">)</span><span class="w"></span>
<span class="w">		</span><span class="n">DBG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;failed to reg notifier: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">ret</span><span class="p">);</span><span class="w"></span>

<span class="w">	</span><span class="k">return</span><span class="w"> </span><span class="n">ret</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">mt_usb_psy_notifier</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">notifier_block</span><span class="w"> </span><span class="o">*</span><span class="n">nb</span><span class="p">,</span><span class="w"></span>
<span class="w">				</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">event</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="k">struct</span><span class="w"> </span><span class="nc">musb</span><span class="w"> </span><span class="o">*</span><span class="n">musb</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">container_of</span><span class="p">(</span><span class="n">nb</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">musb</span><span class="p">,</span><span class="w"> </span><span class="n">psy_nb</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="k">struct</span><span class="w"> </span><span class="nc">power_supply</span><span class="w"> </span><span class="o">*</span><span class="n">psy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ptr</span><span class="p">;</span><span class="w"></span>

<span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">event</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">PSY_EVENT_PROP_CHANGED</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">psy</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">usb_psy</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">		</span><span class="n">DBG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;psy=%s, event=%d&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">psy</span><span class="o">-&gt;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">event</span><span class="p">);</span><span class="w"></span>

<span class="w">		</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">usb_cable_connected</span><span class="p">(</span><span class="n">musb</span><span class="p">))</span><span class="w"></span>
<span class="w">			</span><span class="n">mt_usb_connect</span><span class="p">();</span><span class="w"></span>
<span class="w">		</span><span class="k">else</span><span class="w"></span>
<span class="w">			</span><span class="n">mt_usb_disconnect</span><span class="p">();</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>
<span class="w">	</span><span class="k">return</span><span class="w"> </span><span class="n">NOTIFY_DONE</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
<section id="musb-core-musb-init-controller">
<h2>musb_core musb_init_controller简要分析<a class="headerlink" href="#musb-core-musb-init-controller" title="此标题的永久链接"></a></h2>
<p>上面暂不分析了，直接借鉴一下网友写的musb_init_controller具体干了什么，注意：主要的两个函数usb_add_hcd和musb_gadget_setup暂时不讲，我也不懂。</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="n">musb_init_controller</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">device</span><span class="w"> </span><span class="o">*</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">nIrq</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">__iomem</span><span class="w"> </span><span class="o">*</span><span class="n">ctrl</span><span class="p">)</span><span class="w">  </span>
<span class="p">{</span><span class="w">  </span>
<span class="w">    </span><span class="kt">int</span><span class="w">         </span><span class="n">status</span><span class="p">;</span><span class="w">  </span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">musb</span><span class="w">     </span><span class="o">*</span><span class="n">musb</span><span class="p">;</span><span class="w">  </span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">musb_hdrc_platform_data</span><span class="w"> </span><span class="o">*</span><span class="n">plat</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">platform_data</span><span class="p">;</span><span class="w">  </span>
<span class="w">  </span>
<span class="w">    </span><span class="cm">/* The driver might handle more features than the board; OK. </span>
<span class="cm">     * Fail when the board needs a feature that&#39;s not enabled. </span>
<span class="cm">     */</span><span class="w">  </span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">plat</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">  </span>
<span class="w">        </span><span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;no platform_data?</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w">  </span>
<span class="w">        </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span><span class="w">  </span>
<span class="w">        </span><span class="k">goto</span><span class="w"> </span><span class="n">fail0</span><span class="p">;</span><span class="w">  </span>
<span class="w">    </span><span class="p">}</span><span class="w">  </span>
<span class="w">  </span>
<span class="w">    </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">plat</span><span class="o">-&gt;</span><span class="n">mode</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">  </span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">MUSB_HOST</span><span class="p">:</span><span class="w">  </span>
<span class="cp">#ifdef CONFIG_USB_MUSB_HDRC_HCD  </span>
<span class="w">        </span><span class="k">break</span><span class="p">;</span><span class="w">  </span>
<span class="cp">#else  </span>
<span class="w">        </span><span class="k">goto</span><span class="w"> </span><span class="n">bad_config</span><span class="p">;</span><span class="w">  </span>
<span class="cp">#endif  </span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">MUSB_PERIPHERAL</span><span class="p">:</span><span class="w">  </span>
<span class="cp">#ifdef CONFIG_USB_GADGET_MUSB_HDRC  </span>
<span class="w">        </span><span class="k">break</span><span class="p">;</span><span class="w">  </span>
<span class="cp">#else  </span>
<span class="w">        </span><span class="k">goto</span><span class="w"> </span><span class="n">bad_config</span><span class="p">;</span><span class="w">  </span>
<span class="cp">#endif  </span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">MUSB_OTG</span><span class="p">:</span><span class="w">  </span>
<span class="cp">#ifdef CONFIG_USB_MUSB_OTG  </span>
<span class="w">        </span><span class="k">break</span><span class="p">;</span><span class="w">  </span>
<span class="cp">#else  </span>
<span class="nl">bad_config</span><span class="p">:</span><span class="w">  </span>
<span class="cp">#endif  </span>
<span class="w">    </span><span class="k">default</span><span class="o">:</span><span class="w">  </span>
<span class="w">        </span><span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;incompatible Kconfig role setting</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w">  </span>
<span class="w">        </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span><span class="w">  </span>
<span class="w">        </span><span class="k">goto</span><span class="w"> </span><span class="n">fail0</span><span class="p">;</span><span class="w">  </span>
<span class="w">    </span><span class="p">}</span><span class="w">  </span>
<span class="w">  </span>
<span class="w">    </span><span class="cm">/* allocate */</span><span class="w">  </span>
<span class="w">    </span><span class="n">musb</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">allocate_instance</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="n">plat</span><span class="o">-&gt;</span><span class="n">config</span><span class="p">,</span><span class="w"> </span><span class="n">ctrl</span><span class="p">);</span><span class="w">    </span><span class="c1">//分配实例  </span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">musb</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">  </span>
<span class="w">        </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span><span class="w">  </span>
<span class="w">        </span><span class="k">goto</span><span class="w"> </span><span class="n">fail0</span><span class="p">;</span><span class="w">  </span>
<span class="w">    </span><span class="p">}</span><span class="w">  </span>
<span class="w">  </span>
<span class="w">    </span><span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span><span class="w">  </span>
<span class="w">    </span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">board_mode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">plat</span><span class="o">-&gt;</span><span class="n">mode</span><span class="p">;</span><span class="w">  </span>
<span class="w">    </span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">board_set_power</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">plat</span><span class="o">-&gt;</span><span class="n">set_power</span><span class="p">;</span><span class="w">  </span>
<span class="w">    </span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">set_clock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">plat</span><span class="o">-&gt;</span><span class="n">set_clock</span><span class="p">;</span><span class="w">  </span>
<span class="w">    </span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">min_power</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">plat</span><span class="o">-&gt;</span><span class="n">min_power</span><span class="p">;</span><span class="w">  </span>
<span class="w">  </span>
<span class="w">    </span><span class="cm">/* Clock usage is chip-specific ... functional clock (DaVinci, </span>
<span class="cm">     * OMAP2430), or PHY ref (some TUSB6010 boards).  All this core </span>
<span class="cm">     * code does is make sure a clock handle is available; platform </span>
<span class="cm">     * code manages it during start/stop and suspend/resume. </span>
<span class="cm">     */</span><span class="w">  </span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">plat</span><span class="o">-&gt;</span><span class="n">clock</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">  </span>
<span class="w">        </span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">clock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">clk_get</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="n">plat</span><span class="o">-&gt;</span><span class="n">clock</span><span class="p">);</span><span class="w">  </span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">clock</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w">  </span>
<span class="w">            </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PTR_ERR</span><span class="p">(</span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">clock</span><span class="p">);</span><span class="w">  </span>
<span class="w">            </span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">clock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w">  </span>
<span class="w">            </span><span class="k">goto</span><span class="w"> </span><span class="n">fail1</span><span class="p">;</span><span class="w">  </span>
<span class="w">        </span><span class="p">}</span><span class="w">  </span>
<span class="w">    </span><span class="p">}</span><span class="w">  </span>
<span class="w">  </span>
<span class="w">    </span><span class="cm">/* The musb_platform_init() call: </span>
<span class="cm">     *   - adjusts musb-&gt;mregs and musb-&gt;isr if needed, </span>
<span class="cm">     *   - may initialize an integrated tranceiver </span>
<span class="cm">     *   - initializes musb-&gt;xceiv, usually by otg_get_transceiver() </span>
<span class="cm">     *   - activates clocks. </span>
<span class="cm">     *   - stops powering VBUS </span>
<span class="cm">     *   - assigns musb-&gt;board_set_vbus if host mode is enabled </span>
<span class="cm">     * </span>
<span class="cm">     * There are various transciever configurations.  Blackfin, </span>
<span class="cm">     * DaVinci, TUSB60x0, and others integrate them.  OMAP3 uses </span>
<span class="cm">     * external/discrete ones in various flavors (twl4030 family, </span>
<span class="cm">     * isp1504, non-OTG, etc) mostly hooking up through ULPI. </span>
<span class="cm">     */</span><span class="w">  </span>
<span class="w">    </span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">isr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">generic_interrupt</span><span class="p">;</span><span class="w">                                 </span><span class="c1">//赋值 musb-&gt;irq  </span>
<span class="w">    </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">musb_platform_init</span><span class="p">(</span><span class="n">musb</span><span class="p">);</span><span class="w">                             </span><span class="c1">//初始化 musb  </span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">status</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w">  </span>
<span class="w">        </span><span class="k">goto</span><span class="w"> </span><span class="n">fail2</span><span class="p">;</span><span class="w">  </span>
<span class="w">  </span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">isr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">  </span>
<span class="w">        </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span><span class="w">  </span>
<span class="w">        </span><span class="k">goto</span><span class="w"> </span><span class="n">fail3</span><span class="p">;</span><span class="w">  </span>
<span class="w">    </span><span class="p">}</span><span class="w">  </span>
<span class="w">  </span>
<span class="cp">#ifndef CONFIG_MUSB_PIO_ONLY  </span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">use_dma</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma_mask</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">                  </span><span class="c1">//屏蔽DMA  </span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">dma_controller</span><span class="w">   </span><span class="o">*</span><span class="n">c</span><span class="p">;</span><span class="w">  </span>
<span class="w">  </span>
<span class="w">        </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dma_controller_create</span><span class="p">(</span><span class="n">musb</span><span class="p">,</span><span class="w"> </span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">mregs</span><span class="p">);</span><span class="w">  </span>
<span class="w">        </span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">dma_controller</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c</span><span class="p">;</span><span class="w">  </span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="w">  </span>
<span class="w">            </span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="n">c</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">(</span><span class="n">c</span><span class="p">);</span><span class="w">  </span>
<span class="w">    </span><span class="p">}</span><span class="w">  </span>
<span class="cp">#endif  </span>
<span class="w">    </span><span class="cm">/* ideally this would be abstracted in platform setup */</span><span class="w">  </span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">is_dma_capable</span><span class="p">()</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="o">!</span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">dma_controller</span><span class="p">)</span><span class="w">  </span>
<span class="w">        </span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma_mask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w">  </span>
<span class="w">  </span>
<span class="w">    </span><span class="cm">/* be sure interrupts are disabled before connecting ISR */</span><span class="w">       </span><span class="c1">//先关闭中断  </span>
<span class="w">    </span><span class="n">musb_platform_disable</span><span class="p">(</span><span class="n">musb</span><span class="p">);</span><span class="w">  </span>
<span class="w">    </span><span class="n">musb_generic_disable</span><span class="p">(</span><span class="n">musb</span><span class="p">);</span><span class="w">  </span>
<span class="w">  </span>
<span class="w">    </span><span class="cm">/* setup musb parts of the core (especially endpoints) */</span><span class="w">  </span>
<span class="w">    </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">musb_core_init</span><span class="p">(</span><span class="n">plat</span><span class="o">-&gt;</span><span class="n">config</span><span class="o">-&gt;</span><span class="n">multipoint</span><span class="w">                     </span><span class="c1">//这个是主要函数  </span>
<span class="w">            </span><span class="o">?</span><span class="w"> </span><span class="n">MUSB_CONTROLLER_MHDRC</span><span class="w">  </span>
<span class="w">            </span><span class="o">:</span><span class="w"> </span><span class="n">MUSB_CONTROLLER_HDRC</span><span class="p">,</span><span class="w"> </span><span class="n">musb</span><span class="p">);</span><span class="w">  </span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">status</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w">  </span>
<span class="w">        </span><span class="k">goto</span><span class="w"> </span><span class="n">fail3</span><span class="p">;</span><span class="w">  </span>
<span class="w">  </span>
<span class="cp">#ifdef CONFIG_USB_MUSB_OTG  </span>
<span class="w">    </span><span class="n">setup_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">otg_timer</span><span class="p">,</span><span class="w"> </span><span class="n">musb_otg_timer_func</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="p">)</span><span class="w"> </span><span class="n">musb</span><span class="p">);</span><span class="w">  </span>
<span class="cp">#endif  </span>
<span class="w">  </span>
<span class="w">    </span><span class="cm">/* Init IRQ workqueue before request_irq */</span><span class="w">  </span>
<span class="w">    </span><span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">irq_work</span><span class="p">,</span><span class="w"> </span><span class="n">musb_irq_work</span><span class="p">);</span><span class="w">                  </span><span class="c1">//初始化工作队列  </span>
<span class="w">  </span>
<span class="w">    </span><span class="cm">/* attach to the IRQ */</span><span class="w">  </span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">request_irq</span><span class="p">(</span><span class="n">nIrq</span><span class="p">,</span><span class="w"> </span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">isr</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">dev_name</span><span class="p">(</span><span class="n">dev</span><span class="p">),</span><span class="w"> </span><span class="n">musb</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w">    </span><span class="c1">//申请中断号  </span>
<span class="w">        </span><span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;request_irq %d failed!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">nIrq</span><span class="p">);</span><span class="w">  </span>
<span class="w">        </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span><span class="w">  </span>
<span class="w">        </span><span class="k">goto</span><span class="w"> </span><span class="n">fail3</span><span class="p">;</span><span class="w">  </span>
<span class="w">    </span><span class="p">}</span><span class="w">  </span>
<span class="w">    </span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">nIrq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nIrq</span><span class="p">;</span><span class="w">  </span>
<span class="cm">/* FIXME this handles wakeup irqs wrong */</span><span class="w">  </span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">enable_irq_wake</span><span class="p">(</span><span class="n">nIrq</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">  </span>
<span class="w">        </span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">irq_wake</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">  </span>
<span class="w">        </span><span class="n">device_init_wakeup</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w">  </span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">  </span>
<span class="w">        </span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">irq_wake</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span>
<span class="w">    </span><span class="p">}</span><span class="w">  </span>
<span class="w">  </span>
<span class="w">    </span><span class="cm">/* host side needs more setup */</span><span class="w">                   </span><span class="c1">//使能host模式  </span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">is_host_enabled</span><span class="p">(</span><span class="n">musb</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w">  </span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">usb_hcd</span><span class="w">  </span><span class="o">*</span><span class="n">hcd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">musb_to_hcd</span><span class="p">(</span><span class="n">musb</span><span class="p">);</span><span class="w">  </span>
<span class="w">  </span>
<span class="w">        </span><span class="n">otg_set_host</span><span class="p">(</span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">xceiv</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">);</span><span class="w">  </span>
<span class="w">  </span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">is_otg_enabled</span><span class="p">(</span><span class="n">musb</span><span class="p">))</span><span class="w">  </span>
<span class="w">            </span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">otg_port</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">  </span>
<span class="w">        </span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">xceiv</span><span class="o">-&gt;</span><span class="n">host</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">;</span><span class="w">  </span>
<span class="w">        </span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">power_budget</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">plat</span><span class="o">-&gt;</span><span class="n">power</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">250</span><span class="p">);</span><span class="w">  </span>
<span class="w">  </span>
<span class="w">        </span><span class="cm">/* program PHY to use external vBus if required */</span><span class="w">  </span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">plat</span><span class="o">-&gt;</span><span class="n">extvbus</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">  </span>
<span class="w">            </span><span class="n">u8</span><span class="w"> </span><span class="n">busctl</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">musb_read_ulpi_buscontrol</span><span class="p">(</span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">mregs</span><span class="p">);</span><span class="w">  </span>
<span class="w">            </span><span class="n">busctl</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">MUSB_ULPI_USE_EXTVBUS</span><span class="p">;</span><span class="w">  </span>
<span class="w">            </span><span class="n">musb_write_ulpi_buscontrol</span><span class="p">(</span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">mregs</span><span class="p">,</span><span class="w"> </span><span class="n">busctl</span><span class="p">);</span><span class="w">  </span>
<span class="w">        </span><span class="p">}</span><span class="w">  </span>
<span class="w">    </span><span class="p">}</span><span class="w">  </span>
<span class="w">  </span>
<span class="w">    </span><span class="cm">/* For the host-only role, we can activate right away. </span>
<span class="cm">     * (We expect the ID pin to be forcibly grounded!!) </span>
<span class="cm">     * Otherwise, wait till the gadget driver hooks up. </span>
<span class="cm">     */</span><span class="w">  </span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">is_otg_enabled</span><span class="p">(</span><span class="n">musb</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">is_host_enabled</span><span class="p">(</span><span class="n">musb</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w">         </span><span class="c1">//如果使能了 OTG 模式或 host 模式  </span>
<span class="w">        </span><span class="n">MUSB_HST_MODE</span><span class="p">(</span><span class="n">musb</span><span class="p">);</span><span class="w">  </span>
<span class="w">        </span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">xceiv</span><span class="o">-&gt;</span><span class="n">default_a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">  </span>
<span class="w">        </span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">xceiv</span><span class="o">-&gt;</span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">OTG_STATE_A_IDLE</span><span class="p">;</span><span class="w">  </span>
<span class="w">  </span>
<span class="w">        </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">usb_add_hcd</span><span class="p">(</span><span class="n">musb_to_hcd</span><span class="p">(</span><span class="n">musb</span><span class="p">),</span><span class="w"> </span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w">       </span><span class="c1">//把 musb 添加到 hcd（host controller driver）中  </span>
<span class="w">  </span>
<span class="w">        </span><span class="n">DBG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;%s mode, status %d, devctl %02x %c</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w">  </span>
<span class="w">            </span><span class="s">&quot;HOST&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">status</span><span class="p">,</span><span class="w">  </span>
<span class="w">            </span><span class="n">musb_readb</span><span class="p">(</span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">mregs</span><span class="p">,</span><span class="w"> </span><span class="n">MUSB_DEVCTL</span><span class="p">),</span><span class="w">  </span>
<span class="w">            </span><span class="p">(</span><span class="n">musb_readb</span><span class="p">(</span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">mregs</span><span class="p">,</span><span class="w"> </span><span class="n">MUSB_DEVCTL</span><span class="p">)</span><span class="w">  </span>
<span class="w">                    </span><span class="o">&amp;</span><span class="w"> </span><span class="n">MUSB_DEVCTL_BDEVICE</span><span class="w">  </span>
<span class="w">                </span><span class="o">?</span><span class="w"> </span><span class="sc">&#39;B&#39;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="sc">&#39;A&#39;</span><span class="p">));</span><span class="w">  </span>
<span class="w">  </span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="cm">/* peripheral is enabled */</span><span class="w"> </span><span class="p">{</span><span class="w">                         </span><span class="c1">//如果使能了 Peripheral 模式  </span>
<span class="w">        </span><span class="n">MUSB_DEV_MODE</span><span class="p">(</span><span class="n">musb</span><span class="p">);</span><span class="w">  </span>
<span class="w">        </span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">xceiv</span><span class="o">-&gt;</span><span class="n">default_a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span>
<span class="w">        </span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">xceiv</span><span class="o">-&gt;</span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">OTG_STATE_B_IDLE</span><span class="p">;</span><span class="w">  </span>
<span class="w">   </span>
<span class="w">        </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">musb_gadget_setup</span><span class="p">(</span><span class="n">musb</span><span class="p">);</span><span class="w">                    </span><span class="c1">//则建立 gadget  </span>
<span class="w">  </span>
<span class="w">        </span><span class="n">DBG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;%s mode, status %d, dev%02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w">  </span>
<span class="w">            </span><span class="n">is_otg_enabled</span><span class="p">(</span><span class="n">musb</span><span class="p">)</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="s">&quot;OTG&quot;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="s">&quot;PERIPHERAL&quot;</span><span class="p">,</span><span class="w">  </span>
<span class="w">            </span><span class="n">status</span><span class="p">,</span><span class="w">  </span>
<span class="w">            </span><span class="n">musb_readb</span><span class="p">(</span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">mregs</span><span class="p">,</span><span class="w"> </span><span class="n">MUSB_DEVCTL</span><span class="p">));</span><span class="w">  </span>
<span class="w">  </span>
<span class="w">    </span><span class="p">}</span><span class="w">  </span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">status</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w">  </span>
<span class="w">        </span><span class="k">goto</span><span class="w"> </span><span class="n">fail3</span><span class="p">;</span><span class="w">  </span>
<span class="w">  </span>
<span class="cp">#ifdef CONFIG_SYSFS  </span>
<span class="w">    </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sysfs_create_group</span><span class="p">(</span><span class="o">&amp;</span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">controller</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">musb_attr_group</span><span class="p">);</span><span class="w">     </span><span class="c1">//在 /sys 下建立目录  </span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">status</span><span class="p">)</span><span class="w">  </span>
<span class="w">        </span><span class="k">goto</span><span class="w"> </span><span class="n">fail4</span><span class="p">;</span><span class="w">  </span>
<span class="cp">#endif  </span>
<span class="w">  </span>
<span class="w">    </span><span class="n">dev_info</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;USB %s mode controller at %p using %s, IRQ %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w">            </span><span class="c1">//dmesg中打印消息  </span>
<span class="w">            </span><span class="p">({</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">s</span><span class="p">;</span><span class="w">  </span>
<span class="w">             </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">board_mode</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">  </span>
<span class="w">             </span><span class="k">case</span><span class="w"> </span><span class="no">MUSB_HOST</span><span class="p">:</span><span class="w">        </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Host&quot;</span><span class="p">;</span><span class="w"> </span><span class="k">break</span><span class="p">;</span><span class="w">  </span>
<span class="w">             </span><span class="k">case</span><span class="w"> </span><span class="no">MUSB_PERIPHERAL</span><span class="p">:</span><span class="w">  </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Peripheral&quot;</span><span class="p">;</span><span class="w"> </span><span class="k">break</span><span class="p">;</span><span class="w">  </span>
<span class="w">             </span><span class="k">default</span><span class="o">:</span><span class="w">       </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;OTG&quot;</span><span class="p">;</span><span class="w"> </span><span class="k">break</span><span class="p">;</span><span class="w">  </span>
<span class="w">             </span><span class="p">};</span><span class="w"> </span><span class="n">s</span><span class="p">;</span><span class="w"> </span><span class="p">}),</span><span class="w">  </span>
<span class="w">            </span><span class="n">ctrl</span><span class="p">,</span><span class="w">  </span>
<span class="w">            </span><span class="p">(</span><span class="n">is_dma_capable</span><span class="p">()</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">dma_controller</span><span class="p">)</span><span class="w">  </span>
<span class="w">            </span><span class="o">?</span><span class="w"> </span><span class="s">&quot;DMA&quot;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="s">&quot;PIO&quot;</span><span class="p">,</span><span class="w">  </span>
<span class="w">            </span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">nIrq</span><span class="p">);</span><span class="w">  </span>
<span class="w">  </span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span>
<span class="w">  </span>
<span class="nl">fail4</span><span class="p">:</span><span class="w">  </span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">is_otg_enabled</span><span class="p">(</span><span class="n">musb</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">is_host_enabled</span><span class="p">(</span><span class="n">musb</span><span class="p">))</span><span class="w">       </span>
<span class="w">        </span><span class="n">usb_remove_hcd</span><span class="p">(</span><span class="n">musb_to_hcd</span><span class="p">(</span><span class="n">musb</span><span class="p">));</span><span class="w">  </span>
<span class="w">    </span><span class="k">else</span><span class="w">  </span>
<span class="w">        </span><span class="n">musb_gadget_cleanup</span><span class="p">(</span><span class="n">musb</span><span class="p">);</span><span class="w">  </span>
<span class="w">  </span>
<span class="nl">fail3</span><span class="p">:</span><span class="w">  </span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">irq_wake</span><span class="p">)</span><span class="w">  </span>
<span class="w">        </span><span class="n">device_init_wakeup</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w">  </span>
<span class="w">    </span><span class="n">musb_platform_exit</span><span class="p">(</span><span class="n">musb</span><span class="p">);</span><span class="w">  </span>
<span class="w">  </span>
<span class="nl">fail2</span><span class="p">:</span><span class="w">  </span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">clock</span><span class="p">)</span><span class="w">  </span>
<span class="w">        </span><span class="n">clk_put</span><span class="p">(</span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">clock</span><span class="p">);</span><span class="w">  </span>
<span class="w">  </span>
<span class="nl">fail1</span><span class="p">:</span><span class="w">  </span>
<span class="w">    </span><span class="n">dev_err</span><span class="p">(</span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">controller</span><span class="p">,</span><span class="w">  </span>
<span class="w">        </span><span class="s">&quot;musb_init_controller failed with status %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">status</span><span class="p">);</span><span class="w">  </span>
<span class="w">  </span>
<span class="w">    </span><span class="n">musb_free</span><span class="p">(</span><span class="n">musb</span><span class="p">);</span><span class="w">  </span>
<span class="w">  </span>
<span class="nl">fail0</span><span class="p">:</span><span class="w">  </span>
<span class="w">  </span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">status</span><span class="p">;</span><span class="w">  </span>
<span class="w">  </span>
<span class="p">}</span><span class="w">  </span>
</pre></div>
</div>
<section id="usb-add-hcdhcd-host-controller-device">
<h3>1. usb_add_hcd注册主控制器HCD(host controller device/主)<a class="headerlink" href="#usb-add-hcdhcd-host-controller-device" title="此标题的永久链接"></a></h3>
<p>参考：</p>
<ul class="simple">
<li><p><a class="reference external" href="https://blog.csdn.net/mike8825/article/details/103756462">USB驱动之二控制器驱动(musb)</a></p></li>
</ul>
<p>来看一下host controller是如何驱动的，软件流程如下，我们发现，他们都会去执行下面的调用：调用usb_create_hcd()来创建usb_hcd结构体；调用usb_add_hcd()来把主控制器添加到usb总线上。</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="o">*</span><span class="w"> </span><span class="n">musb_init_controller</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">device</span><span class="w"> </span><span class="o">*</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">nIrq</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">__iomem</span><span class="w"> </span><span class="o">*</span><span class="n">ctrl</span><span class="p">)</span><span class="w">  </span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="o">*</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">musb</span><span class="w"> </span><span class="o">*</span><span class="n">allocate_instance</span><span class="p">(...)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">hcd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">usb_create_hcd</span><span class="p">(</span><span class="o">&amp;</span><span class="n">musb_hc_driver</span><span class="p">,</span><span class="w"> </span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="n">dev_name</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">hcd</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="cm">/* usbcore sets dev-&gt;driver_data to hcd, and sometimes uses that... */</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">usb_add_hcd</span><span class="p">(</span><span class="n">musb_to_hcd</span><span class="p">(</span><span class="n">musb</span><span class="p">),</span><span class="w"> </span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w">       </span><span class="c1">//把 musb 添加到 hcd（host controller driver）中  </span>
<span class="p">}</span><span class="w"></span>

<span class="n">musb_host</span><span class="p">.</span><span class="n">c</span><span class="o">:</span><span class="w"></span>
<span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">hc_driver</span><span class="w"> </span><span class="n">musb_hc_driver</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="p">.</span><span class="n">description</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;musb-hcd&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">	</span><span class="p">.</span><span class="n">product_desc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;MUSB HDRC host driver&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">	</span><span class="p">.</span><span class="n">hcd_priv_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">musb</span><span class="p">),</span><span class="w"></span>
<span class="w">	</span><span class="p">.</span><span class="n">flags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">HCD_USB2</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">HCD_MEMORY</span><span class="p">,</span><span class="w"></span>

<span class="w">	</span><span class="cm">/* not using irq handler or reset hooks from usbcore, since</span>
<span class="cm">	 * those must be shared with peripheral code for OTG configs</span>
<span class="cm">	 */</span><span class="w"></span>

<span class="w">	</span><span class="p">.</span><span class="n">start</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">musb_h_start</span><span class="p">,</span><span class="w"></span>
<span class="w">	</span><span class="p">.</span><span class="n">stop</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">musb_h_stop</span><span class="p">,</span><span class="w"></span>

<span class="w">	</span><span class="p">.</span><span class="n">get_frame_number</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">musb_h_get_frame_number</span><span class="p">,</span><span class="w"></span>

<span class="w">	</span><span class="p">.</span><span class="n">urb_enqueue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">musb_urb_enqueue</span><span class="p">,</span><span class="w"></span>
<span class="w">	</span><span class="p">.</span><span class="n">urb_dequeue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">musb_urb_dequeue</span><span class="p">,</span><span class="w"></span>
<span class="w">	</span><span class="p">.</span><span class="n">endpoint_disable</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">musb_h_disable</span><span class="p">,</span><span class="w"></span>

<span class="w">	</span><span class="p">.</span><span class="n">hub_status_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">musb_hub_status_data</span><span class="p">,</span><span class="w"></span>
<span class="w">	</span><span class="p">.</span><span class="n">hub_control</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">musb_hub_control</span><span class="p">,</span><span class="w"></span>
<span class="w">	</span><span class="p">.</span><span class="n">bus_suspend</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">musb_bus_suspend</span><span class="p">,</span><span class="w"></span>
<span class="w">	</span><span class="p">.</span><span class="n">bus_resume</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">musb_bus_resume</span><span class="p">,</span><span class="w"></span>
<span class="w">	</span><span class="cm">/* .start_port_reset    = NULL, */</span><span class="w"></span>
<span class="w">	</span><span class="cm">/* .hub_irq_enable      = NULL, */</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>这些ops是谁调用呢？</p>
<p>比如endpoint_disable，貌似都是给usb_core(usb总线)调用的，我们索引到<code class="docutils literal notranslate"><span class="pre">kernel-4.19/drivers/usb/core/hcd.c</span></code>:</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">usb_hcd_disable_endpoint</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">usb_device</span><span class="w"> </span><span class="o">*</span><span class="n">udev</span><span class="p">,</span><span class="w"></span>
<span class="w">                </span><span class="k">struct</span><span class="w"> </span><span class="nc">usb_host_endpoint</span><span class="w"> </span><span class="o">*</span><span class="n">ep</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">usb_hcd</span><span class="w">          </span><span class="o">*</span><span class="n">hcd</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="n">might_sleep</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="n">hcd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bus_to_hcd</span><span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">endpoint_disable</span><span class="p">)</span><span class="w"></span>
<span class="w">                </span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">endpoint_disable</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span><span class="w"> </span><span class="n">ep</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">core</span><span class="o">/</span><span class="n">driver</span><span class="p">.</span><span class="n">c</span><span class="o">:</span><span class="w"></span>
<span class="o">*</span><span class="w"> </span><span class="n">usb_probe_interface</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">device</span><span class="w"> </span><span class="o">*</span><span class="n">dev</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="o">*</span><span class="w"> </span><span class="n">usb_set_interface</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">usb_device</span><span class="w"> </span><span class="o">*</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">interface</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">alternate</span><span class="p">)</span><span class="w"> </span><span class="c1">//core/message.c:</span>
<span class="w">    </span><span class="o">*</span><span class="w"> </span><span class="n">usb_disable_interface</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">usb_device</span><span class="w"> </span><span class="o">*</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">usb_interface</span><span class="w"> </span><span class="o">*</span><span class="n">intf</span><span class="p">,</span><span class="w"></span>
<span class="w">      </span><span class="o">*</span><span class="w"> </span><span class="n">usb_disable_endpoint</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">usb_device</span><span class="w"> </span><span class="o">*</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">epaddr</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">reset_hardware</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>HCD的注册过程:</p>
<p><img alt="0001_0003.png" src="../../../_images/0001_00033.png" /></p>
</section>
<section id="musb-gadget-setupudc-usb-device-controllerr">
<h3>2.musb_gadget_setup注册从控制器UDC(usb device controllerr/从)<a class="headerlink" href="#musb-gadget-setupudc-usb-device-controllerr" title="此标题的永久链接"></a></h3>
<p>参考：</p>
<ul class="simple">
<li><p><a class="reference external" href="https://blog.csdn.net/u013836909/article/details/114953427">gadget之udc</a></p></li>
<li><p><a class="reference external" href="https://blog.csdn.net/u013836909/article/details/114952794">gadget驱动框架（一）</a></p></li>
</ul>
<p>udc全称为（usb device conctrl），usb设备控制器，其为某soc的usb device的控制器，将usb device的功能抽象，转换成一个个可实现的实例。相关源码如下：</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="c1">//udc的核心层代码</span>
<span class="n">drivers</span><span class="o">/</span><span class="n">usb</span><span class="o">/</span><span class="n">gadget</span><span class="o">/</span><span class="n">core</span><span class="p">.</span><span class="n">c</span><span class="w"> </span>
<span class="c1">//udc控制器的代码，具体需要编写udc驱动者实现</span>
<span class="n">drivers</span><span class="o">/</span><span class="n">misc</span><span class="o">/</span><span class="n">mediatek</span><span class="o">/</span><span class="n">usb20</span><span class="o">/</span><span class="n">mt6765</span><span class="o">/</span><span class="n">musb_gadget</span><span class="p">.</span><span class="n">c</span><span class="w"></span>
</pre></div>
</div>
<ul class="simple">
<li><p>结构体：</p></li>
</ul>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * struct usb_udc - describes one usb device controller</span>
<span class="cm"> * @driver - the gadget driver pointer. For use by the class code</span>
<span class="cm"> * @dev - the child device to the actual controller</span>
<span class="cm"> * @gadget - the gadget. For use by the class code</span>
<span class="cm"> * @list - for use by the udc class driver</span>
<span class="cm"> * @vbus - for udcs who care about vbus status, this value is real vbus status;</span>
<span class="cm"> * for udcs who do not care about vbus status, this value is always true</span>
<span class="cm"> *</span>
<span class="cm"> * This represents the internal data structure which is used by the UDC-class</span>
<span class="cm"> * to hold information about udc driver and gadget together.</span>
<span class="cm"> */</span><span class="w"></span>
<span class="k">struct</span><span class="w"> </span><span class="nc">usb_udc</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="k">struct</span><span class="w"> </span><span class="nc">usb_gadget_driver</span><span class="w">	</span><span class="o">*</span><span class="n">driver</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="k">struct</span><span class="w"> </span><span class="nc">usb_gadget</span><span class="w">		</span><span class="o">*</span><span class="n">gadget</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="k">struct</span><span class="w"> </span><span class="nc">device</span><span class="w">			</span><span class="n">dev</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="k">struct</span><span class="w"> </span><span class="nc">list_head</span><span class="w">		</span><span class="n">list</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="kt">bool</span><span class="w">				</span><span class="n">vbus</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<section id="gadget">
<h4>gadget驱动框架<a class="headerlink" href="#gadget" title="此标题的永久链接"></a></h4>
<ul class="simple">
<li><p>gadget源码主要在：drivers/usb/gadget，以虚拟串口为例，对源文件做简单说明：</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">drivers/usb/gadget/function/*.c</span></code>:实现具体的usb功能，有serial、video、audio等</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">drivers/usb/gadget/legacy/*.c</span></code>:注册usb class驱动，往上与function衔接，往下与composite</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">drivers/usb/gadget/udc/*.c</span></code>：usb device conctrl，与各IC相关，需各自实现；</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">drivers/usb/gadget/composite.c</span></code>：复合设备，与硬件无关，往下与udc驱动衔接</p></li>
</ul>
</section>
<section id="id4">
<h4>gadget驱动架构图<a class="headerlink" href="#id4" title="此标题的永久链接"></a></h4>
<p><img alt="0001_0004.png" src="../../../_images/0001_00042.png" /></p>
</section>
<section id="id5">
<h4>gadget相关数据结构体关系<a class="headerlink" href="#id5" title="此标题的永久链接"></a></h4>
<p><img alt="0001_0005.png" src="../../../_images/0001_00052.png" /></p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span>musb_init_controller(struct device *dev, int nIrq, void __iomem *ctrl)  
{
	status = musb_gadget_setup(musb);
}

int musb_gadget_setup(struct musb *musb)
{
	int status;

	/* REVISIT minor race:  if (erroneously) setting up two
	 * musb peripherals at the same time, only the bus lock
	 * is probably held.
	 */

	musb-&gt;g.ops = &amp;musb_gadget_operations;
	musb-&gt;g.max_speed = USB_SPEED_HIGH;
	musb-&gt;g.speed = USB_SPEED_UNKNOWN;

	/* this &quot;gadget&quot; abstracts/virtualizes the controller */
	musb-&gt;g.name = musb_driver_name;
	musb-&gt;g.is_otg = 1;

	musb_g_init_endpoints(musb); //初始化endpoinit

	musb-&gt;is_active = 0;
	musb_platform_try_idle(musb, 0);

	/* Fix: gadget device dma ops is null,so add musb controller dma ops */
	/* to gadget device dma ops, otherwise will go do dma dump ops. */
#ifdef CONFIG_XEN
	if (musb-&gt;controller-&gt;archdata.dev_dma_ops) {
		DBG(0, &quot;musb controller dma ops is non-null\n&quot;);
		musb-&gt;g.dev.archdata.dev_dma_ops =
			musb-&gt;controller-&gt;archdata.dev_dma_ops;
	}
#endif

	status = usb_add_gadget_udc(musb-&gt;controller, &amp;musb-&gt;g);
	if (status)
		goto err;

	return 0;
err:
	musb-&gt;g.dev.parent = NULL;
	device_unregister(&amp;musb-&gt;g.dev);
	return status;
}

ops：
static const struct usb_gadget_ops musb_gadget_operations = {
	.get_frame = musb_gadget_get_frame,
	.wakeup = musb_gadget_wakeup,
	.set_selfpowered = musb_gadget_set_self_powered,
	/* .vbus_session                = musb_gadget_vbus_session, */
	.vbus_draw = musb_gadget_vbus_draw,
	.pullup = musb_gadget_pullup,
	.udc_start = musb_gadget_start,
	.udc_stop = musb_gadget_stop,
};
</pre></div>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">gadget/udc/core.c</span></code>:udc与usb_gadget绑定程序流程：</p></li>
</ul>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="o">*</span><span class="w"> </span><span class="n">usb_add_gadget_udc</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">device</span><span class="w"> </span><span class="o">*</span><span class="n">parent</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">usb_gadget</span><span class="w"> </span><span class="o">*</span><span class="n">gadget</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="o">*</span><span class="w"> </span><span class="n">usb_add_gadget_udc_release</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span><span class="w"> </span><span class="n">gadget</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="o">*</span><span class="w"> </span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">gadget</span><span class="p">;</span><span class="w"> </span><span class="c1">//udc 与 usb_gadget绑定</span>
<span class="w">    </span><span class="o">*</span><span class="w"> </span><span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">udc_list</span><span class="p">);</span><span class="c1">//将udc设备添加到udc_list链表中</span>
<span class="w">    </span><span class="o">*</span><span class="w"> </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">check_pending_gadget_drivers</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="o">*</span><span class="w"> </span><span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">driver</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">gadget_driver_pending_list</span><span class="p">,</span><span class="w"> </span><span class="n">pending</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="o">*</span><span class="w"> </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">udc_bind_to_driver</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span><span class="w"> </span><span class="n">driver</span><span class="p">);</span><span class="c1">//遍历gadget_driver_pending_list链表，如有usb_gadget_driver注册，则将其与udc设备绑定</span>
<span class="w">        </span><span class="o">*</span><span class="w"> </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">bind</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">,</span><span class="w"> </span><span class="n">driver</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="o">*</span><span class="w"> </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">usb_gadget_udc_start</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span><span class="c1">//回调usb_gadget的udc_start函数，启动udc控制器,该功能需udc控制器驱动（musb_host.c）实现</span>
<span class="w">        </span><span class="o">*</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">vbus</span><span class="p">)</span><span class="w"> </span><span class="n">usb_udc_connect_control</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span><span class="w"> </span><span class="c1">//如果识别到vbus插入，会回调到usb_gadget的pullup函数，配置上拉，连接到host，就是musb_gadget_operations里面的ops</span>
<span class="w">          </span><span class="o">*</span><span class="w"> </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">gadget</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">pullup</span><span class="p">(</span><span class="n">gadget</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<ul class="simple">
<li><p>musb_g_init_endpoints 初始化端点，udc所有操作端点的操作都在musb_ep_ops里面。</p></li>
</ul>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="o">*</span><span class="w"> </span><span class="n">musb_g_init_endpoints</span><span class="p">()</span><span class="w"></span>
<span class="w">  </span><span class="o">*</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">epnum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">hw_ep</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">endpoints</span><span class="p">;</span><span class="n">epnum</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">nr_endpoints</span><span class="p">;</span><span class="w"> </span><span class="n">epnum</span><span class="o">++</span><span class="p">,</span><span class="w"> </span><span class="n">hw_ep</span><span class="o">++</span><span class="p">)</span><span class="w"> </span>
<span class="w">  </span><span class="o">*</span><span class="w"> </span><span class="n">init_peripheral_ep</span><span class="p">(</span><span class="n">musb</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">hw_ep</span><span class="o">-&gt;</span><span class="n">ep_in</span><span class="p">,</span><span class="w"> </span><span class="n">epnum</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="o">*</span><span class="w"> </span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">end_point</span><span class="p">.</span><span class="n">ops</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">musb_ep_ops</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="o">*</span><span class="w"> </span><span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">end_point</span><span class="p">.</span><span class="n">ep_list</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">g</span><span class="p">.</span><span class="n">ep_list</span><span class="p">);</span><span class="w"></span>

<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">usb_ep_ops</span><span class="w"> </span><span class="n">musb_ep_ops</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="p">.</span><span class="n">enable</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">musb_gadget_enable</span><span class="p">,</span><span class="w"></span>
<span class="w">	</span><span class="p">.</span><span class="n">disable</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">musb_gadget_disable</span><span class="p">,</span><span class="w"></span>
<span class="w">	</span><span class="p">.</span><span class="n">alloc_request</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">musb_alloc_request</span><span class="p">,</span><span class="w"></span>
<span class="w">	</span><span class="p">.</span><span class="n">free_request</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">musb_free_request</span><span class="p">,</span><span class="w"></span>
<span class="w">	</span><span class="p">.</span><span class="n">queue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">musb_gadget_queue</span><span class="p">,</span><span class="w"></span>
<span class="w">	</span><span class="p">.</span><span class="n">dequeue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">musb_gadget_dequeue</span><span class="p">,</span><span class="w"></span>
<span class="w">	</span><span class="p">.</span><span class="n">set_halt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">musb_gadget_set_halt</span><span class="p">,</span><span class="w"></span>
<span class="w">	</span><span class="p">.</span><span class="n">set_wedge</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">musb_gadget_set_wedge</span><span class="p">,</span><span class="w"></span>
<span class="w">	</span><span class="p">.</span><span class="n">fifo_status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">musb_gadget_fifo_status</span><span class="p">,</span><span class="w"></span>
<span class="w">	</span><span class="p">.</span><span class="n">fifo_flush</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">musb_gadget_fifo_flush</span><span class="p">,</span><span class="w"></span>
<span class="cp">#if defined(CONFIG_MTK_MD_DIRECT_TETHERING_SUPPORT)</span>
<span class="w">	</span><span class="o">||</span><span class="w"> </span><span class="n">defined</span><span class="p">(</span><span class="n">CONFIG_MTK_MD_DIRECT_LOGGING_SUPPORT</span><span class="p">)</span><span class="w"></span>
<span class="w">	</span><span class="p">.</span><span class="n">suspend_control</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">musb_gadget_suspend_control</span><span class="p">,</span><span class="w"></span>
<span class="w">	</span><span class="p">.</span><span class="n">resume_control</span><span class="w">	</span><span class="o">=</span><span class="w"> </span><span class="n">musb_gadget_resume_control</span><span class="p">,</span><span class="w"></span>
<span class="cp">#endif</span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
</section>
</section>


           </div>
             <div class="articleComments">
                <comments>
  <script src="https://utteranc.es/client.js"
    repo="iswbm/magic-python"
    issue-term="pathname"
    theme="github-light"
    crossorigin="anonymous"
    async>
  </script>
</comments>
             </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; 版权所有 2022, wugn.</p>
  </div>

  利用 <a href="https://www.sphinx-doc.org/">Sphinx</a> 构建，使用了 
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">主题</a>
    由 <a href="https://readthedocs.org">Read the Docs</a>开发.
  

<script charset="UTF-8" id="LA_COLLECT" src="//sdk.51.la/js-sdk-pro.min.js"></script>
<script>LA.init({id: "JoV5csIHTGhHiGQ4",ck: "JoV5csIHTGhHiGQ4"})</script>

<br/>
<script id="LA-DATA-WIDGET" crossorigin="anonymous" charset="UTF-8" src="https://v6-widget.51.la/v6/JoV5csIHTGhHiGQ4/quote.js?theme=#4C8AC2,#BB2626,#040000,#333333,#AE3535,#1690FF,14&f=14"></script>



</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>