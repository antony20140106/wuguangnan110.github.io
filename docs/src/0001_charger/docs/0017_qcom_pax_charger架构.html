<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>wugn</title>

      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/default.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../index.html" class="icon icon-home"> wugn_note
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <!-- Local TOC -->
              <div class="local-toc"><ul>
<li><a class="reference internal" href="#">概述</a></li>
<li><a class="reference internal" href="#id2">参考</a></li>
<li><a class="reference internal" href="#id3">架构图</a></li>
<li><a class="reference internal" href="#charger-class">charger_class架构介绍</a></li>
<li><a class="reference internal" href="#id4">底座充电功能开发</a></li>
<li><a class="reference internal" href="#id5">问题点</a><ul>
<li><a class="reference internal" href="#bc1-2">bc1.2轮询方案</a></li>
<li><a class="reference internal" href="#charger-routine-threadmsleep">charger_routine_thread不能加msleep</a></li>
</ul>
</li>
</ul>
</div>
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">wugn_note</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs"> 
<li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
<li>概述</li>
<li style="float: right;margin-left: 10px;"><a href="javascript:history.forward()">Forward</a></li>
<li style="float: right;margin-left: 10px;"><a href="javascript:history.back()">Go Back</a> | </li>
<li style="float: right;margin-left: 10px;"><a href="/index.html">Home</a> | </li>

      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="id1">
<h1>概述<a class="headerlink" href="#id1" title="Permalink to this heading"></a></h1>
<p>目前charger使用外置的mp2721，qcom pm4125模块功能全部关闭了，需要自己搭建charger架构。</p>
</section>
<section id="id2">
<h1>参考<a class="headerlink" href="#id2" title="Permalink to this heading"></a></h1>
<ul class="simple">
<li><p><a class="reference external" href="https://blog.csdn.net/yuewen2008/article/details/80594198">MT6739 充电&amp;电量计代码架构变化梳理</a></p></li>
</ul>
</section>
<section id="id3">
<h1>架构图<a class="headerlink" href="#id3" title="Permalink to this heading"></a></h1>
<p>目前mp2721在检测到SNK attach后，会反复轮询bc12检测是否完成，完成后会通知pax_charger并唤醒充电线程进行plug in配置充电，并5s轮询一次充电状态。
<img alt="0017_0000.png" src="../../../_images/0017_0000.png" /></p>
</section>
<section id="charger-class">
<h1>charger_class架构介绍<a class="headerlink" href="#charger-class" title="Permalink to this heading"></a></h1>
<p>charger_class.c文件封装了底层操作chargeric的一些函数，并向linux内核注册一个类文件，名称为switch_charging的类。每一个驱动ic在加载时只需要在该类文件下向内核注册名为primary_chg的设备文件即可。</p>
<ul class="simple">
<li><p>charger ic注册：</p></li>
</ul>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span>dts:
	mp2721@3f {
			compatible = &quot;pax,mp2721&quot;;
			charger_name = &quot;primary_chg&quot;;
	}
		
代码：
static int mp2721_parse_dt(struct device *dev)
{
	if (of_property_read_string(np, &quot;charger_name&quot;,
						&amp;g_mp2721_info-&gt;chg_dev_name) &lt; 0) {
		g_mp2721_info-&gt;chg_dev_name = &quot;primary_chg&quot;;
		chr_mp2721_debug(&quot;%s: no charger name\n&quot;, __func__);
	}

}

注册,最主要的是charger ic的ops：
static struct charger_ops mp2721_chg_ops = {
	/* Normal charging */
	.dump_registers = chg_dump,
	.plug_out = mp2721_plug_out,
	.plug_in = mp2721_plug_in,
	.enable = mp2721_enable_charger,

	//.enable_termination = mp2721_enable_te,

	/* charging current or voltage limit */
	.get_min_charging_current = mp2721_get_min_ichg,
	.get_min_input_current = mp2721_get_min_aicr,
	.set_input_current = mp2721_set_aicr,
	.set_charging_current = mp2721_set_ichg,
	.set_constant_voltage = mp2721_set_cv,
	.set_mivr = mp2721_set_mivr,
	.get_mivr = mp2721_get_mivr,

	.is_charging_done = mp2721_get_charging_status,

	/* Safety timer
	.enable_safety_timer = mp2721_enable_safetytimer,
	.is_safety_timer_enabled = mp2721_is_safetytimer_enable,
	.set_safety_timer = mp2721_set_safetytimer,
	*/

	/* Power path */
	.enable_powerpath = mp2721_enable_powerpath,
	.is_powerpath_enabled = mp2721_get_is_powerpath_enable,

	/* Charger type detection */
	.get_charger_type = mp2721_charge_type,
	//.enable_chg_type_det = mp2721_enable_chg_type_det,

	/* OTG */
	.enable_otg = mp2721_set_otg_enable,
	.set_boost_current_limit = mp2721_set_otg_current,

#if 0
	.get_ibus_adc = mp2721_get_ibus,
	.get_vbus_adc = mp2721_get_vbus,
#endif
	//.event = mp2721_do_event,

	.enable_vbus_ovp = mp2721_enable_vbus_ovp,
	.get_fault_status = mp2721_get_fault_status,

	//set_en_hiz = mp2721_set_en_hiz,
	//.get_en_hiz = mp2721_get_en_hiz,
};

static int mp2721_charger_probe(struct i2c_client *client,
				 const struct i2c_device_id *id)
{
	mp2721_info-&gt;chg_dev = charger_dev_register(mp2721_info-&gt;chg_dev_name,
						&amp;client-&gt;dev, mp2721_info, &amp;mp2721_chg_ops, &amp;mp2721_info-&gt;chg_props);
}
</pre></div>
</div>
<ul class="simple">
<li><p>charger_class注册函数：</p></li>
</ul>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="n">charger_class</span><span class="p">.</span><span class="n">c</span><span class="w"></span>
<span class="k">struct</span><span class="w"> </span><span class="nc">charger_device</span><span class="w"> </span><span class="o">*</span><span class="n">charger_dev_register</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">name</span><span class="p">,</span><span class="w"></span>
<span class="w">		</span><span class="k">struct</span><span class="w"> </span><span class="nc">device</span><span class="w"> </span><span class="o">*</span><span class="n">parent</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">devdata</span><span class="p">,</span><span class="w"></span>
<span class="w">		</span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">charger_ops</span><span class="w"> </span><span class="o">*</span><span class="n">ops</span><span class="p">,</span><span class="w"></span>
<span class="w">		</span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">charger_properties</span><span class="w"> </span><span class="o">*</span><span class="n">props</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="k">struct</span><span class="w"> </span><span class="nc">charger_device</span><span class="w"> </span><span class="o">*</span><span class="n">chg_dev</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="k">static</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">lock_class_key</span><span class="w"> </span><span class="n">key</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="k">struct</span><span class="w"> </span><span class="nc">srcu_notifier_head</span><span class="w"> </span><span class="o">*</span><span class="n">head</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="kt">int</span><span class="w"> </span><span class="n">rc</span><span class="p">;</span><span class="w"></span>

<span class="w">	</span><span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: name=%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">__func__</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="n">chg_dev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">chg_dev</span><span class="p">),</span><span class="w"> </span><span class="n">GFP_KERNEL</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">chg_dev</span><span class="p">)</span><span class="w"></span>
<span class="w">		</span><span class="k">return</span><span class="w"> </span><span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span><span class="w"></span>

<span class="w">	</span><span class="n">head</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">chg_dev</span><span class="o">-&gt;</span><span class="n">evt_nh</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">srcu_init_notifier_head</span><span class="p">(</span><span class="n">head</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="cm">/* Rename srcu&#39;s lock to avoid LockProve warning */</span><span class="w"></span>
<span class="w">	</span><span class="n">lockdep_init_map</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">srcu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">dep_map</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chg_dev</span><span class="o">-&gt;</span><span class="n">ops_lock</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="n">chg_dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="k">class</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">charger_class</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">chg_dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">parent</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">chg_dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">release</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">charger_device_release</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">dev_set_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chg_dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="n">dev_set_drvdata</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chg_dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="n">devdata</span><span class="p">);</span><span class="w"></span>

<span class="w">	</span><span class="cm">/* Copy properties */</span><span class="w"></span>
<span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">props</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chg_dev</span><span class="o">-&gt;</span><span class="n">props</span><span class="p">,</span><span class="w"> </span><span class="n">props</span><span class="p">,</span><span class="w"></span>
<span class="w">			   </span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">charger_properties</span><span class="p">));</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>
<span class="w">	</span><span class="n">rc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">device_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chg_dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span><span class="w"> </span><span class="c1">//每一个驱动ic在加载时只需要在该类文件下向内核注册名为primary_chg的设备文件即可。</span>
<span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">rc</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="n">kfree</span><span class="p">(</span><span class="n">chg_dev</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="k">return</span><span class="w"> </span><span class="n">ERR_PTR</span><span class="p">(</span><span class="n">rc</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>
<span class="w">	</span><span class="n">chg_dev</span><span class="o">-&gt;</span><span class="n">ops</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ops</span><span class="p">;</span><span class="w"> </span><span class="c1">//负责该设备的ops操作</span>
<span class="w">	</span><span class="k">return</span><span class="w"> </span><span class="n">chg_dev</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">__init</span><span class="w"> </span><span class="n">charger_class_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="n">charger_class</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">class_create</span><span class="p">(</span><span class="n">THIS_MODULE</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;switching_charger&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">charger_class</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="n">pr_notice</span><span class="p">(</span><span class="s">&quot;Unable to create charger class; errno = %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">			</span><span class="n">PTR_ERR</span><span class="p">(</span><span class="n">charger_class</span><span class="p">));</span><span class="w"></span>
<span class="w">		</span><span class="k">return</span><span class="w"> </span><span class="n">PTR_ERR</span><span class="p">(</span><span class="n">charger_class</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>
<span class="w">	</span><span class="n">charger_class</span><span class="o">-&gt;</span><span class="n">dev_groups</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">charger_groups</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">subsys_initcall</span><span class="p">(</span><span class="n">charger_class_init</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<ul class="simple">
<li><p>pax_charger调用，首先线程会判断primary_chg有没有注册，注册了才会跑线程，不然一直阻塞：</p></li>
</ul>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">charger_device</span><span class="w"> </span><span class="o">*</span><span class="n">get_charger_by_name</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">name</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="k">struct</span><span class="w"> </span><span class="nc">device</span><span class="w"> </span><span class="o">*</span><span class="n">dev</span><span class="p">;</span><span class="w"></span>

<span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">name</span><span class="p">)</span><span class="w"></span>
<span class="w">		</span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">charger_device</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">dev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">class_find_device</span><span class="p">(</span><span class="n">charger_class</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"></span>
<span class="w">				</span><span class="n">charger_match_dev_by_name</span><span class="p">);</span><span class="w"></span>

<span class="w">	</span><span class="k">return</span><span class="w"> </span><span class="n">dev</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">to_charger_device</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>

<span class="p">}</span><span class="w"></span>
<span class="k">static</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">charger_init_algo</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">pax_charger</span><span class="w"> </span><span class="o">*</span><span class="n">info</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">chg1_dev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_charger_by_name</span><span class="p">(</span><span class="s">&quot;primary_chg&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">chg1_dev</span><span class="p">)</span><span class="w"></span>
<span class="w">		</span><span class="n">chr_err</span><span class="p">(</span><span class="s">&quot;Found primary charger</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="n">chr_err</span><span class="p">(</span><span class="s">&quot;*** Error : can&#39;t find primary charger ***</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>

<span class="w">	</span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">charger_routine_thread</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">arg</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="k">struct</span><span class="w"> </span><span class="nc">pax_charger</span><span class="w"> </span><span class="o">*</span><span class="n">info</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">arg</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">flags</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="k">static</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">is_module_init_done</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="kt">bool</span><span class="w"> </span><span class="n">is_charger_on</span><span class="p">;</span><span class="w"></span>

<span class="w">	</span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="n">wait_event</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">wait_que</span><span class="p">,</span><span class="w"></span>
<span class="w">			</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">charger_thread_timeout</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">true</span><span class="p">));</span><span class="w"></span>

<span class="w">		</span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">is_module_init_done</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">false</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">			</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">charger_init_algo</span><span class="p">(</span><span class="n">info</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">true</span><span class="p">)</span><span class="w"></span>
<span class="w">				</span><span class="n">is_module_init_done</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="w">			</span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">				</span><span class="n">chr_err</span><span class="p">(</span><span class="s">&quot;charger_init fail</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">				</span><span class="n">msleep</span><span class="p">(</span><span class="mi">5000</span><span class="p">);</span><span class="w"></span>
<span class="w">			</span><span class="p">}</span><span class="w"></span>
<span class="w">		</span><span class="p">}</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<ul class="simple">
<li><p>调用历程，直接调用已注册charger_dev的ops函数：</p></li>
</ul>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="n">pax_charger</span><span class="p">.</span><span class="n">c</span><span class="w"></span>
<span class="k">static</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">pax_is_charger_on</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">pax_charger</span><span class="w"> </span><span class="o">*</span><span class="n">info</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="kt">int</span><span class="w"> </span><span class="n">chr_type</span><span class="p">;</span><span class="w"></span>

<span class="w">	</span><span class="n">chr_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pax_charger_dev_get_charger_type</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">chg1_dev</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">pax_charger_class</span><span class="p">.</span><span class="n">c</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">pax_charger_dev_get_charger_type</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">charger_device</span><span class="w"> </span><span class="o">*</span><span class="n">charger_dev</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">charger_dev</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">charger_dev</span><span class="o">-&gt;</span><span class="n">ops</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"></span>
<span class="w">					   </span><span class="n">charger_dev</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">get_charger_type</span><span class="p">)</span><span class="w"></span>
<span class="w">		</span><span class="k">return</span><span class="w"> </span><span class="n">charger_dev</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">get_charger_type</span><span class="p">(</span><span class="n">charger_dev</span><span class="p">);</span><span class="w"></span>

<span class="w">	</span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="n">ENOTSUPP</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">pax_charger_dev_get_charger_type</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="id4">
<h1>底座充电功能开发<a class="headerlink" href="#id4" title="Permalink to this heading"></a></h1>
<ul class="simple">
<li><p>硬件信息
<img alt="0017_0004.png" src="../../../_images/0017_0004.png" />
<img alt="0017_0005.png" src="../../../_images/0017_0005.png" /></p></li>
</ul>
</section>
<section id="id5">
<h1>问题点<a class="headerlink" href="#id5" title="Permalink to this heading"></a></h1>
<section id="bc1-2">
<h2>bc1.2轮询方案<a class="headerlink" href="#bc1-2" title="Permalink to this heading"></a></h2>
<p>我们目前需要等待usb先做完bc1.2，才开始执行充电，目前采用timer轮询的方案，如下：</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span>
static void pax_wait_bc12_start_timer(void)
{
	struct timespec time, time_now;
	ktime_t ktime;
	int ret = 0;

	/* If the timer was already set, cancel it */
	ret = alarm_try_to_cancel(&amp;g_info-&gt;wait_bc12_timer);

	get_monotonic_boottime(&amp;time_now);
	time.tv_sec = 0;
	time.tv_nsec = CHR_BC12_POLL_INTERVAL*1000*1000;
	g_info-&gt;waitbc12_endtime = timespec_add(time_now, time);
	ktime = ktime_set(g_info-&gt;endtime.tv_sec, g_info-&gt;waitbc12_endtime.tv_nsec);

	pr_err(&quot;%s: alarm timer start:%d, %ld %ld\n&quot;, __func__, ret,
		g_info-&gt;waitbc12_endtime.tv_sec, g_info-&gt;waitbc12_endtime.tv_nsec);
	alarm_start(&amp;g_info-&gt;wait_bc12_timer, ktime);
}

static enum alarmtimer_restart
	pax_wait_bc12_alarm_timer_func(struct alarm *alarm, ktime_t now)
{
	uint8_t type = TYPEC_UNATTACHED;
	type = g_info-&gt;typec_state;

	g_info-&gt;chr_type = pax_charger_dev_get_charger_type(g_info-&gt;chg1_dev);

	pr_err(&quot;111type=%d, chg_type=%d, count=%d\n&quot;, type,
		g_info-&gt;chr_type, g_info-&gt;wait_bc12_count);

	if (!g_info-&gt;attach)
		goto out;

	if (g_info-&gt;chr_type != POWER_SUPPLY_TYPE_UNKNOWN ||
		g_info-&gt;wait_bc12_count &gt;= 50) {
		g_info-&gt;wait_bc12_count = 0;
		/* start charging after getting the charging type */
		_wake_up_charger(g_info);
		pr_err(&quot;get charger type OK\n&quot;);
	} else {
		pr_err(&quot;restart pax_wait_bc12_alarm_timer_func\n&quot;);
		g_info-&gt;wait_bc12_count++;
		pax_wait_bc12_start_timer();
	}
out:
	pr_err(&quot;device check bc12 fail!\n&quot;);


	return ALARMTIMER_NORESTART;
}

static void pax_charger_init_timer(struct pax_charger *info)
{
	alarm_init(&amp;info-&gt;charger_timer, ALARM_BOOTTIME,
			pax_charger_alarm_timer_func);
	pax_charger_start_timer(info);

	alarm_init(&amp;info-&gt;wait_bc12_timer, ALARM_BOOTTIME,
	pax_wait_bc12_alarm_timer_func); //初始化timer


#ifdef CONFIG_PM
	if (register_pm_notifier(&amp;info-&gt;pm_notifier))
		chr_err(&quot;%s: register pm failed\n&quot;, __func__);
#endif /* CONFIG_PM */
}

在这里调用：
void handle_typec_attach_dettach(bool en)
{
	union power_supply_propval val;

	chr_err(&quot;%s: ++ en:%d g_info-&gt;sink_mv_new = %d\n&quot;, __func__,en,g_info-&gt;sink_mv_new);
	mutex_lock(&amp;g_info-&gt;attach_lock);
	/* The thread notifies the pax charger that the device is connected */
	g_info-&gt;attach = en;
	if (en) {
		/* turn on the timer to poll the charging type when the device is connected */
		pax_wait_bc12_start_timer();
	}
	else {
		/* set prop unknown after device is disconnected */
		val.intval = POWER_SUPPLY_USB_TYPE_UNKNOWN;
		power_supply_set_property(g_info-&gt;usb_psy, POWER_SUPPLY_PROP_REAL_TYPE,
								&amp;val);
	}
	mutex_unlock(&amp;g_info-&gt;attach_lock);
}


typec发送通知：
	case TCP_NOTIFY_TYPEC_STATE:
		old_state = noti-&gt;typec_state.old_state;
		new_state = noti-&gt;typec_state.new_state;
		if (old_state == TYPEC_UNATTACHED &amp;&amp;
		    (new_state == TYPEC_ATTACHED_SNK ||
		     new_state == TYPEC_ATTACHED_NORP_SRC ||
		     new_state == TYPEC_ATTACHED_CUSTOM_SRC ||
		     new_state == TYPEC_ATTACHED_DBGACC_SNK)) {
			dev_err(rpmd-&gt;dev,
				 &quot;%s Charger plug in, polarity = %d\n&quot;,
				 __func__, noti-&gt;typec_state.polarity);
			/*
			 * start charger type detection,
			 * and enable device connection
			 */
			cancel_delayed_work_sync(&amp;rpmd-&gt;usb_dwork);
			rpmd-&gt;usb_dr = DR_DEVICE;
			rpmd-&gt;usb_type_polling_cnt = 0;
			schedule_delayed_work(&amp;rpmd-&gt;usb_dwork,
					      msecs_to_jiffies(
					      USB_TYPE_POLLING_INTERVAL));
			typec_set_data_role(rpmd-&gt;typec_port, TYPEC_DEVICE);
			typec_set_pwr_role(rpmd-&gt;typec_port, TYPEC_SINK);
			typec_set_pwr_opmode(rpmd-&gt;typec_port,
					     noti-&gt;typec_state.rp_level -
					     TYPEC_CC_VOLT_SNK_DFT);
			typec_set_vconn_role(rpmd-&gt;typec_port, TYPEC_SINK);
			set_charger_plug_status(1);
		}
</pre></div>
</div>
<p>发现timer需要先轮询跑完，再跑<code class="docutils literal notranslate"><span class="pre">usb_dwork</span></code>发送通知给usb作切换，就没作用，需要换成dwork形式进行轮询：</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">pax_wait_bc12_work</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">work_struct</span><span class="w"> </span><span class="o">*</span><span class="n">work</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>

<span class="w">	</span><span class="n">g_info</span><span class="o">-&gt;</span><span class="n">chr_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pax_charger_dev_get_charger_type</span><span class="p">(</span><span class="n">g_info</span><span class="o">-&gt;</span><span class="n">chg1_dev</span><span class="p">);</span><span class="w"></span>

<span class="w">	</span><span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;chg_type=%d, count=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">		</span><span class="n">g_info</span><span class="o">-&gt;</span><span class="n">chr_type</span><span class="p">,</span><span class="w"> </span><span class="n">g_info</span><span class="o">-&gt;</span><span class="n">wait_bc12_count</span><span class="p">);</span><span class="w"></span>

<span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">g_info</span><span class="o">-&gt;</span><span class="n">attach</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="n">cancel_delayed_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">g_info</span><span class="o">-&gt;</span><span class="n">wait_bc12_dwork</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>

<span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">g_info</span><span class="o">-&gt;</span><span class="n">chr_type</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">POWER_SUPPLY_TYPE_UNKNOWN</span><span class="w"> </span><span class="o">||</span><span class="w"></span>
<span class="w">		</span><span class="n">g_info</span><span class="o">-&gt;</span><span class="n">wait_bc12_count</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">50</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="n">g_info</span><span class="o">-&gt;</span><span class="n">wait_bc12_count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">		</span><span class="cm">/* start charging after getting the charging type */</span><span class="w"></span>
<span class="w">		</span><span class="n">_wake_up_charger</span><span class="p">(</span><span class="n">g_info</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;get charger type OK</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;restart pax_wait_bc12 dwork</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="n">g_info</span><span class="o">-&gt;</span><span class="n">wait_bc12_count</span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="w">		</span><span class="n">cancel_delayed_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">g_info</span><span class="o">-&gt;</span><span class="n">wait_bc12_dwork</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="n">schedule_delayed_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">g_info</span><span class="o">-&gt;</span><span class="n">wait_bc12_dwork</span><span class="p">,</span><span class="w"> </span><span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">CHR_BC12_POLL_INTERVAL</span><span class="p">));</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">handle_typec_attach_dettach</span><span class="p">(</span><span class="kt">bool</span><span class="w"> </span><span class="n">en</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="k">union</span><span class="w"> </span><span class="nc">power_supply_propval</span><span class="w"> </span><span class="n">val</span><span class="p">;</span><span class="w"></span>

<span class="w">	</span><span class="n">chr_err</span><span class="p">(</span><span class="s">&quot;%s: ++ en:%d g_info-&gt;sink_mv_new = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">__func__</span><span class="p">,</span><span class="n">en</span><span class="p">,</span><span class="n">g_info</span><span class="o">-&gt;</span><span class="n">sink_mv_new</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">g_info</span><span class="o">-&gt;</span><span class="n">attach_lock</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="cm">/* The thread notifies the pax charger that the device is connected */</span><span class="w"></span>
<span class="w">	</span><span class="n">g_info</span><span class="o">-&gt;</span><span class="n">attach</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">en</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">en</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="cm">/* turn on the timer to poll the charging type when the device is connected */</span><span class="w"></span>
<span class="w">		</span><span class="n">schedule_delayed_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">g_info</span><span class="o">-&gt;</span><span class="n">wait_bc12_dwork</span><span class="p">,</span><span class="w"> </span><span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">CHR_BC12_POLL_INTERVAL</span><span class="p">));</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>
<span class="w">	</span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="cm">/* set prop unknown after device is disconnected */</span><span class="w"></span>
<span class="w">		</span><span class="n">val</span><span class="p">.</span><span class="n">intval</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">POWER_SUPPLY_USB_TYPE_UNKNOWN</span><span class="p">;</span><span class="w"></span>
<span class="w">		</span><span class="n">power_supply_set_property</span><span class="p">(</span><span class="n">g_info</span><span class="o">-&gt;</span><span class="n">usb_psy</span><span class="p">,</span><span class="w"> </span><span class="n">POWER_SUPPLY_PROP_REAL_TYPE</span><span class="p">,</span><span class="w"></span>
<span class="w">								</span><span class="o">&amp;</span><span class="n">val</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>
<span class="w">	</span><span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">g_info</span><span class="o">-&gt;</span><span class="n">attach_lock</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>打印如下,可以看到轮询了5次，也就是250ms才得到充电类型：</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span>[  859.346234] pax-pd-manager soc:pax_pd_manager: pd_tcp_notifier_call event = 10
[  859.364617] pax-pd-manager soc:pax_pd_manager: pd_tcp_notifier_call sink vbus 5000mV 100mA type(0x01)
[  859.377953] pax-pd-manager soc:pax_pd_manager: pd_tcp_notifier_call event = 14
[  859.385984] pax-pd-manager soc:pax_pd_manager: pd_tcp_notifier_call Charger plug in, polarity = 0
[  859.395758] plug status: 1
[  859.400562] init: Control message: Could not find &#39;android.hardware.soundtrigger@2.0::ISoundTriggerHw/default&#39; for ctl.interface_start from pid: 407 (/system/bin/hwservicemanager)
[  859.417091] pax-pd-manager soc:pax_pd_manager: usb_dwork_handler Device
[  859.423999] extcon extcon2: extcon_set_state_sync id = 2 state = 0
[  859.430939] extcon extcon2: extcon_set_state_sync state 1
[  859.437289] extcon extcon2: extcon_set_state_sync id = 1 state = 1
[  859.444120] extcon extcon2: extcon_set_state_sync state 1
[  859.449662] extcon extcon2: extcon_sync state 1
[  859.454407] extcon extcon2: extcon_sync state 2 index = 0
[  859.459955] extcon extcon2: extcon_sync state 3
[  859.464821] msm-qusb-phy 1613000.qusb: Got VBUS notification: 1
[  859.470872] extcon extcon2: name_show = NAME=soc:pax_pd_manager
[  859.476819] extcon extcon2: state_show = STATE=USB=1
[  859.476819] USB-HOST=0
[  859.488540] chg_type=0, count=0
[  859.491710] restart pax_wait_bc12 dwork
[  859.495755] msm-qusb-phy 1613000.qusb: state: 0
[  859.500526] msm-qusb-phy 1613000.qusb: qusb_phy_enable_power turn on regulators
[  859.508491] msm-qusb-phy 1613000.qusb: min_vol:925000 max_vol:970000
[  859.520947] msm-qusb-phy 1613000.qusb: qusb_phy_enable_clocks(): on:1
[  859.527608] msm-qusb-phy 1613000.qusb: state: 1
[  859.548206] chg_type=0, count=1
[  859.551367] restart pax_wait_bc12 dwork
[  859.584748] msm-qusb-phy 1613000.qusb: state: 2
[  859.589466] msm-qusb-phy 1613000.qusb: state: 1 reg: 0x0
[  859.595064] msm-qusb-phy 1613000.qusb: state: 2
[  859.608212] chg_type=0, count=2
[  859.614515] restart pax_wait_bc12 dwork
[  859.668206] chg_type=0, count=3
[  859.671392] restart pax_wait_bc12 dwork
[  859.696608] msm-qusb-phy 1613000.qusb: state: 3
[  859.701468] msm-qusb-phy 1613000.qusb: state: 2 reg: 0x0
[  859.711492] msm-qusb-phy 1613000.qusb: qusb_phy_enable_clocks(): on:0
[  859.718749] msm-qusb-phy 1613000.qusb: qusb_phy_enable_power turn off regulators
[  859.727840] chg_type=0, count=4
[  859.732692] restart pax_wait_bc12 dwork
[  859.736817] msm-qusb-phy 1613000.qusb: min_vol:0 max_vol:970000
[  859.743300] msm-qusb-phy 1613000.qusb: QUSB PHY&#39;s regulators are turned OFF.
[  859.750898] msm-qusb-phy 1613000.qusb: Notify charger type: 4
[  859.756872] mp2721 0-003f: mp2721_set_property() set charge_type:4, ret:0
[  859.763816] msm-qusb-phy 1613000.qusb: Notify event: 1 for extcon_id: 1
[  859.763828] extcon extcon3: extcon_set_state_sync id = 1 state = 1
[  859.776918] extcon extcon3: extcon_set_state_sync state 1
[  859.782469] extcon extcon3: extcon_sync state 1
[  859.787595] extcon extcon3: extcon_sync state 2 index = 0
[  859.793356] extcon extcon3: extcon_sync state 3
[  859.798396] msm-dwc3 4e00000.ssusb: vbus:1 event received
[  859.803982] msm-dwc3 4e00000.ssusb: edev:1613000.qusb
[  859.809457] extcon extcon3: name_show = NAME=1613000.qusb
[  859.810420] msm-dwc3 4e00000.ssusb: dwc3_resume_work: dwc3 resume work
[  859.814892] extcon extcon3: state_show = STATE=USB=1
[  859.814892] USB-HOST=0
[  859.815757] msm-dwc3 4e00000.ssusb: XCVR: ID set
[  859.820883] chg_type=4, count=5
[  859.820919] get charger type OK
[  859.820932] msm-qusb-phy 1613000.qusb: state: 5
[  859.829601] pax_is_charger_on chr_type = 4
</pre></div>
</div>
<p>貌似这样做会阻塞typec通知，快速拔插会造成死机。</p>
</section>
<section id="charger-routine-threadmsleep">
<h2>charger_routine_thread不能加msleep<a class="headerlink" href="#charger-routine-threadmsleep" title="Permalink to this heading"></a></h2>
<p>参考：</p>
<ul class="simple">
<li><p><a class="reference external" href="https://blog.csdn.net/subfate/article/details/54380164">Linux内核小笔记：spin_lock锁内不能使用sleep休眠</a></p></li>
</ul>
<p>首先，执行了sleep，就可能切换到其它进程，此时，并没有调用spin_unlock释放锁。当另外的进程(线程)再次调用同一驱动时，需要获取相同的spin lock，由于之前并没有释放锁，于是就出现死锁了。</p>
<p>鉴于此，只能放弃msleep的做法，而使用循环达到延时的目标。</p>
</section>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, wugn.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
  

<script charset="UTF-8" id="LA_COLLECT" src="//sdk.51.la/js-sdk-pro.min.js"></script>
<script>LA.init({id: "JjOE14XScyd75b2C",ck: "JjOE14XScyd75b2C"})</script>

<br/>
<script id="LA-DATA-WIDGET" crossorigin="anonymous" charset="UTF-8" src="https://v6-widget.51.la/v6/JjOE14XScyd75b2C/quote.js?theme=0&f=12&display=1,0,0,0,0,0,1,1"></script>



</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>