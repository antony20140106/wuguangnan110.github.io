<!DOCTYPE html>
<html class="writer-html5" lang="zh-CN" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>wugn</title>

      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/default.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/translations.js"></script>
        <script src="../../../_static/js/baidutongji.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="索引" href="../../../genindex.html" />
    <link rel="search" title="搜索" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../index.html" class="icon icon-home"> wugn_note
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="在文档中搜索" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <!-- Local TOC -->
              <div class="local-toc"><ul>
<li><a class="reference internal" href="#">README</a><ul>
<li><a class="reference internal" href="#id1">参考</a></li>
<li><a class="reference internal" href="#id2">概述</a></li>
<li><a class="reference internal" href="#iddig-pd-irq">IDDIG PD_IRQ代码分析</a></li>
<li><a class="reference internal" href="#debug">debug开关</a></li>
<li><a class="reference internal" href="#type-c-tcp-notify-typec-state">type-c TCP_NOTIFY_TYPEC_STATE事件处理</a><ul>
<li><a class="reference internal" href="#id3">type-c TCP_NOTIFY_TYPEC_STATE事件监听</a></li>
<li><a class="reference internal" href="#usb">剖析usb插入拔出事件操作</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">wugn_note</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs"> 
<li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
<li>README</li>
<li style="float: right;margin-left: 10px;"><a href="javascript:history.forward()">Forward</a></li>
<li style="float: right;margin-left: 10px;"><a href="javascript:history.back()">Go Back</a> | </li>
<li style="float: right;margin-left: 10px;"><a href="/index.html">Home</a> | </li>

      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="readme">
<h1>README<a class="headerlink" href="#readme" title="此标题的永久链接"></a></h1>
<p>mt6762 otg检测过程</p>
<section id="id1">
<h2>参考<a class="headerlink" href="#id1" title="此标题的永久链接"></a></h2>
<p><a class="reference external" href="https://blog.csdn.net/weixin_36044869/article/details/104589360">插otg的识别过程</a></p>
</section>
<section id="id2">
<h2>概述<a class="headerlink" href="#id2" title="此标题的永久链接"></a></h2>
<p><img alt="0004_0000.png" src="../../../_images/0004_0000.png" /></p>
<p>上图IDDIG引脚之前误以为是OTG的ID脚，发现是PD的中断，主要功能如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">The</span> <span class="n">TCPC</span> <span class="n">has</span> <span class="n">an</span> <span class="nb">open</span><span class="o">-</span><span class="n">drain</span> <span class="n">output</span><span class="p">,</span> <span class="n">active</span><span class="o">-</span><span class="n">low</span> <span class="n">PD_IRQB</span> <span class="n">pin</span><span class="o">.</span> <span class="n">This</span> <span class="n">pin</span> <span class="ow">is</span> <span class="n">used</span> <span class="n">to</span> <span class="n">indicate</span> 
<span class="n">change</span> <span class="n">of</span> <span class="n">state</span><span class="p">,</span> <span class="n">where</span> <span class="n">the</span> <span class="n">PD_IRQB</span> <span class="n">pin</span> <span class="ow">is</span> <span class="n">asserted</span> <span class="n">when</span> <span class="nb">any</span> <span class="n">Alert</span> <span class="n">Bits</span> <span class="n">are</span> <span class="nb">set</span>
</pre></div>
</div>
<p>原理分析：OTG的识别有两种方式，一种是靠的是ID引脚，当OTG设备插入机器时，会自动将usb的ID pin引脚拉低，从而会触发中断，进而识别出有OTG设备插入。第二种是靠CC脚电平变化判断，目前mt6762平台采用的是第二种，第一种参考上面的链接。</p>
<p>补充1：</p>
<p>usb id pin一般为1.8v，默认可以连接电脑usb或adb，即机器默认做从设备device。
而usb id pin拉低到0v后，将触发usb切换为host模式，即可以连接otg设备。</p>
</section>
<section id="iddig-pd-irq">
<h2>IDDIG PD_IRQ代码分析<a class="headerlink" href="#iddig-pd-irq" title="此标题的永久链接"></a></h2>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">mt6765.dts</span></code>：</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>        这个没用，所以参考文章也是没用的
        otg_iddig: otg_iddig{
                compatible = &quot;mediatek,usb_iddig_bi_eint&quot;;
        };

&amp;mt6370_typec {
        mt6370pd,intr_gpio_num = &lt;9&gt;; /* direct defined GPIO num */
        mt6370pd,intr_gpio = &lt;&amp;pio 9 0x0&gt;;
};
</pre></div>
</div>
<ul class="simple">
<li><p>剑锋分析</p></li>
</ul>
<p><img alt="0004_0001.png" src="../../../_images/0004_0001.png" /></p>
</section>
<section id="debug">
<h2>debug开关<a class="headerlink" href="#debug" title="此标题的永久链接"></a></h2>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="n">tcpci_core</span><span class="p">.</span><span class="n">h</span><span class="o">:</span><span class="w"></span>
<span class="cm">/* The switch of log message */</span><span class="w"></span>
<span class="cp">#define TYPEC_INFO_ENABLE	1</span>
<span class="cp">#define TYPEC_INFO2_ENABLE	1</span>
<span class="cp">#define PE_EVENT_DBG_ENABLE	1</span>
<span class="cp">#define PE_STATE_INFO_ENABLE	1</span>
<span class="cp">#define TCPC_INFO_ENABLE	1</span>
<span class="cp">#define TCPC_TIMER_DBG_EN	0</span>
<span class="cp">#define TCPC_TIMER_INFO_EN	0</span>
<span class="cp">#define PE_INFO_ENABLE		1</span>
<span class="cp">#define TCPC_DBG_ENABLE		0</span>
<span class="cp">#define TCPC_DBG2_ENABLE	0</span>
<span class="cp">#define DPM_INFO_ENABLE		1</span>
<span class="cp">#define DPM_INFO2_ENABLE	1</span>
<span class="cp">#define DPM_DBG_ENABLE		0</span>
<span class="cp">#define PD_ERR_ENABLE		1</span>
<span class="cp">#define PE_DBG_ENABLE		1</span>
<span class="cp">#define TYPEC_DBG_ENABLE	1</span>


<span class="cp">#define DP_INFO_ENABLE		1</span>
<span class="cp">#define DP_DBG_ENABLE		1</span>

<span class="cp">#define UVDM_INFO_ENABLE		1</span>
<span class="cp">#define TCPM_DBG_ENABLE		1</span>

<span class="cp">#ifdef CONFIG_USB_PD_ALT_MODE_RTDC</span>
<span class="cp">#define DC_INFO_ENABLE			1</span>
<span class="cp">#define DC_DBG_ENABLE			1</span>
<span class="cp">#endif	</span><span class="cm">/* CONFIG_USB_PD_ALT_MODE_RTDC */</span><span class="cp"></span>
</pre></div>
</div>
</section>
<section id="type-c-tcp-notify-typec-state">
<h2>type-c TCP_NOTIFY_TYPEC_STATE事件处理<a class="headerlink" href="#type-c-tcp-notify-typec-state" title="此标题的永久链接"></a></h2>
<p>typec state所有事件如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">enum</span> <span class="n">typec_attach_type</span> <span class="p">{</span>
    <span class="n">TYPEC_UNATTACHED</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>   <span class="n">没接</span>
    <span class="n">TYPEC_ATTACHED_SNK</span><span class="p">,</span>      <span class="n">手机作为sink端</span>
    <span class="n">TYPEC_ATTACHED_SRC</span><span class="p">,</span>      <span class="n">手机作为source端</span>
    <span class="n">TYPEC_ATTACHED_AUDIO</span><span class="p">,</span>    <span class="n">手机作为audio输出</span>
    <span class="n">TYPEC_ATTACHED_DEBUG</span><span class="p">,</span>			<span class="o">/*</span> <span class="n">Rd</span><span class="p">,</span> <span class="n">Rd</span> <span class="o">*/</span>

<span class="o">/*</span> <span class="n">CONFIG_TYPEC_CAP_DBGACC_SNK</span> <span class="o">*/</span>
    <span class="n">TYPEC_ATTACHED_DBGACC_SNK</span><span class="p">,</span>		<span class="o">/*</span> <span class="n">Rp</span><span class="p">,</span> <span class="n">Rp</span> <span class="o">*/</span>

<span class="o">/*</span> <span class="n">CONFIG_TYPEC_CAP_CUSTOM_SRC</span> <span class="o">*/</span>
    <span class="n">TYPEC_ATTACHED_CUSTOM_SRC</span><span class="p">,</span>		<span class="o">/*</span> <span class="n">Same</span> <span class="n">Rp</span> <span class="o">*/</span>

<span class="o">/*</span> <span class="n">CONFIG_TYPEC_CAP_NORP_SRC</span> <span class="o">*/</span>
    <span class="n">TYPEC_ATTACHED_NORP_SRC</span><span class="p">,</span>		<span class="o">/*</span> <span class="n">No</span> <span class="n">Rp</span> <span class="o">*/</span>
<span class="p">};</span>
</pre></div>
</div>
<ul class="simple">
<li><p>CC处理线程逻辑：</p></li>
</ul>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span>* `kernel-4.19\drivers\misc\mediatek\typec\tcpc\tcpc_mt6370.c`:
  └── mt6370_i2c_probe
      └── mt6370_tcpcdev_init(chip, &amp;client-&gt;dev);
          └── chip-&gt;tcpc = tcpc_device_register(dev,desc, &amp;mt6370_tcpc_ops, chip);
              └── tcpci_timer_init(tcpc); //创建中断timer
                  ├── hrtimer_init(&amp;tcpc_dev-&gt;tcpc_timer[i],CLOCK_MONOTONIC, HRTIMER_MODE_REL); //初始化定时器
                  ├── tcpc_dev-&gt;tcpc_timer[i].function = tcpc_timer_call[i]; //注册各种timer，具体下面说明
                  └── kthread_create(tcpc_timer_thread, tcpc_dev, //创建线程
                      ├── wait_event_interruptible(tcpc_dev-&gt;timer_wait_que, //将本进程置为可中断的挂起状态
                      └── tcpc_handle_timer_triggered(tcpc_dev); //主要处理函数
                          └── tcpc_typec_handle_timeout(tcpc_dev, i);
                              └── typec_handle_debounce_timeout(tcpc_dev);
                                  ├── typec_handle_cc_changed_entry(tcpc_dev); //处理CC事件 tcpci_typec.c
                                  └── TYPEC_INFO(&quot;[CC_Change] %d/%d\r\n&quot;, typec_get_cc1(), typec_get_cc2()); //打印CC 如TCPC-TYPEC:[CC_Change] 5/0
                                      ├── if (typec_is_act_as_sink_role(tcpc_dev))
                                      │   ├── typec_cc_change_sink_entry(tcpc_dev); //处理sink入口
                                      │   │   └── typec_cc_snk_detect_entry(tcpc_dev);
                                      │   │       ├── if (tcpci_check_vbus_valid(tcpc_dev)) /* If Port Partner act as Source without VBUS, wait vSafe5V */
                                      │   │       └── typec_cc_snk_detect_vsafe5v_entry(tcpc_dev);
                                      │   │           └── typec_sink_attached_entry(tcpc_dev);
                                      │   │               └── typec_custom_src_attached_entry(tcpc_dev);
                                      │   │                   └── tcpc_dev-&gt;typec_attach_new = TYPEC_ATTACHED_SNK; //赋值新状态
                                      │   └── else typec_cc_change_source_entry(tcpc_dev); //处理source入口
                                      ├── typec_alert_attach_state_change(tcpc_dev); //tcpci_alert.c
                                      └── TYPEC_INFO(&quot;Attached-&gt; %s\r\n&quot;,typec_attach_name[tcpc_dev-&gt;typec_attach_new]);  //重要打印attach 信息，如TCPC-TYPEC:Attached-&gt; SINK
                                          └── tcpci_report_usb_port_changed(tcpc_dev); //tcpci_alert.c 主要是notify通知
                                              ├── tcpci_notify_typec_state(tcpc); //tcpci.c
                                              │   ├── tcp_noti.typec_state.polarity = tcpc-&gt;typec_polarity;  //各种状态赋值
                                              │   ├── tcp_noti.typec_state.old_state = tcpc-&gt;typec_attach_old;
                                              │   ├── tcp_noti.typec_state.new_state = tcpc-&gt;typec_attach_new;
                                              │   ├── tcp_noti.typec_state.rp_level = tcpc-&gt;typec_remote_rp_level;
                                              │   └── tcpc_check_notify_time(tcpc, &amp;tcp_noti,TCP_NOTIFY_IDX_USB, TCP_NOTIFY_TYPEC_STATE); //状态notify通知
                                              │       ├── INIT_WORK(&amp;tn_work-&gt;work, tcp_notify_func); //创建通知工作队列
                                              │       └── queue_work(tcpc-&gt;evt_wq, &amp;tn_work-&gt;work) ? 0 : -EAGAIN;  //开始工作队列
                                              │           └── srcu_notifier_call_chain(&amp;tcpc-&gt;evt_nh[type], state, tcp_noti); //重要通知到其他驱动typec状态
                                              ├── if (tcpc-&gt;typec_attach_old == TYPEC_UNATTACHED) //从TYPEC_UNATTACHED到attach
                                              └── tcpci_report_usb_port_attached(tcpc); //重要，主要是真正设置usb 状态，具体在下面解释
                                                  ├── TCPC_INFO(&quot;usb_port_attached\r\n&quot;); //打印usb_port_attached
                                                  ├── typec_set_data_role(tcpc-&gt;typec_port, TYPEC_DEVICE);//设置数据方向
                                                  ├── typec_set_pwr_role(tcpc-&gt;typec_port, TYPEC_SINK); //设置电源方向为sink
                                                  ├── typec_set_vconn_role(tcpc-&gt;typec_port, TYPEC_SINK);  //设置VCONN方向为sink
                                                  └── if (tcpc-&gt;pd_inited_flag)  //查看代码flag是1
                                                      └── pd_put_cc_attached_event(tcpc, tcpc-&gt;typec_attach_new);
                                                          ├── if (type == TYPEC_ATTACHED_SNK &amp;&amp;(rv || prop.intval == POWER_SUPPLY_USB_TYPE_UNKNOWN)) //如果usb类型还未识别，将等待bc1.2识别
                                                          └── tcpc_enable_timer(tcpc_dev, TYPEC_RT_TIMER_SINK_WAIT_BC12); //开启定时器，这里会调用定时器回调函数tcpc_timer_rt_sink_wait_bc12
                                                              ├── TCPC_TIMER_TRIGGER() //唤醒处理线程
                                                              │   └── wake_up_interruptible(&amp;tcpc_dev-&gt;timer_wait_que);	\
                                                              │       └── tcpc_timer_thread(void *param) //线程
                                                              │           └── tcpc_handle_timer_triggered(tcpc_dev);
                                                              │               └── tcpc_typec_handle_timeout(tcpc_dev, i); //和上面一样，不做分析了
                                                              └── __pd_put_cc_attached_event(tcpc_dev, type);
                                                                  └── __pd_put_event(tcpc_dev, &amp;evt, false);  // typec event事件上报
                                                                      └── wake_up_interruptible(&amp;tcpc_dev-&gt;event_loop_wait_que); //唤醒事件处理线程
                                                                          └── tcpc_event_thread(void *param)
                                                                              └── while (pd_policy_engine_run(tcpc_dev));
                                                                                  └── pd_pe_state_change(pd_port, pd_event); //这里不做深入分析了，应该是pd协议方面的事件处理
</pre></div>
</div>
<ul class="simple">
<li><p>创建的timer如下，各种状态改变的：</p></li>
</ul>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span>static tcpc_hrtimer_call tcpc_timer_call[PD_TIMER_NR] = {
#ifdef CONFIG_USB_POWER_DELIVERY
    tcpc_timer_discover_id,
    tcpc_timer_bist_cont_mode,
    tcpc_timer_hard_reset_complete,
    tcpc_timer_no_response,
    tcpc_timer_ps_hard_reset,
    tcpc_timer_ps_source_off,
    tcpc_timer_ps_source_on,
    tcpc_timer_ps_transition,
    tcpc_timer_sender_response,
    tcpc_timer_sink_activity,
    tcpc_timer_sink_request,
    tcpc_timer_sink_wait_cap,
    tcpc_timer_source_activity,
    tcpc_timer_source_capability,
    tcpc_timer_source_start,
    tcpc_timer_vconn_on,
#ifdef CONFIG_USB_PD_VCONN_STABLE_DELAY
    tcpc_timer_vconn_stable,
#endif	/* CONFIG_USB_PD_VCONN_STABLE_DELAY */
    tcpc_timer_vdm_mode_entry,
    tcpc_timer_vdm_mode_exit,
    tcpc_timer_vdm_response,
    tcpc_timer_source_transition,
    tcpc_timer_src_recover,
#ifdef CONFIG_USB_PD_REV30
    tcpc_timer_ck_no_support,
#ifdef CONFIG_USB_PD_REV30_COLLISION_AVOID
    tcpc_timer_sink_tx,
#endif	/* CONFIG_USB_PD_REV30_COLLISION_AVOID */
#ifdef CONFIG_USB_PD_REV30_PPS_SOURCE
    tcpc_timer_source_pps,
#endif	/* CONFIG_USB_PD_REV30_PPS_SOURCE */
#endif	/* CONFIG_USB_PD_REV30 */

/* PD_TIMER (out of spec )*/
    tcpc_timer_vsafe0v_delay,
    tcpc_timer_vsafe0v_tout,
    tcpc_timer_pd_discard,
    tcpc_timer_vbus_stable,
    tcpc_timer_vbus_present,
    tcpc_timer_uvdm_response,
    tcpc_timer_dfp_flow_delay,
    tcpc_timer_ufp_flow_delay,
    tcpc_timer_vconn_ready,
    tcpc_timer_vdm_postpone,

#ifdef CONFIG_USB_PD_REV30
#ifdef CONFIG_USB_PD_REV30_COLLISION_AVOID
    tcpc_timer_deferred_evt,
#endif	/* CONFIG_USB_PD_REV30_COLLISION_AVOID */
#ifdef CONFIG_USB_PD_REV30_SNK_FLOW_DELAY_STARTUP
    tcpc_timer_snk_flow_delay,
#endif	/* CONFIG_USB_PD_REV30_SNK_FLOW_DELAY_STARTUP */
#endif	/* CONFIG_USB_PD_REV30 */

    tcpc_timer_pe_idle_tout,
#endif /* CONFIG_USB_POWER_DELIVERY */

/* TYPEC_RT_TIMER (out of spec )*/
    tcpc_timer_rt_vsafe0v_delay,
    tcpc_timer_rt_vsafe0v_tout,
    tcpc_timer_rt_role_swap_start,
    tcpc_timer_rt_role_swap_stop,
    tcpc_timer_rt_legacy,
    tcpc_timer_rt_not_legacy,
    tcpc_timer_rt_legacy_stable,
    tcpc_timer_rt_legacy_recycle,
    tcpc_timer_rt_auto_discharge,
    tcpc_timer_rt_low_power_mode,
#ifdef CONFIG_USB_POWER_DELIVERY
    tcpc_timer_rt_pe_idle,
#ifdef CONFIG_TYPEC_WAIT_BC12
    tcpc_timer_rt_sink_wait_bc12,
#endif /* CONFIG_TYPEC_WAIT_BC12 */
#endif	/* CONFIG_USB_POWER_DELIVERY */
    tcpc_timer_error_recovery,
/* TYPEC-TRY-TIMER */
    tcpc_timer_try_drp_try,
    tcpc_timer_try_drp_trywait,
/* TYPEC-DEBOUNCE-TIMER */
    tcpc_timer_ccdebounce,
    tcpc_timer_pddebounce,
#ifdef CONFIG_COMPATIBLE_APPLE_TA
    tcpc_timer_apple_cc_open,
#endif /* CONFIG_COMPATIBLE_APPLE_TA */
    tcpc_timer_tryccdebounce,
    tcpc_timer_srcdisconnect,
    tcpc_timer_drp_src_toggle,
#ifdef CONFIG_TYPEC_CAP_NORP_SRC
    tcpc_timer_norp_src,
#endif
};

* 正式设置usb sink source状态：
static inline int tcpci_report_usb_port_attached(struct tcpc_device *tcpc)
{
    TCPC_INFO(&quot;usb_port_attached\r\n&quot;);

    switch (tcpc-&gt;typec_attach_new) {
    case TYPEC_ATTACHED_SNK:
    case TYPEC_ATTACHED_CUSTOM_SRC:
    case TYPEC_ATTACHED_NORP_SRC:
        tcpc-&gt;dual_role_pr = DUAL_ROLE_PROP_PR_SNK;
        tcpc-&gt;dual_role_dr = DUAL_ROLE_PROP_DR_DEVICE;
        tcpc-&gt;dual_role_mode = DUAL_ROLE_PROP_MODE_UFP;
        tcpc-&gt;dual_role_vconn = DUAL_ROLE_PROP_VCONN_SUPPLY_NO;
        tcpc-&gt;typec_caps.type = TYPEC_PORT_SNK;
        tcpc-&gt;typec_caps.data = TYPEC_PORT_UFP;
        typec_set_data_role(tcpc-&gt;typec_port, TYPEC_DEVICE);
        typec_set_pwr_role(tcpc-&gt;typec_port, TYPEC_SINK);
        typec_set_vconn_role(tcpc-&gt;typec_port, TYPEC_SINK);
        break;
    case TYPEC_ATTACHED_SRC:
        tcpc-&gt;dual_role_pr = DUAL_ROLE_PROP_PR_SRC;
        tcpc-&gt;dual_role_dr = DUAL_ROLE_PROP_DR_HOST;
        tcpc-&gt;dual_role_mode = DUAL_ROLE_PROP_MODE_DFP;
        tcpc-&gt;dual_role_vconn = DUAL_ROLE_PROP_VCONN_SUPPLY_YES;
        tcpc-&gt;typec_caps.type = TYPEC_PORT_SRC;
        tcpc-&gt;typec_caps.data = TYPEC_PORT_DFP;
        typec_set_data_role(tcpc-&gt;typec_port, TYPEC_HOST);
        typec_set_pwr_role(tcpc-&gt;typec_port, TYPEC_SOURCE);
        typec_set_vconn_role(tcpc-&gt;typec_port, TYPEC_SOURCE);
        break;
    default:
        break;
    }
    /* set typec switch orientation */
    typec_set_orientation(tcpc-&gt;typec_port, tcpc-&gt;typec_polarity ?
            TYPEC_ORIENTATION_NORMAL : TYPEC_ORIENTATION_REVERSE);

    tcpci_set_wake_lock_pd(tcpc, true);

#ifdef CONFIG_USB_POWER_DELIVERY

#ifdef CONFIG_USB_PD_DISABLE_PE
    if (tcpc-&gt;disable_pe)
        return 0;
#endif	/* CONFIG_USB_PD_DISABLE_PE */

    /* MTK Only */
    if (tcpc-&gt;pd_inited_flag)
        pd_put_cc_attached_event(tcpc, tcpc-&gt;typec_attach_new);
#endif /* CONFIG_USB_POWER_DLEIVERY */

    return 0;
}

</pre></div>
</div>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">tcpci_notify_typec_state</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">tcpc_device</span><span class="w"> </span><span class="o">*</span><span class="n">tcpc</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">tcp_notify</span><span class="w"> </span><span class="n">tcp_noti</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">ret</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">//以下是状态赋值</span>
<span class="w">    </span><span class="n">tcp_noti</span><span class="p">.</span><span class="n">typec_state</span><span class="p">.</span><span class="n">polarity</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tcpc</span><span class="o">-&gt;</span><span class="n">typec_polarity</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">tcp_noti</span><span class="p">.</span><span class="n">typec_state</span><span class="p">.</span><span class="n">old_state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tcpc</span><span class="o">-&gt;</span><span class="n">typec_attach_old</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">tcp_noti</span><span class="p">.</span><span class="n">typec_state</span><span class="p">.</span><span class="n">new_state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tcpc</span><span class="o">-&gt;</span><span class="n">typec_attach_new</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">tcp_noti</span><span class="p">.</span><span class="n">typec_state</span><span class="p">.</span><span class="n">rp_level</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tcpc</span><span class="o">-&gt;</span><span class="n">typec_remote_rp_level</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">//状态上报</span>
<span class="w">    </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tcpc_check_notify_time</span><span class="p">(</span><span class="n">tcpc</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">tcp_noti</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">TCP_NOTIFY_IDX_USB</span><span class="p">,</span><span class="w"> </span><span class="n">TCP_NOTIFY_TYPEC_STATE</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">ret</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<ul class="simple">
<li><p>notify通知函数剖析，实际上报函数为<code class="docutils literal notranslate"><span class="pre">srcu_notifier_call_chain</span></code>：</p></li>
<li><p>tcpc_check_notify_time(tcpc, &amp;tcp_noti,TCP_NOTIFY_IDX_USB,TCP_NOTIFY_TYPEC_STATE);</p>
<ul>
<li><p>INIT_WORK(&amp;tn_work-&gt;work, tcp_notify_func);</p></li>
<li><p>queue_work(tcpc-&gt;evt_wq, &amp;tn_work-&gt;work)</p></li>
</ul>
</li>
</ul>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">tcp_notify_func</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">work_struct</span><span class="w"> </span><span class="o">*</span><span class="n">work</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">tcp_notify_work</span><span class="w"> </span><span class="o">*</span><span class="n">tn_work</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">        </span><span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">tcp_notify_work</span><span class="p">,</span><span class="w"> </span><span class="n">work</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">tcpc_device</span><span class="w"> </span><span class="o">*</span><span class="n">tcpc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tn_work</span><span class="o">-&gt;</span><span class="n">tcpc</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">tcp_notify</span><span class="w"> </span><span class="o">*</span><span class="n">tcp_noti</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">tn_work</span><span class="o">-&gt;</span><span class="n">tcp_noti</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tn_work</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tn_work</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">;</span><span class="w"></span>
<span class="cp">#ifdef CONFIG_PD_BEGUG_ON</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">timeval</span><span class="w"> </span><span class="n">begin</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">timeval</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">do_gettimeofday</span><span class="p">(</span><span class="o">&amp;</span><span class="n">begin</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">srcu_notifier_call_chain</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tcpc</span><span class="o">-&gt;</span><span class="n">evt_nh</span><span class="p">[</span><span class="n">type</span><span class="p">],</span><span class="w"> </span><span class="n">state</span><span class="p">,</span><span class="w"> </span><span class="n">tcp_noti</span><span class="p">);</span><span class="w"> </span><span class="c1">//SRCU 通知链,可阻塞</span>
<span class="w">    </span><span class="n">do_gettimeofday</span><span class="p">(</span><span class="o">&amp;</span><span class="n">end</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">timeval</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">timeval_to_ns</span><span class="p">(</span><span class="n">end</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">timeval_to_ns</span><span class="p">(</span><span class="n">begin</span><span class="p">))</span><span class="o">/</span><span class="mi">1000</span><span class="o">/</span><span class="mi">1000</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">PD_BUG_ON</span><span class="p">(</span><span class="n">timeval</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">TCPC_NOTIFY_OVERTIME</span><span class="p">);</span><span class="w"></span>
<span class="cp">#else</span>
<span class="w">    </span><span class="n">srcu_notifier_call_chain</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tcpc</span><span class="o">-&gt;</span><span class="n">evt_nh</span><span class="p">[</span><span class="n">type</span><span class="p">],</span><span class="w"> </span><span class="n">state</span><span class="p">,</span><span class="w"> </span><span class="n">tcp_noti</span><span class="p">);</span><span class="w"></span>
<span class="cp">#endif</span>

<span class="w">    </span><span class="n">kfree</span><span class="p">(</span><span class="n">tn_work</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<section id="id3">
<h3>type-c TCP_NOTIFY_TYPEC_STATE事件监听<a class="headerlink" href="#id3" title="此标题的永久链接"></a></h3>
<ul class="simple">
<li><p>type-c事件监听，<code class="docutils literal notranslate"><span class="pre">CONFIG_MTK_USB_TYPEC</span></code>定义了，选择typec识别OTG方式，注册通知链<code class="docutils literal notranslate"><span class="pre">otg_tcp_notifier_call</span></code>：</p></li>
</ul>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="p">.</span><span class="n">config</span><span class="w"></span>
<span class="mi">1799</span><span class="o">:</span><span class="n">CONFIG_MTK_USB_TYPEC</span><span class="o">=</span><span class="n">y</span><span class="w"></span>

<span class="o">*</span><span class="w"> </span><span class="n">INIT_DELAYED_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">register_otg_work</span><span class="p">,</span><span class="w"> </span><span class="n">do_register_otg_work</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="o">*</span><span class="w"> </span><span class="n">otg_nb</span><span class="p">.</span><span class="n">notifier_call</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">otg_tcp_notifier_call</span><span class="p">;</span><span class="w"> </span>
<span class="w">  </span><span class="o">*</span><span class="w"> </span><span class="n">register_tcp_dev_notifier</span><span class="p">(</span><span class="n">otg_tcpc_dev</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">otg_nb</span><span class="p">,</span><span class="n">TCP_NOTIFY_TYPE_VBUS</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">TCP_NOTIFY_TYPE_USB</span><span class="w"> </span><span class="o">|</span><span class="n">TCP_NOTIFY_TYPE_MISC</span><span class="p">);</span><span class="c1">//注册通知链`otg_tcp_notifier_call`</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">mt_usb_otg_init</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">musb</span><span class="w"> </span><span class="o">*</span><span class="n">musb</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="cm">/* test */</span><span class="w"></span>
<span class="w">    </span><span class="n">INIT_DELAYED_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">host_plug_test_work</span><span class="p">,</span><span class="w"> </span><span class="n">do_host_plug_test_work</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">ktime_start</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ktime_get</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="cm">/* CONNECTION MANAGEMENT*/</span><span class="w"></span>
<span class="cp">#ifdef CONFIG_MTK_USB_TYPEC</span>
<span class="w">    </span><span class="n">DBG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;host controlled by TYPEC</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">typec_control</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="cp">#ifdef CONFIG_TCPC_CLASS </span><span class="c1">//跑这里</span>
<span class="w">    </span><span class="n">INIT_DELAYED_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">register_otg_work</span><span class="p">,</span><span class="w"> </span><span class="n">do_register_otg_work</span><span class="p">);</span><span class="w"></span>
<span class="cm">/* Add-BEGIN by (shanliangliang@paxsz.com), 2021/08/27 fix notifier reigister too late */</span><span class="w"></span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">    queue_delayed_work(mtk_musb-&gt;st_wq, &amp;register_otg_work, 0);</span>
<span class="cp">#else</span>
<span class="w">    </span><span class="n">schedule_delayed_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">register_otg_work</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">REGISTER_OTG_WORK_DELAY</span><span class="p">));</span><span class="w"></span>
<span class="cp">#endif</span>
<span class="cm">/* Add-END by (shanliangliang@paxsz.com), 2021/08/27 fix notifier reigister too late */</span><span class="w"></span>
<span class="w">    </span><span class="n">vbus_control</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="cp">#endif</span>
<span class="cp">#else  </span><span class="c1">//第二种iddig方式</span>
<span class="w">    </span><span class="n">DBG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;host controlled by IDDIG</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">iddig_int_init</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">vbus_control</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="cp">#endif</span>
</pre></div>
</div>
<ul class="simple">
<li><p>通知链处理typec状态，包括切换host devices处理，包括usb插入拔出处理：</p></li>
</ul>
</section>
<section id="usb">
<h3>剖析usb插入拔出事件操作<a class="headerlink" href="#usb" title="此标题的永久链接"></a></h3>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span>static int otg_tcp_notifier_call(struct notifier_block *nb,
        unsigned long event, void *data)
{
    struct tcp_notify *noti = data;

    switch (event) {
    case TCP_NOTIFY_SOURCE_VBUS:
        DBG(0, &quot;source vbus = %dmv\n&quot;, noti-&gt;vbus_state.mv);
        if (noti-&gt;vbus_state.mv)
            mt_usb_vbus_on(0);
        else
            mt_usb_vbus_off(0);
        break;
    case TCP_NOTIFY_TYPEC_STATE:
        DBG(0, &quot;TCP_NOTIFY_TYPEC_STATE, old_state=%d, new_state=%d\n&quot;,
                noti-&gt;typec_state.old_state,
                noti-&gt;typec_state.new_state);

        /* Add-BEGIN by (shanliangliang@paxsz.com), 2021/08/15 add for M8 usb otg */
        mtk_musb-&gt;typec_state = noti-&gt;typec_state.new_state;
        /* Add-END by (shanliangliang@paxsz.com), 2021/08/15 add for M8 usb otg */

        if (noti-&gt;typec_state.old_state == TYPEC_UNATTACHED &amp;&amp;
            noti-&gt;typec_state.new_state == TYPEC_ATTACHED_SRC) {
            DBG(0, &quot;OTG Plug in\n&quot;);
            mt_usb_host_connect(0);
        /* Add-BEGIN by (shanliangliang@paxsz.com), 2021/09/23 add for M8 usb otg */
        } else if (noti-&gt;typec_state.old_state == TYPEC_UNATTACHED &amp;&amp;
            noti-&gt;typec_state.new_state == TYPEC_ATTACHED_SNK) {
            mt_usb_host_disconnect(0);
            mt_usb_connect();
        /* Add-END by (shanliangliang@paxsz.com), 2021/09/23 add for M8 usb otg */
        } else if ((noti-&gt;typec_state.old_state == TYPEC_ATTACHED_SRC ||
            noti-&gt;typec_state.old_state == TYPEC_ATTACHED_SNK ||
            noti-&gt;typec_state.old_state ==
                    TYPEC_ATTACHED_NORP_SRC) &amp;&amp;
            noti-&gt;typec_state.new_state == TYPEC_UNATTACHED) {
            /* Add-BEGIN by (shanliangliang@paxsz.com), 2021/08/15 add for M8 usb otg */
                if (mtk_musb-&gt;default_mode != MUSB_HOST) {
                    if (is_host_active(mtk_musb)) {
                        DBG(0, &quot;OTG Plug out\n&quot;);
                        mt_usb_host_disconnect(0);
                    } else {
                        DBG(0, &quot;USB Plug out\n&quot;);
                        mt_usb_dev_disconnect();
                    }
                }
                else {
                    if ((noti-&gt;typec_state.old_state != TYPEC_ATTACHED_SRC) &amp;&amp; 
                            (noti-&gt;typec_state.new_state == TYPEC_UNATTACHED)) {
                        if (is_host_active(mtk_musb)) {
                            DBG(0, &quot;OTG Plug out\n&quot;);
                            mt_usb_host_disconnect(0);
                        } else {
                            DBG(0, &quot;USB Plug out\n&quot;);
                            mt_usb_dev_disconnect();
                        }
                        
                        if (mtk_musb-&gt;lcd_state != FB_BLANK_POWERDOWN) {
                            msleep(50);
                            mt_usb_host_connect(100);
                        }
                    }
                    else if ((noti-&gt;typec_state.old_state == TYPEC_ATTACHED_SRC) &amp;&amp; 
                            (noti-&gt;typec_state.new_state == TYPEC_UNATTACHED)) {
                        if (mtk_musb-&gt;lcd_state == FB_BLANK_POWERDOWN) {
                            if (is_host_active(mtk_musb)) {
                                DBG(0, &quot;OTG Plug out\n&quot;);
                                mt_usb_host_disconnect(0);
                            } else {
                                DBG(0, &quot;USB Plug out\n&quot;);
                                mt_usb_dev_disconnect();
                            }
                        }
                    }
                }

        /* Add-END by (shanliangliang@paxsz.com), 2021/08/15 add for M8 usb otg */
#ifdef CONFIG_MTK_UART_USB_SWITCH
        } else if ((noti-&gt;typec_state.new_state ==
                    TYPEC_ATTACHED_SNK ||
                noti-&gt;typec_state.new_state ==
                    TYPEC_ATTACHED_CUSTOM_SRC ||
                noti-&gt;typec_state.new_state ==
                    TYPEC_ATTACHED_NORP_SRC) &amp;&amp;
                in_uart_mode) {
            pr_info(&quot;%s USB cable plugged-in in UART mode.
                    Switch to USB mode.\n&quot;, __func__);
            usb_phy_switch_to_usb();
#endif
        }
        break;
    case TCP_NOTIFY_DR_SWAP:
        DBG(0, &quot;TCP_NOTIFY_DR_SWAP, new role=%d\n&quot;,
                noti-&gt;swap_state.new_role);
        if (is_host_active(mtk_musb) &amp;&amp;
            noti-&gt;swap_state.new_role == PD_ROLE_UFP) {
            DBG(0, &quot;switch role to device\n&quot;);
            mt_usb_host_disconnect(0);
            mt_usb_connect();
        } else if (is_peripheral_active(mtk_musb) &amp;&amp;
            noti-&gt;swap_state.new_role == PD_ROLE_DFP) {
            DBG(0, &quot;switch role to host\n&quot;);
            mt_usb_dev_disconnect();
            mt_usb_host_connect(0);
        }
        break;
    }
    return NOTIFY_OK;
}
</pre></div>
</div>
</section>
</section>
</section>


           </div>
             <div class="articleComments">
                <comments>
  <script src="https://utteranc.es/client.js"
    repo="iswbm/magic-python"
    issue-term="pathname"
    theme="github-light"
    crossorigin="anonymous"
    async>
  </script>
</comments>
             </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; 版权所有 2022, wugn.</p>
  </div>

  利用 <a href="https://www.sphinx-doc.org/">Sphinx</a> 构建，使用了 
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">主题</a>
    由 <a href="https://readthedocs.org">Read the Docs</a>开发.
  

<script charset="UTF-8" id="LA_COLLECT" src="//sdk.51.la/js-sdk-pro.min.js"></script>
<script>LA.init({id: "JoV5csIHTGhHiGQ4",ck: "JoV5csIHTGhHiGQ4"})</script>

<br/>
<script id="LA-DATA-WIDGET" crossorigin="anonymous" charset="UTF-8" src="https://v6-widget.51.la/v6/JoV5csIHTGhHiGQ4/quote.js?theme=#4C8AC2,#BB2626,#040000,#333333,#AE3535,#1690FF,14&f=14"></script>



</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>