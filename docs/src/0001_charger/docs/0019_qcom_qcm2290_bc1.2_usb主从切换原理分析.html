<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>wugn</title>

      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/default.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../index.html" class="icon icon-home"> wugn_note
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <!-- Local TOC -->
              <div class="local-toc"><ul>
<li><a class="reference internal" href="#">概述</a></li>
<li><a class="reference internal" href="#id2">参考</a></li>
<li><a class="reference internal" href="#id3">代码</a></li>
<li><a class="reference internal" href="#id4">程序流程</a></li>
<li><a class="reference internal" href="#charger-extcon">charger extcon通知原理</a><ul>
<li><a class="reference internal" href="#qusbhost-device">qusb设置host/device逻辑</a><ul>
<li><a class="reference internal" href="#pm4125extcon">pm4125初始化extcon</a></li>
<li><a class="reference internal" href="#qusb-dtsedev-pm2250-charger-usb-add-phy-dev">qusb 根据dts找到edev(pm2250_charger)，并注册到其内核通知链中(usb_add_phy_dev)</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#charger-bc1-2">charger BC1.2检测原理</a><ul>
<li><a class="reference internal" href="#qusb-port-det-w-work">qusb port_det_w.work识别流程</a></li>
<li><a class="reference internal" href="#smblite-usb">smblite usb设置充电类型接口</a></li>
</ul>
</li>
<li><a class="reference internal" href="#dw3usb">DW3驱动设置USB主从模式</a><ul>
<li><a class="reference internal" href="#resume-work">resume_work主从切换原理</a></li>
<li><a class="reference internal" href="#usb-device">USB device切换</a></li>
</ul>
</li>
<li><a class="reference internal" href="#usbpower-supply-type-unknown">拔usb时设置充电类型为POWER_SUPPLY_TYPE_UNKNOWN</a></li>
<li><a class="reference internal" href="#device">device流程实例</a></li>
<li><a class="reference internal" href="#pax-extcon">PAX extcon实例</a></li>
</ul>
</div>
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">wugn_note</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs"> 
<li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
<li>概述</li>
<li style="float: right;margin-left: 10px;"><a href="javascript:history.forward()">Forward</a></li>
<li style="float: right;margin-left: 10px;"><a href="javascript:history.back()">Go Back</a> | </li>
<li style="float: right;margin-left: 10px;"><a href="/index.html">Home</a> | </li>

      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="id1">
<h1>概述<a class="headerlink" href="#id1" title="Permalink to this heading"></a></h1>
<p>高通qcm2290 bc1.2目前使用纯micro usb方式无法获取，看一下原理</p>
</section>
<section id="id2">
<h1>参考<a class="headerlink" href="#id2" title="Permalink to this heading"></a></h1>
<p>qcom有的平台直接通过寄存器获取，接口<code class="docutils literal notranslate"><span class="pre">smblib_get_apsd_result</span></code>：</p>
<ul class="simple">
<li><p><a class="reference external" href="https://blog.csdn.net/qq_40405527/article/details/124740245">Android Qcom USB Driver学习(二)</a></p></li>
</ul>
</section>
<section id="id3">
<h1>代码<a class="headerlink" href="#id3" title="Permalink to this heading"></a></h1>
<ul class="simple">
<li><p>涉及文件如下：</p></li>
</ul>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span>vendor/bengal_defconfig
470:CONFIG_MSM_QUSB_PHY=y
CONFIG_USB_MSM_SSPHY_QMP=y

drivers/usb/phy/Makefile：
obj-$(CONFIG_MSM_QUSB_PHY)              += phy-msm-qusb.o phy-msm-qusb-v2.o
obj-$(CONFIG_USB_MSM_SSPHY_QMP)         += phy-msm-ssusb-qmp.o
</pre></div>
</div>
</section>
<section id="id4">
<h1>程序流程<a class="headerlink" href="#id4" title="Permalink to this heading"></a></h1>
<p><img alt="0017_0003.png" src="../../../_images/0017_0003.png" /></p>
</section>
<section id="charger-extcon">
<h1>charger extcon通知原理<a class="headerlink" href="#charger-extcon" title="Permalink to this heading"></a></h1>
<ul class="simple">
<li><p><a class="reference external" href="https://blog.csdn.net/u012804784/article/details/124762990">extcon驱动及其在USB驱动中的应用</a></p></li>
<li><p><a class="reference external" href="https://blog.csdn.net/qq_24622489/article/details/120436289">Linux extcon驱动学习</a></p></li>
<li><p><a class="reference external" href="https://blog.csdn.net/mike8825/article/details/121186656">linux下的extcon驱动小析</a></p></li>
</ul>
<section id="qusbhost-device">
<h2>qusb设置host/device逻辑<a class="headerlink" href="#qusbhost-device" title="Permalink to this heading"></a></h2>
<ul class="simple">
<li><p>qusb驱动通过extcon绑定pm2250_charger驱动，两者可以进行extcon notify通信，dts:</p></li>
</ul>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span>scuba-usb.dtsi:
        /* Primary USB port related High Speed PHY */
        qusb_phy0: qusb@1613000 {
                compatible = &quot;qcom,qusb2phy&quot;;
        };

scuba-iot-idp.dtsi:
&amp;qusb_phy0 {
        extcon = &lt;&amp;pm2250_charger&gt;;
        vdda33-supply = &lt;&amp;vreg_usb_3p1&gt;;
};
</pre></div>
</div>
<section id="pm4125extcon">
<h3>pm4125初始化extcon<a class="headerlink" href="#pm4125extcon" title="Permalink to this heading"></a></h3>
<ul class="simple">
<li><p>首先是pmic收到usb插入中断，流程图如下：</p></li>
</ul>
<p><img alt="0017_0001.png" src="../../../_images/0017_0001.png" /></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">drivers/power/supply/qcom/qpnp-smblite.c</span></code>charger先分配edev，初始化extcon和内核通知链:</p></li>
</ul>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">smblite_lib_extcon_cable</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="n">EXTCON_USB</span><span class="p">,</span><span class="w"></span>
<span class="w">	</span><span class="n">EXTCON_USB_HOST</span><span class="p">,</span><span class="w"></span>
<span class="w">	</span><span class="n">EXTCON_NONE</span><span class="p">,</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">smblite_probe</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">platform_device</span><span class="w"> </span><span class="o">*</span><span class="n">pdev</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="cm">/* extcon registration */</span><span class="w"></span>
<span class="w">	</span><span class="n">chg</span><span class="o">-&gt;</span><span class="n">extcon</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">devm_extcon_dev_allocate</span><span class="p">(</span><span class="n">chg</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span><span class="w"></span>
<span class="w">					</span><span class="n">smblite_lib_extcon_cable</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">chg</span><span class="o">-&gt;</span><span class="n">extcon</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="n">rc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PTR_ERR</span><span class="p">(</span><span class="n">chg</span><span class="o">-&gt;</span><span class="n">extcon</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="n">dev_err</span><span class="p">(</span><span class="n">chg</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Couldn&#39;t to allocate extcon device rc=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">				</span><span class="n">rc</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="k">goto</span><span class="w"> </span><span class="n">cleanup</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>

<span class="w">	</span><span class="n">rc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">devm_extcon_dev_register</span><span class="p">(</span><span class="n">chg</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="n">chg</span><span class="o">-&gt;</span><span class="n">extcon</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">rc</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="n">dev_err</span><span class="p">(</span><span class="n">chg</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Couldn&#39;t to register extcon device rc=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">				</span><span class="n">rc</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="k">goto</span><span class="w"> </span><span class="n">cleanup</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>

<span class="w">	</span><span class="cm">/* Support reporting polarity and speed via properties */</span><span class="w"></span>
<span class="cm">/*EXTCON_USB/EXTCON_USB_HOST 支持设置typec的方向还有usb的速度 */</span><span class="w"></span>
<span class="w">	</span><span class="n">rc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">extcon_set_property_capability</span><span class="p">(</span><span class="n">chg</span><span class="o">-&gt;</span><span class="n">extcon</span><span class="p">,</span><span class="w"></span>
<span class="w">			</span><span class="n">EXTCON_USB</span><span class="p">,</span><span class="w"> </span><span class="n">EXTCON_PROP_USB_TYPEC_POLARITY</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="n">rc</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">extcon_set_property_capability</span><span class="p">(</span><span class="n">chg</span><span class="o">-&gt;</span><span class="n">extcon</span><span class="p">,</span><span class="w"></span>
<span class="w">			</span><span class="n">EXTCON_USB</span><span class="p">,</span><span class="w"> </span><span class="n">EXTCON_PROP_USB_SS</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="n">rc</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">extcon_set_property_capability</span><span class="p">(</span><span class="n">chg</span><span class="o">-&gt;</span><span class="n">extcon</span><span class="p">,</span><span class="w"></span>
<span class="w">			</span><span class="n">EXTCON_USB_HOST</span><span class="p">,</span><span class="w"> </span><span class="n">EXTCON_PROP_USB_TYPEC_POLARITY</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="n">rc</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">extcon_set_property_capability</span><span class="p">(</span><span class="n">chg</span><span class="o">-&gt;</span><span class="n">extcon</span><span class="p">,</span><span class="w"></span>
<span class="w">			</span><span class="n">EXTCON_USB_HOST</span><span class="p">,</span><span class="w"> </span><span class="n">EXTCON_PROP_USB_SS</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">rc</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="n">dev_err</span><span class="p">(</span><span class="n">chg</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span><span class="w"></span>
<span class="w">			</span><span class="s">&quot;Couldn&#39;t to configure extcon capabilities</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="k">goto</span><span class="w"> </span><span class="n">cleanup</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>


<span class="kt">int</span><span class="w"> </span><span class="nf">devm_extcon_dev_register</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">device</span><span class="w"> </span><span class="o">*</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">extcon_dev</span><span class="w"> </span><span class="o">*</span><span class="n">edev</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="p">...</span><span class="w"></span>
<span class="w">	</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">edev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">devm_extcon_dev_allocate</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="n">usb_extcon_cable</span><span class="p">);</span><span class="c1">//注册对应的edev</span>
<span class="w">	</span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">extcon_dev_register</span><span class="p">(</span><span class="n">edev</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="w"> </span>
<span class="kt">int</span><span class="w"> </span><span class="nf">extcon_dev_register</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">extcon_dev</span><span class="w"> </span><span class="o">*</span><span class="n">edev</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="p">...</span><span class="w"></span>
<span class="w">	</span><span class="n">edev</span><span class="o">-&gt;</span><span class="n">nh</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">devm_kcalloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">edev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="n">edev</span><span class="o">-&gt;</span><span class="n">max_supported</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">edev</span><span class="o">-&gt;</span><span class="n">nh</span><span class="p">),</span><span class="w"> </span><span class="n">GFP_KERNEL</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="o">-</span><span class="w"></span>
<span class="w">	</span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">edev</span><span class="o">-&gt;</span><span class="n">max_supported</span><span class="p">;</span><span class="w"> </span><span class="n">index</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">		</span><span class="n">RAW_INIT_NOTIFIER_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">edev</span><span class="o">-&gt;</span><span class="n">nh</span><span class="p">[</span><span class="n">index</span><span class="p">]);</span><span class="w"></span>
<span class="w"> </span>
<span class="w">	</span><span class="n">RAW_INIT_NOTIFIER_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">edev</span><span class="o">-&gt;</span><span class="n">nh_all</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="p">...</span><span class="w">	</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="qusb-dtsedev-pm2250-charger-usb-add-phy-dev">
<h3>qusb 根据dts找到edev(pm2250_charger)，并注册到其内核通知链中(usb_add_phy_dev)<a class="headerlink" href="#qusb-dtsedev-pm2250-charger-usb-add-phy-dev" title="Permalink to this heading"></a></h3>
<ul class="simple">
<li><p>这里做了两件事：</p>
<ul>
<li><ol class="arabic simple">
<li><p>qusb 根据dts找到edev(pm2250_charger)，并将vbus_nb和id_nb注册到其内核通知链中(usb_add_phy_dev)</p></li>
</ol>
</li>
<li><ol class="arabic simple" start="2">
<li><p>向DW3驱动分配edev，初始化extcon内核通知链。</p></li>
</ol>
</li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">drivers/usb/phy/phy-msm-qusb.c</span></code>:</p></li>
</ul>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span>static int qusb_phy_probe(struct platform_device *pdev)
{
	if (of_property_read_bool(dev-&gt;of_node, &quot;extcon&quot;)) {
		INIT_DELAYED_WORK(&amp;qphy-&gt;port_det_w, qusb_phy_port_state_work);

		ret = qusb_phy_extcon_register(qphy);
		if (ret)
			return ret;

	}

	ret = usb_add_phy_dev(&amp;qphy-&gt;phy);
	if (ret)
		return ret;
}

1.qusb 根据dts找到edev(pm2250_charger)，并将vbus_nb和id_nb注册到其内核通知链中(usb_add_phy_dev)
int usb_add_phy_dev(struct usb_phy *x)
{
	...	
	ret = usb_add_extcon(x);
	...	
}
 
static int usb_add_extcon(struct usb_phy *x)
{
	...
	if (of_property_read_bool(x-&gt;dev-&gt;of_node, &quot;extcon&quot;)) {
		x-&gt;edev = extcon_get_edev_by_phandle(x-&gt;dev, 0);//找对对应的edev
		if (x-&gt;vbus_nb.notifier_call) {
			ret = devm_extcon_register_notifier(x-&gt;dev, x-&gt;edev,EXTCON_USB,&amp;x-&gt;vbus_nb);
		}
	} 
	...

	1.注册vbus_nb，绑定EXTCON_USB
	if (x-&gt;vbus_nb.notifier_call) {
		ret = devm_extcon_register_notifier(x-&gt;dev, x-&gt;edev,
							EXTCON_USB,
							&amp;x-&gt;vbus_nb);
		if (ret &lt; 0) {
			dev_err(x-&gt;dev,
				&quot;register VBUS notifier failed\n&quot;);
			return ret;
		}

	2.注册id_nb，绑定EXTCON_USB_HOST
	if (x-&gt;id_nb.notifier_call) {
		struct extcon_dev *id_ext;

		if (x-&gt;id_edev)
			id_ext = x-&gt;id_edev;
		else
			id_ext = x-&gt;edev;

		ret = devm_extcon_register_notifier(x-&gt;dev, id_ext,
							EXTCON_USB_HOST,
							&amp;x-&gt;id_nb);
		if (ret &lt; 0) {
			dev_err(x-&gt;dev,
				&quot;register ID notifier failed\n&quot;);
			return ret;
		}
}
 
int devm_extcon_register_notifier(struct device *dev, struct extcon_dev *edev,unsigned int id, struct notifier_block *nb)
{
	...	
	ret = extcon_register_notifier(edev, id, nb);
	...	
}
 
int extcon_register_notifier(struct extcon_dev *edev, unsigned int id,struct notifier_block *nb)
{
	...
	idx = find_cable_index_by_id(edev, id);
	ret = raw_notifier_chain_register(&amp;edev-&gt;nh[idx], nb);
	...
}


注册两个notify，分别是vbus和id脚，由charger发起通知，qusb接收：
static int qusb_phy_extcon_register(struct qusb_phy *qphy)
{
	int ret;

	/* Register extcon for notifications from charger driver */
	qphy-&gt;phy.vbus_nb.notifier_call = qusb_phy_vbus_notifier;

	qphy-&gt;phy.id_nb.notifier_call = qusb_phy_id_notifier;

	/* Register extcon to notify USB driver */
	qphy-&gt;usb_extcon = devm_extcon_dev_allocate(qphy-&gt;phy.dev,
						qusb_phy_extcon_cable);
	if (IS_ERR(qphy-&gt;usb_extcon)) {
		dev_err(qphy-&gt;phy.dev, &quot;failed to allocate extcon device\n&quot;);
		return PTR_ERR(qphy-&gt;usb_extcon);
	}

向DW3驱动注册extcon设备，并设置属性EXTCON_USB_HOST EXTCON_USB
	ret = devm_extcon_dev_register(qphy-&gt;phy.dev, qphy-&gt;usb_extcon);
	if (ret) {
		dev_err(qphy-&gt;phy.dev, &quot;failed to register extcon device\n&quot;);
		return ret;
	}

	extcon_set_property_capability(qphy-&gt;usb_extcon, EXTCON_USB,
			EXTCON_PROP_USB_TYPEC_POLARITY);
	extcon_set_property_capability(qphy-&gt;usb_extcon, EXTCON_USB,
			EXTCON_PROP_USB_SS);
	extcon_set_property_capability(qphy-&gt;usb_extcon, EXTCON_USB_HOST,
			EXTCON_PROP_USB_TYPEC_POLARITY);
	extcon_set_property_capability(qphy-&gt;usb_extcon, EXTCON_USB_HOST,
			EXTCON_PROP_USB_SS);
	return 0;
}
</pre></div>
</div>
<p>dw3驱动dts如下：</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span>&amp;usb0 {
        extcon = &lt;&amp;qusb_phy0&gt;, &lt;&amp;eud&gt;;
};

&amp;soc {
        /* Primary USB port related controller */
        usb0: ssusb@4e00000 {
                compatible = &quot;qcom,dwc-usb3-msm&quot;;
                reg = &lt;0x4e00000 0x100000&gt;;
                reg-names = &quot;core_base&quot;;
		};

                dwc3@4e00000 {
                        compatible = &quot;snps,dwc3&quot;;
                        reg = &lt;0x4e00000 0xcd00&gt;;
                        interrupt-parent = &lt;&amp;intc&gt;;
                        interrupts = &lt;GIC_SPI 255 IRQ_TYPE_LEVEL_HIGH&gt;;
                        usb-phy = &lt;&amp;qusb_phy0&gt;, &lt;&amp;usb_qmp_phy&gt;;
                        tx-fifo-resize;
                        linux,sysdev_is_parent;
                        snps,disable-clk-gating;
                        snps,dis_u2_susphy_quirk;
                        snps,dis_enblslpm_quirk;
                        snps,has-lpm-erratum;
                        snps,hird-threshold = /bits/ 8 &lt;0x10&gt;;
                        snps,usb3-u1u2-disable;
                        snps,usb3_lpm_capable;
                        usb-core-id = &lt;0&gt;;
                        maximum-speed = &quot;super-speed&quot;;
                        dr_mode = &quot;otg&quot;;
                };
};
</pre></div>
</div>
<ul class="simple">
<li><p>两个notify如下:</p>
<ul>
<li><p>也就是charger那边发送<code class="docutils literal notranslate"><span class="pre">extcon_set_state_sync(chg-&gt;extcon,</span> <span class="pre">EXTCON_USB,</span> <span class="pre">enable)</span></code>后会发通知给qusb的<code class="docutils literal notranslate"><span class="pre">qusb_phy_vbus_notifier</span></code>，然后<code class="docutils literal notranslate"><span class="pre">queue_delayed_work</span> <span class="pre">port_det_w</span></code>工作队列。</p></li>
<li><p>charger那边发送<code class="docutils literal notranslate"><span class="pre">extcon_set_state_sync(chg-&gt;extcon,</span> <span class="pre">EXTCON_USB_HOST,</span> <span class="pre">enable)</span></code>后会发通知给qusb的<code class="docutils literal notranslate"><span class="pre">qusb_phy_id_notifier</span></code>，然后<code class="docutils literal notranslate"><span class="pre">queue_delayed_work</span> <span class="pre">port_det_w</span></code>工作队列。</p></li>
</ul>
</li>
</ul>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">qusb_phy_vbus_notifier</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">notifier_block</span><span class="w"> </span><span class="o">*</span><span class="n">nb</span><span class="p">,</span><span class="w"></span>
<span class="w">		</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">event</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">data</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="k">struct</span><span class="w"> </span><span class="nc">usb_phy</span><span class="w"> </span><span class="o">*</span><span class="n">phy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">container_of</span><span class="p">(</span><span class="n">nb</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">usb_phy</span><span class="p">,</span><span class="w"> </span><span class="n">vbus_nb</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="k">struct</span><span class="w"> </span><span class="nc">qusb_phy</span><span class="w"> </span><span class="o">*</span><span class="n">qphy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">container_of</span><span class="p">(</span><span class="n">phy</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">qusb_phy</span><span class="p">,</span><span class="w"> </span><span class="n">phy</span><span class="p">);</span><span class="w"></span>

<span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">qphy</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="o">!</span><span class="n">data</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Failed to get PHY for vbus_notifier</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="k">return</span><span class="w"> </span><span class="n">NOTIFY_DONE</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>
<span class="w">	</span><span class="n">dump_stack</span><span class="p">();</span><span class="w"></span>
<span class="w">	</span><span class="n">qphy</span><span class="o">-&gt;</span><span class="n">vbus_active</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">!!</span><span class="n">event</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">dev_err</span><span class="p">(</span><span class="n">qphy</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Got VBUS notification: %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">event</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="n">queue_delayed_work</span><span class="p">(</span><span class="n">system_freezable_wq</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">qphy</span><span class="o">-&gt;</span><span class="n">port_det_w</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>

<span class="w">	</span><span class="k">return</span><span class="w"> </span><span class="n">NOTIFY_DONE</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">qusb_phy_id_notifier</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">notifier_block</span><span class="w"> </span><span class="o">*</span><span class="n">nb</span><span class="p">,</span><span class="w"></span>
<span class="w">		</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">event</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">data</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="k">struct</span><span class="w"> </span><span class="nc">usb_phy</span><span class="w"> </span><span class="o">*</span><span class="n">phy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">container_of</span><span class="p">(</span><span class="n">nb</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">usb_phy</span><span class="p">,</span><span class="w"> </span><span class="n">id_nb</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="k">struct</span><span class="w"> </span><span class="nc">qusb_phy</span><span class="w"> </span><span class="o">*</span><span class="n">qphy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">container_of</span><span class="p">(</span><span class="n">phy</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">qusb_phy</span><span class="p">,</span><span class="w"> </span><span class="n">phy</span><span class="p">);</span><span class="w"></span>

<span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">qphy</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="o">!</span><span class="n">data</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Failed to get PHY for vbus_notifier</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="k">return</span><span class="w"> </span><span class="n">NOTIFY_DONE</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>
<span class="w">	</span><span class="n">dump_stack</span><span class="p">();</span><span class="w"></span>
<span class="w">	</span><span class="n">qphy</span><span class="o">-&gt;</span><span class="n">id_state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">!</span><span class="n">event</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">dev_err</span><span class="p">(</span><span class="n">qphy</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Got id notification: %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">event</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="n">queue_delayed_work</span><span class="p">(</span><span class="n">system_freezable_wq</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">qphy</span><span class="o">-&gt;</span><span class="n">port_det_w</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>

<span class="w">	</span><span class="k">return</span><span class="w"> </span><span class="n">NOTIFY_DONE</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
</section>
<section id="charger-bc1-2">
<h1>charger BC1.2检测原理<a class="headerlink" href="#charger-bc1-2" title="Permalink to this heading"></a></h1>
<p>检测原理：</p>
<p>(1)DCD：DP上有150mV（= 10uA x 15K欧姆下拉电阻）的电压，DM上电压为0
DCD机制向D+提供的电流源，可用定时器替代，但DCD能尽快检测数据线的连接，不必等待定时器超时，
DCD（data contact detect）的检测机制等待时间是可编程的通常是300ms 或者 600 ms。
(2)Primary Det（DP发起检测DM）：
DP上加载0.6V电压，DM上电压为0，充电器类型是SDP
DP上加载0.6V电压，DM上电压为0.6V，进入Secondary Det
(3)Secondary Det（DM发起检测DP）：
DM上加载0.8V电压，DP上电压为0，充电器类型是CDP
DM上加载0.8V电压，DP上电压为0.8V，充电器类型是DCP</p>
<p><img alt="0017_0002.png" src="../../../_images/0017_0002.png" /></p>
<section id="qusb-port-det-w-work">
<h2>qusb port_det_w.work识别流程<a class="headerlink" href="#qusb-port-det-w-work" title="Permalink to this heading"></a></h2>
<p>总体usb bc12识别流程由上层charger通知device插入后，将调用vbus通知链，以下是SDP识别过程及log：</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="o">*</span><span class="w"> </span><span class="n">INIT_DELAYED_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qphy</span><span class="o">-&gt;</span><span class="n">port_det_w</span><span class="p">,</span><span class="w"> </span><span class="n">qusb_phy_port_state_work</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="o">*</span><span class="w"> </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">qphy</span><span class="o">-&gt;</span><span class="n">port_state</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="o">*</span><span class="w"> </span><span class="n">PORT_UNKNOWN</span><span class="w"></span>
<span class="w">	  </span><span class="o">*</span><span class="w"> </span><span class="n">PORT_DISCONNECTED</span><span class="w"></span>
<span class="w">	    </span><span class="o">*</span><span class="w"> </span><span class="n">PORT_DCD_IN_PROGRESS</span><span class="w"></span>
<span class="w">		  </span><span class="o">*</span><span class="w"> </span><span class="n">PORT_DISCONNECTED</span><span class="w"></span>
<span class="w">		    </span><span class="o">*</span><span class="w"> </span><span class="n">PORT_DCD_IN_PROGRESS</span><span class="w"></span>
<span class="w">			  </span><span class="o">*</span><span class="w"> </span><span class="n">PORT_PRIMARY_IN_PROGRESS</span><span class="w"></span>
<span class="w">			    </span><span class="o">*</span><span class="w"> </span><span class="n">PORT_DCD_IN_PROGRESS</span><span class="w"></span>
<span class="w">				  </span><span class="o">*</span><span class="w"> </span><span class="n">qusb_phy_notify_charger</span><span class="p">(</span><span class="n">qphy</span><span class="p">,</span><span class="w"> </span><span class="n">POWER_SUPPLY_TYPE_USB</span><span class="p">);</span><span class="w"> </span><span class="c1">//设置charger充电类型</span>
<span class="w">				    </span><span class="o">*</span><span class="w"> </span><span class="n">power_supply_set_property</span><span class="p">(</span><span class="n">qphy</span><span class="o">-&gt;</span><span class="n">usb_psy</span><span class="p">,</span><span class="w"> </span><span class="n">POWER_SUPPLY_PROP_REAL_TYPE</span><span class="p">,</span><span class="o">&amp;</span><span class="n">pval</span><span class="p">);</span><span class="w"></span>
<span class="w">				  </span><span class="o">*</span><span class="w"> </span><span class="n">qusb_phy_notify_extcon</span><span class="p">(</span><span class="n">qphy</span><span class="p">,</span><span class="w"> </span><span class="n">EXTCON_USB</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"> </span><span class="c1">//通知dw3驱动切换device</span>
<span class="w">				    </span><span class="o">*</span><span class="w"> </span><span class="n">extcon_set_state_sync</span><span class="p">(</span><span class="n">qphy</span><span class="o">-&gt;</span><span class="n">usb_extcon</span><span class="p">,</span><span class="w"> </span><span class="n">extcon_id</span><span class="p">,</span><span class="w"> </span><span class="n">event</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>log如下，识别过程花费时间<code class="docutils literal notranslate"><span class="pre">0.302503</span></code>s：</p>
<div class="highlight-log notranslate"><div class="highlight"><pre><span></span>[   74.957732] msm-qusb-phy 1613000.qusb: Got VBUS notification: 1
[   74.963686] extcon extcon2: name_show = NAME=soc:rt_pd_manager
[   74.969536] extcon extcon2: state_show = STATE=USB=1
[   74.969536] USB-HOST=0
[   74.979288] msm-qusb-phy 1613000.qusb: state: 0
[   74.983873] msm-qusb-phy 1613000.qusb: qusb_phy_enable_power turn on regulators
[   74.991506] msm-qusb-phy 1613000.qusb: min_vol:925000 max_vol:970000
[   74.999738] msm-qusb-phy 1613000.qusb: qusb_phy_enable_clocks(): on:1
[   75.006219] msm-qusb-phy 1613000.qusb: state: 1
[   75.043606] ///PD dbg info 42d
[   75.043779] PAX_CHG_MP2721: mp2721_info tcpc_notifier_call, old_state = (null), new_state = (null)
[   75.046699] &lt;   75.043&gt;Trigger PD_TIMER_SINK_WAIT_CAP
[   75.060061] msm-qusb-phy 1613000.qusb: state: 2
[   75.062241] PAX_CHG_MP2721: mp2721_info tcpc_notifier_call, old_state = UNATTACHED, new_state = UNATTACHED
[   75.065356] msm-qusb-phy 1613000.qusb: state: 1 reg: 0x0
[   75.065359] msm-qusb-phy 1613000.qusb: state: 2
[   75.085011] rt-pd-manager soc:rt_pd_manager: pd_tcp_notifier_call pd state = 9
[   75.088173] E:pd_state=9
[   75.138681] PAX_CHG_MP2721: tcpc_notifier_call sink vbus 5000mV 100mA type(0x02)
[   75.164064] msm-qusb-phy 1613000.qusb: state: 3
[   75.175473] rt-pd-manager soc:rt_pd_manager: pd_tcp_notifier_call sink vbus 5000mV 100mA type(0x02)
[   75.221475] msm-qusb-phy 1613000.qusb: state: 2 reg: 0x0
[   75.226998] msm-qusb-phy 1613000.qusb: qusb_phy_enable_clocks(): on:0
[   75.233477] msm-qusb-phy 1613000.qusb: qusb_phy_enable_power turn off regulators
[   75.241424] msm-qusb-phy 1613000.qusb: min_vol:0 max_vol:970000
[   75.247378] msm-qusb-phy 1613000.qusb: QUSB PHY&#39;s regulators are turned OFF.
[   75.254457] msm-qusb-phy 1613000.qusb: Notify charger type: 4
[   75.260235] mp2721 0-003f: mp2721_set_property() set charge_type:4, ret:0
</pre></div>
</div>
<p>DCP识别过程log如下：</p>
<div class="highlight-log notranslate"><div class="highlight"><pre><span></span>行 1585: [Wed Dec 31 20:05:14 1969] msm-qusb-phy 1613000.qusb: Got VBUS notification: 1
行 1594: [Wed Dec 31 20:05:14 1969] msm-qusb-phy 1613000.qusb: state: 0
行 1595: [Wed Dec 31 20:05:15 1969] msm-qusb-phy 1613000.qusb: qusb_phy_enable_power turn on regulators
行 1600: [Wed Dec 31 20:05:15 1969] msm-qusb-phy 1613000.qusb: min_vol:925000 max_vol:970000
行 1618: [Wed Dec 31 20:05:15 1969] msm-qusb-phy 1613000.qusb: qusb_phy_enable_clocks(): on:1
行 1619: [Wed Dec 31 20:05:15 1969] msm-qusb-phy 1613000.qusb: state: 1
行 1630: [Wed Dec 31 20:05:15 1969] msm-qusb-phy 1613000.qusb: state: 2
行 1635: [Wed Dec 31 20:05:15 1969] msm-qusb-phy 1613000.qusb: state: 1 reg: 0x0
行 1639: [Wed Dec 31 20:05:15 1969] msm-qusb-phy 1613000.qusb: state: 2
行 1649: [Wed Dec 31 20:05:15 1969] msm-qusb-phy 1613000.qusb: state: 3
行 1650: [Wed Dec 31 20:05:15 1969] msm-qusb-phy 1613000.qusb: state: 2 reg: 0x10101010
行 1654: [Wed Dec 31 20:05:15 1969] msm-qusb-phy 1613000.qusb: state: 3
行 1661: [Wed Dec 31 20:05:15 1969] msm-qusb-phy 1613000.qusb: state: 4
行 1662: [Wed Dec 31 20:05:15 1969] msm-qusb-phy 1613000.qusb: state: 3 reg: 0x10101010
行 1666: [Wed Dec 31 20:05:15 1969] msm-qusb-phy 1613000.qusb: Notify charger type: 5
</pre></div>
</div>
<p>处理函数如下工作队列：</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">qusb_phy_port_state_work</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">work_struct</span><span class="w"> </span><span class="o">*</span><span class="n">w</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="k">struct</span><span class="w"> </span><span class="nc">qusb_phy</span><span class="w"> </span><span class="o">*</span><span class="n">qphy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">container_of</span><span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">qusb_phy</span><span class="p">,</span><span class="w"></span>
<span class="w">							</span><span class="n">port_det_w</span><span class="p">.</span><span class="n">work</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">delay</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="kt">int</span><span class="w"> </span><span class="n">status</span><span class="p">,</span><span class="w"> </span><span class="n">ret</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="kt">bool</span><span class="w"> </span><span class="n">vbus_active</span><span class="p">,</span><span class="w"> </span><span class="n">id_state</span><span class="p">;</span><span class="w"></span>

<span class="w">	</span><span class="n">dev_err</span><span class="p">(</span><span class="n">qphy</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;state: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">qphy</span><span class="o">-&gt;</span><span class="n">port_state</span><span class="p">);</span><span class="w"></span>

<span class="w">	</span><span class="cm">/*</span>
<span class="cm">	 * The events for cable connect should be ignored if</span>
<span class="cm">	 * the is_port_valid set to false to prevent the USB</span>
<span class="cm">	 * stack being brought up and voting for the regulators.</span>
<span class="cm">	 */</span><span class="w"></span>
<span class="w">	</span><span class="n">qphy</span><span class="o">-&gt;</span><span class="n">is_port_valid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">qphy_get_notifier_gpio_state</span><span class="p">(</span><span class="n">qphy</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">qphy</span><span class="o">-&gt;</span><span class="n">is_port_valid</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="n">dev_err</span><span class="p">(</span><span class="n">qphy</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Port not valid, notify disconnect</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="n">vbus_active</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="w">		</span><span class="n">id_state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="n">vbus_active</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">qphy</span><span class="o">-&gt;</span><span class="n">vbus_active</span><span class="p">;</span><span class="w"></span>
<span class="w">		</span><span class="n">id_state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">qphy</span><span class="o">-&gt;</span><span class="n">id_state</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>

<span class="w">	</span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">qphy</span><span class="o">-&gt;</span><span class="n">port_state</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="k">case</span><span class="w"> </span><span class="no">PORT_UNKNOWN</span><span class="p">:</span><span class="w"></span>
<span class="w">		</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">id_state</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">			</span><span class="n">qphy</span><span class="o">-&gt;</span><span class="n">port_state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PORT_HOST_MODE</span><span class="p">;</span><span class="w"></span>
<span class="w">			</span><span class="n">qusb_phy_notify_extcon</span><span class="p">(</span><span class="n">qphy</span><span class="p">,</span><span class="w"> </span><span class="n">EXTCON_USB_HOST</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">			</span><span class="k">return</span><span class="p">;</span><span class="w"></span>
<span class="w">		</span><span class="p">}</span><span class="w"></span>

<span class="w">		</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">vbus_active</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">			</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">qphy</span><span class="o">-&gt;</span><span class="n">eud_enable_reg</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"></span>
<span class="w">					</span><span class="n">readl_relaxed</span><span class="p">(</span><span class="n">qphy</span><span class="o">-&gt;</span><span class="n">eud_enable_reg</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">				</span><span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;qusb: EUD is enabled, no charger detection</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">				</span><span class="n">qusb_phy_notify_charger</span><span class="p">(</span><span class="n">qphy</span><span class="p">,</span><span class="w"></span>
<span class="w">							</span><span class="n">POWER_SUPPLY_TYPE_USB</span><span class="p">);</span><span class="w"></span>
<span class="w">				</span><span class="n">qusb_phy_notify_extcon</span><span class="p">(</span><span class="n">qphy</span><span class="p">,</span><span class="w"> </span><span class="n">EXTCON_USB</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">				</span><span class="n">qphy</span><span class="o">-&gt;</span><span class="n">port_state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PORT_CHG_DET_DONE</span><span class="p">;</span><span class="w"></span>
<span class="w">				</span><span class="k">return</span><span class="p">;</span><span class="w"></span>
<span class="w">			</span><span class="p">}</span><span class="w"></span>

<span class="w">			</span><span class="cm">/* Enable DCD sequence */</span><span class="w"></span>
<span class="w">			</span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">qusb_phy_prepare_chg_det</span><span class="p">(</span><span class="n">qphy</span><span class="p">);</span><span class="w"></span>
<span class="w">			</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ret</span><span class="p">)</span><span class="w"></span>
<span class="w">				</span><span class="k">return</span><span class="p">;</span><span class="w"></span>

<span class="w">			</span><span class="n">qusb_phy_chg_det_enable_seq</span><span class="p">(</span><span class="n">qphy</span><span class="p">,</span><span class="w"> </span><span class="n">STATE_DCD</span><span class="p">);</span><span class="w"></span>
<span class="w">			</span><span class="n">qphy</span><span class="o">-&gt;</span><span class="n">port_state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PORT_DCD_IN_PROGRESS</span><span class="p">;</span><span class="w"></span>
<span class="w">			</span><span class="n">qphy</span><span class="o">-&gt;</span><span class="n">dcd_timeout</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">			</span><span class="n">delay</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CHG_DCD_POLL_TIME_MSEC</span><span class="p">;</span><span class="w"></span>
<span class="w">			</span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">		</span><span class="p">}</span><span class="w"></span>
<span class="w">		</span><span class="k">return</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="k">case</span><span class="w"> </span><span class="no">PORT_DISCONNECTED</span><span class="p">:</span><span class="w"></span>
<span class="w">		</span><span class="n">qusb_phy_unprepare_chg_det</span><span class="p">(</span><span class="n">qphy</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="n">qphy</span><span class="o">-&gt;</span><span class="n">port_state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PORT_UNKNOWN</span><span class="p">;</span><span class="w"></span>
<span class="w">		</span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="k">case</span><span class="w"> </span><span class="no">PORT_DCD_IN_PROGRESS</span><span class="p">:</span><span class="w"></span>
<span class="w">		</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">vbus_active</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">			</span><span class="cm">/* Disable PHY sequence */</span><span class="w"></span>
<span class="w">			</span><span class="n">qphy</span><span class="o">-&gt;</span><span class="n">port_state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PORT_DISCONNECTED</span><span class="p">;</span><span class="w"></span>
<span class="w">			</span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">		</span><span class="p">}</span><span class="w"></span>

<span class="w">		</span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">qusb_phy_chg_det_status</span><span class="p">(</span><span class="n">qphy</span><span class="p">,</span><span class="w"> </span><span class="n">STATE_DCD</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">qphy</span><span class="o">-&gt;</span><span class="n">dcd_timeout</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">CHG_DCD_TIMEOUT_MSEC</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">			</span><span class="n">delay</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CHG_DCD_POLL_TIME_MSEC</span><span class="p">;</span><span class="w"></span>
<span class="w">			</span><span class="n">qphy</span><span class="o">-&gt;</span><span class="n">dcd_timeout</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">delay</span><span class="p">;</span><span class="w"></span>
<span class="w">		</span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">status</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">			</span><span class="n">qusb_phy_chg_det_enable_seq</span><span class="p">(</span><span class="n">qphy</span><span class="p">,</span><span class="w"> </span><span class="n">STATE_PRIMARY</span><span class="p">);</span><span class="w"></span>
<span class="w">			</span><span class="n">qphy</span><span class="o">-&gt;</span><span class="n">port_state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PORT_PRIMARY_IN_PROGRESS</span><span class="p">;</span><span class="w"></span>
<span class="w">			</span><span class="n">delay</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CHG_PRIMARY_DET_TIME_MSEC</span><span class="p">;</span><span class="w"></span>
<span class="w">		</span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">qphy</span><span class="o">-&gt;</span><span class="n">dcd_timeout</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">CHG_DCD_TIMEOUT_MSEC</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">			</span><span class="n">qusb_phy_notify_charger</span><span class="p">(</span><span class="n">qphy</span><span class="p">,</span><span class="w"></span>
<span class="w">						</span><span class="n">POWER_SUPPLY_TYPE_USB_DCP</span><span class="p">);</span><span class="w"></span>
<span class="w">			</span><span class="n">qusb_phy_unprepare_chg_det</span><span class="p">(</span><span class="n">qphy</span><span class="p">);</span><span class="w"></span>
<span class="w">			</span><span class="n">qphy</span><span class="o">-&gt;</span><span class="n">port_state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PORT_CHG_DET_DONE</span><span class="p">;</span><span class="w"></span>
<span class="w">		</span><span class="p">}</span><span class="w"></span>
<span class="w">		</span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="k">case</span><span class="w"> </span><span class="no">PORT_PRIMARY_IN_PROGRESS</span><span class="p">:</span><span class="w"></span>
<span class="w">		</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">vbus_active</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">			</span><span class="n">qphy</span><span class="o">-&gt;</span><span class="n">port_state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PORT_DISCONNECTED</span><span class="p">;</span><span class="w"></span>
<span class="w">			</span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">		</span><span class="p">}</span><span class="w"></span>

<span class="w">		</span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">qusb_phy_chg_det_status</span><span class="p">(</span><span class="n">qphy</span><span class="p">,</span><span class="w"> </span><span class="n">STATE_PRIMARY</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">status</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">			</span><span class="n">qusb_phy_chg_det_enable_seq</span><span class="p">(</span><span class="n">qphy</span><span class="p">,</span><span class="w"> </span><span class="n">STATE_SECONDARY</span><span class="p">);</span><span class="w"></span>
<span class="w">			</span><span class="n">qphy</span><span class="o">-&gt;</span><span class="n">port_state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PORT_SECONDARY_IN_PROGRESS</span><span class="p">;</span><span class="w"></span>
<span class="w">			</span><span class="n">delay</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CHG_SECONDARY_DET_TIME_MSEC</span><span class="p">;</span><span class="w"></span>

<span class="w">		</span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">			</span><span class="n">qusb_phy_unprepare_chg_det</span><span class="p">(</span><span class="n">qphy</span><span class="p">);</span><span class="w"></span>
<span class="w">			</span><span class="n">qusb_phy_notify_charger</span><span class="p">(</span><span class="n">qphy</span><span class="p">,</span><span class="w"> </span><span class="n">POWER_SUPPLY_TYPE_USB</span><span class="p">);</span><span class="w"></span>
<span class="w">			</span><span class="n">qusb_phy_notify_extcon</span><span class="p">(</span><span class="n">qphy</span><span class="p">,</span><span class="w"> </span><span class="n">EXTCON_USB</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">			</span><span class="n">qphy</span><span class="o">-&gt;</span><span class="n">port_state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PORT_CHG_DET_DONE</span><span class="p">;</span><span class="w"></span>
<span class="w">		</span><span class="p">}</span><span class="w"></span>
<span class="w">		</span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="k">case</span><span class="w"> </span><span class="no">PORT_SECONDARY_IN_PROGRESS</span><span class="p">:</span><span class="w"></span>
<span class="w">		</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">vbus_active</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">			</span><span class="n">qphy</span><span class="o">-&gt;</span><span class="n">port_state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PORT_DISCONNECTED</span><span class="p">;</span><span class="w"></span>
<span class="w">			</span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">		</span><span class="p">}</span><span class="w"></span>

<span class="w">		</span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">qusb_phy_chg_det_status</span><span class="p">(</span><span class="n">qphy</span><span class="p">,</span><span class="w"> </span><span class="n">STATE_SECONDARY</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">status</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">			</span><span class="n">qusb_phy_notify_charger</span><span class="p">(</span><span class="n">qphy</span><span class="p">,</span><span class="w"></span>
<span class="w">						</span><span class="n">POWER_SUPPLY_TYPE_USB_DCP</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">			</span><span class="n">qusb_phy_notify_charger</span><span class="p">(</span><span class="n">qphy</span><span class="p">,</span><span class="w"></span>
<span class="w">						</span><span class="n">POWER_SUPPLY_TYPE_USB_CDP</span><span class="p">);</span><span class="w"></span>
<span class="w">			</span><span class="n">qusb_phy_notify_extcon</span><span class="p">(</span><span class="n">qphy</span><span class="p">,</span><span class="w"> </span><span class="n">EXTCON_USB</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="p">}</span><span class="w"></span>

<span class="w">		</span><span class="n">qusb_phy_unprepare_chg_det</span><span class="p">(</span><span class="n">qphy</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="n">qphy</span><span class="o">-&gt;</span><span class="n">port_state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PORT_CHG_DET_DONE</span><span class="p">;</span><span class="w"></span>
<span class="w">		</span><span class="cm">/*</span>
<span class="cm">		 * Fall through to check if cable got disconnected</span>
<span class="cm">		 * during detection.</span>
<span class="cm">		 */</span><span class="w"></span>
<span class="w">	</span><span class="k">case</span><span class="w"> </span><span class="no">PORT_CHG_DET_DONE</span><span class="p">:</span><span class="w"></span>
<span class="w">		</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">vbus_active</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">			</span><span class="n">qphy</span><span class="o">-&gt;</span><span class="n">port_state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PORT_UNKNOWN</span><span class="p">;</span><span class="w"></span>
<span class="w">			</span><span class="n">qusb_phy_notify_extcon</span><span class="p">(</span><span class="n">qphy</span><span class="p">,</span><span class="w"> </span><span class="n">EXTCON_USB</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="p">}</span><span class="w"></span>

<span class="w">		</span><span class="k">return</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="k">case</span><span class="w"> </span><span class="no">PORT_HOST_MODE</span><span class="p">:</span><span class="w"></span>
<span class="w">		</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">id_state</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">			</span><span class="n">qphy</span><span class="o">-&gt;</span><span class="n">port_state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PORT_UNKNOWN</span><span class="p">;</span><span class="w"></span>
<span class="w">			</span><span class="n">qusb_phy_notify_extcon</span><span class="p">(</span><span class="n">qphy</span><span class="p">,</span><span class="w"> </span><span class="n">EXTCON_USB_HOST</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="p">}</span><span class="w"></span>

<span class="w">		</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">qphy</span><span class="o">-&gt;</span><span class="n">vbus_active</span><span class="p">)</span><span class="w"></span>
<span class="w">			</span><span class="k">return</span><span class="p">;</span><span class="w"></span>

<span class="w">		</span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="k">default</span><span class="o">:</span><span class="w"></span>
<span class="w">		</span><span class="k">return</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>

<span class="w">	</span><span class="n">queue_delayed_work</span><span class="p">(</span><span class="n">system_freezable_wq</span><span class="p">,</span><span class="w"></span>
<span class="w">			</span><span class="o">&amp;</span><span class="n">qphy</span><span class="o">-&gt;</span><span class="n">port_det_w</span><span class="p">,</span><span class="w"> </span><span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">delay</span><span class="p">));</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="smblite-usb">
<h2>smblite usb设置充电类型接口<a class="headerlink" href="#smblite-usb" title="Permalink to this heading"></a></h2>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">drivers/power/supply/qcom/qpnp-smblite.c</span></code>:</p></li>
</ul>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">smblite_usb_set_prop</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">power_supply</span><span class="w"> </span><span class="o">*</span><span class="n">psy</span><span class="p">,</span><span class="w"></span>
<span class="w">		</span><span class="k">enum</span><span class="w"> </span><span class="nc">power_supply_property</span><span class="w"> </span><span class="n">psp</span><span class="p">,</span><span class="w"></span>
<span class="w">		</span><span class="k">const</span><span class="w"> </span><span class="k">union</span><span class="w"> </span><span class="nc">power_supply_propval</span><span class="w"> </span><span class="o">*</span><span class="n">val</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">psp</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="k">case</span><span class="w"> </span><span class="no">POWER_SUPPLY_PROP_REAL_TYPE</span><span class="p">:</span><span class="w"></span>
<span class="w">		</span><span class="n">rc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">smblite_lib_set_prop_usb_type</span><span class="p">(</span><span class="n">chg</span><span class="p">,</span><span class="w"> </span><span class="n">val</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="k">default</span><span class="o">:</span><span class="w"></span>
<span class="w">		</span><span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;set prop %d is not supported</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">psp</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="n">rc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span><span class="w"></span>
<span class="w">		</span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>

<span class="w">	</span><span class="k">return</span><span class="w"> </span><span class="n">rc</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">static</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">power_supply_desc</span><span class="w"> </span><span class="n">usb_psy_desc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;usb&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">	</span><span class="p">.</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">POWER_SUPPLY_TYPE_USB</span><span class="p">,</span><span class="w"></span>
<span class="w">	</span><span class="p">.</span><span class="n">properties</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">smblite_usb_props</span><span class="p">,</span><span class="w"></span>
<span class="w">	</span><span class="p">.</span><span class="n">num_properties</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">smblite_usb_props</span><span class="p">),</span><span class="w"></span>
<span class="w">	</span><span class="p">.</span><span class="n">get_property</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">smblite_usb_get_prop</span><span class="p">,</span><span class="w"></span>
<span class="w">	</span><span class="p">.</span><span class="n">set_property</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">smblite_usb_set_prop</span><span class="p">,</span><span class="w"></span>
<span class="w">	</span><span class="p">.</span><span class="n">property_is_writeable</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">smblite_usb_prop_is_writeable</span><span class="p">,</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">smblite_init_usb_psy</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">smblite</span><span class="w"> </span><span class="o">*</span><span class="n">chip</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="k">struct</span><span class="w"> </span><span class="nc">power_supply_config</span><span class="w"> </span><span class="n">usb_cfg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span><span class="w"></span>
<span class="w">	</span><span class="k">struct</span><span class="w"> </span><span class="nc">smb_charger</span><span class="w"> </span><span class="o">*</span><span class="n">chg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">chg</span><span class="p">;</span><span class="w"></span>

<span class="w">	</span><span class="n">usb_cfg</span><span class="p">.</span><span class="n">drv_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">chip</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">usb_cfg</span><span class="p">.</span><span class="n">of_node</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">chg</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">of_node</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">chg</span><span class="o">-&gt;</span><span class="n">usb_psy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">devm_power_supply_register</span><span class="p">(</span><span class="n">chg</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span><span class="w"></span>
<span class="w">						  </span><span class="o">&amp;</span><span class="n">usb_psy_desc</span><span class="p">,</span><span class="w"></span>
<span class="w">						  </span><span class="o">&amp;</span><span class="n">usb_cfg</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">chg</span><span class="o">-&gt;</span><span class="n">usb_psy</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Couldn&#39;t register USB power supply</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="k">return</span><span class="w"> </span><span class="n">PTR_ERR</span><span class="p">(</span><span class="n">chg</span><span class="o">-&gt;</span><span class="n">usb_psy</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>

<span class="w">	</span><span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;wugn test register USB power supply OK</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">smblite_probe</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">platform_device</span><span class="w"> </span><span class="o">*</span><span class="n">pdev</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="n">rc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">smblite_init_usb_psy</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">rc</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Couldn&#39;t initialize usb psy rc=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">rc</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="k">goto</span><span class="w"> </span><span class="n">cleanup</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
<section id="dw3usb">
<h1>DW3驱动设置USB主从模式<a class="headerlink" href="#dw3usb" title="Permalink to this heading"></a></h1>
<p>dw3驱动额注册了extcon notify，有2个notify接收主从切换信息，分别是<code class="docutils literal notranslate"><span class="pre">dwc3_msm_id_notifier</span></code>和<code class="docutils literal notranslate"><span class="pre">dwc3_msm_vbus_notifier</span></code>，主要是BC12检测完后，用来接收qusb phy的USB切换信息，当dw3接收到消息后都会启用工作队列<code class="docutils literal notranslate"><span class="pre">resume_work</span></code>,代码流程如下：</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span>static int dwc3_msm_probe(struct platform_device *pdev)
{
	INIT_WORK(&amp;mdwc-&gt;resume_work, dwc3_resume_work);

	if (of_property_read_bool(node, &quot;extcon&quot;)) {
		ret = dwc3_msm_extcon_register(mdwc);
		if (ret)
			goto put_dwc3;	
}

static int dwc3_msm_extcon_register(struct dwc3_msm *mdwc)
{
	extcon_cnt = of_count_phandle_with_args(node, &quot;extcon&quot;, NULL);
	mdwc-&gt;extcon = devm_kcalloc(mdwc-&gt;dev, extcon_cnt,
					sizeof(*mdwc-&gt;extcon), GFP_KERNEL);
	if (!mdwc-&gt;extcon)
		return -ENOMEM;	

	for (idx = 0; idx &lt; extcon_cnt; idx++) {
		edev = extcon_get_edev_by_phandle(mdwc-&gt;dev, idx);
		if (IS_ERR(edev) &amp;&amp; PTR_ERR(edev) != -ENODEV)
			return PTR_ERR(edev);

		if (IS_ERR_OR_NULL(edev))
			continue;

		check_vbus_state = check_id_state = true;
		phandle_found = true;

		mdwc-&gt;extcon[idx].mdwc = mdwc;
		mdwc-&gt;extcon[idx].edev = edev;
		mdwc-&gt;extcon[idx].idx = idx;

		mdwc-&gt;extcon[idx].vbus_nb.notifier_call =
						dwc3_msm_vbus_notifier;
		ret = extcon_register_notifier(edev, EXTCON_USB,
						&amp;mdwc-&gt;extcon[idx].vbus_nb);
		if (ret &lt; 0)
			check_vbus_state = false;

		mdwc-&gt;extcon[idx].id_nb.notifier_call = dwc3_msm_id_notifier;
		ret = extcon_register_notifier(edev, EXTCON_USB_HOST,
						&amp;mdwc-&gt;extcon[idx].id_nb);
		if (ret &lt; 0)
			check_id_state = false;

		mdwc-&gt;extcon[idx].blocking_sync_nb.notifier_call =
					dwc3_usb_blocking_sync;
		extcon_register_blocking_notifier(edev, EXTCON_USB_HOST,
					&amp;mdwc-&gt;extcon[idx].blocking_sync_nb);

		/* Update initial VBUS/ID state */
		if (check_vbus_state &amp;&amp; extcon_get_state(edev, EXTCON_USB))
			dwc3_msm_vbus_notifier(&amp;mdwc-&gt;extcon[idx].vbus_nb,
						true, edev);
		else  if (check_id_state &amp;&amp;
				extcon_get_state(edev, EXTCON_USB_HOST))
			dwc3_msm_id_notifier(&amp;mdwc-&gt;extcon[idx].id_nb,
						true, edev);
	}

}

这里主要绑定了两个notify：
EXTCON_USB_HOST:
static int dwc3_msm_id_notifier(struct notifier_block *nb,
	unsigned long event, void *ptr)
{
	struct dwc3 *dwc;
	struct extcon_dev *edev = ptr;
	struct extcon_nb *enb = container_of(nb, struct extcon_nb, id_nb);
	struct dwc3_msm *mdwc = enb-&gt;mdwc;
	enum dwc3_id_state id;

	if (!edev || !mdwc)
		return NOTIFY_DONE;

	dwc = platform_get_drvdata(mdwc-&gt;dwc3);

	dbg_event(0xFF, &quot;extcon idx&quot;, enb-&gt;idx);

	id = event ? DWC3_ID_GROUND : DWC3_ID_FLOAT;

	if (mdwc-&gt;id_state == id)
		return NOTIFY_DONE;

	mdwc-&gt;ext_idx = enb-&gt;idx;

	dev_err(mdwc-&gt;dev, &quot;host:%ld (id:%d) event received\n&quot;, event, id);

	mdwc-&gt;id_state = id;
	dbg_event(0xFF, &quot;id_state&quot;, mdwc-&gt;id_state);
	queue_work(mdwc-&gt;dwc3_wq, &amp;mdwc-&gt;resume_work);

	return NOTIFY_DONE;
}

EXTCON_USB:
static int dwc3_msm_vbus_notifier(struct notifier_block *nb,
	unsigned long event, void *ptr)
{
	struct dwc3 *dwc;
	struct extcon_dev *edev = ptr;
	struct extcon_nb *enb = container_of(nb, struct extcon_nb, vbus_nb);
	struct dwc3_msm *mdwc = enb-&gt;mdwc;
	char *eud_str;
	const char *edev_name;

	if (!edev || !mdwc)
		return NOTIFY_DONE;

	dwc = platform_get_drvdata(mdwc-&gt;dwc3);

	dbg_event(0xFF, &quot;extcon idx&quot;, enb-&gt;idx);
	dev_err(mdwc-&gt;dev, &quot;vbus:%ld event received\n&quot;, event);
	edev_name = extcon_get_edev_name(edev);
	dev_err(mdwc-&gt;dev,&quot;edev:%s\n&quot;, edev_name);

	/* detect USB spoof disconnect/connect notification with EUD device */
	eud_str = strnstr(edev_name, &quot;eud&quot;, strlen(edev_name));
	if (eud_str) {
		if (mdwc-&gt;eud_active == event)
			return NOTIFY_DONE;
		mdwc-&gt;eud_active = event;
		mdwc-&gt;check_eud_state = true;
	} else {
		if (mdwc-&gt;vbus_active == event)
			return NOTIFY_DONE;
		mdwc-&gt;vbus_active = event;
	}

	/*
	 * Drive a pulse on DP to ensure proper CDP detection
	 * and only when the vbus connect event is a valid one.
	 */
	if (get_psy_type(mdwc) == POWER_SUPPLY_TYPE_USB_CDP &amp;&amp;
			mdwc-&gt;vbus_active &amp;&amp; !mdwc-&gt;check_eud_state) {
		dev_err(mdwc-&gt;dev, &quot;Connected to CDP, pull DP up\n&quot;);
		usb_phy_drive_dp_pulse(mdwc-&gt;hs_phy, DP_PULSE_WIDTH_MSEC);
	}

	if (dwc3_is_otg_or_drd(dwc) &amp;&amp; !mdwc-&gt;in_restart)
		queue_work(mdwc-&gt;dwc3_wq, &amp;mdwc-&gt;resume_work);

	return NOTIFY_DONE;
}
</pre></div>
</div>
<section id="resume-work">
<h2>resume_work主从切换原理<a class="headerlink" href="#resume-work" title="Permalink to this heading"></a></h2>
<p>USB主从切换主要是通过resume_work工作队列来完成，</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span>* dwc3_resume_work
  * dwc3_msm_resume(mdwc); //设置usb phy
  * dwc3_ext_event_notify(mdwc);//启动工作队列切主从
    * queue_delayed_work(mdwc-&gt;sm_usb_wq, &amp;mdwc-&gt;sm_work, 0);
	  * dwc3_otg_sm_work(struct work_struct *w)
        * dwc3_otg_start_peripheral(mdwc, 1); //从
        * dwc3_otg_start_host(mdwc, 1); //主
static void dwc3_resume_work(struct work_struct *w)
{
	struct dwc3_msm *mdwc = container_of(w, struct dwc3_msm, resume_work);
	struct dwc3 *dwc = platform_get_drvdata(mdwc-&gt;dwc3);
	union extcon_property_value val;
	unsigned int extcon_id;
	struct extcon_dev *edev = NULL;
	const char *edev_name;
	char *eud_str;
	int ret = 0;

	dev_dbg(mdwc-&gt;dev, &quot;%s: dwc3 resume work\n&quot;, __func__);
	if (mdwc-&gt;extcon &amp;&amp; mdwc-&gt;vbus_active &amp;&amp; !mdwc-&gt;in_restart) {
		extcon_id = EXTCON_USB; //从
		edev = mdwc-&gt;extcon[mdwc-&gt;ext_idx].edev;
	} else if (mdwc-&gt;extcon &amp;&amp; mdwc-&gt;id_state == DWC3_ID_GROUND) {
		extcon_id = EXTCON_USB_HOST; //主
		edev = mdwc-&gt;extcon[mdwc-&gt;ext_idx].edev;
	}

	if (edev) {
		edev_name = extcon_get_edev_name(edev);
		dbg_log_string(&quot;edev:%s\n&quot;, edev_name);
		/* Skip querying speed and cc_state for EUD edev */
		eud_str = strnstr(edev_name, &quot;eud&quot;, strlen(edev_name));
		if (eud_str)
			goto skip_update;
	}

	dwc-&gt;maximum_speed = dwc-&gt;max_hw_supp_speed;
	/* Check speed and Type-C polarity values in order to configure PHY */
	if (edev &amp;&amp; extcon_get_state(edev, extcon_id)) {
		ret = extcon_get_property(edev, extcon_id,
				EXTCON_PROP_USB_SS, &amp;val);

		if (!ret &amp;&amp; val.intval == 0)
			dwc-&gt;maximum_speed = USB_SPEED_HIGH;

		ret = extcon_get_property(edev, extcon_id,
				EXTCON_PROP_USB_TYPEC_POLARITY, &amp;val);
		if (ret)
			mdwc-&gt;typec_orientation = ORIENTATION_NONE;
		else
			mdwc-&gt;typec_orientation = val.intval ?
					ORIENTATION_CC2 : ORIENTATION_CC1;

		dbg_event(0xFF, &quot;cc_state&quot;, mdwc-&gt;typec_orientation);

		ret = extcon_get_property(edev, extcon_id,
				EXTCON_PROP_USB_TYPEC_MED_HIGH_CURRENT, &amp;val);
		if (!ret)
			dwc-&gt;gadget.is_selfpowered = val.intval;
		else
			dwc-&gt;gadget.is_selfpowered = 0;
	}

skip_update:
	dbg_log_string(&quot;max_speed:%d hw_supp_speed:%d override_speed:%d&quot;,
		dwc-&gt;maximum_speed, dwc-&gt;max_hw_supp_speed,
		mdwc-&gt;override_usb_speed);
	if (mdwc-&gt;override_usb_speed &amp;&amp;
			mdwc-&gt;override_usb_speed &lt;= dwc-&gt;maximum_speed) {
		dwc-&gt;maximum_speed = mdwc-&gt;override_usb_speed;
		dwc-&gt;gadget.max_speed = dwc-&gt;maximum_speed;
	}

	dbg_event(0xFF, &quot;speed&quot;, dwc-&gt;maximum_speed);

	/*
	 * Skip scheduling sm work if no work is pending. When boot-up
	 * with USB cable connected, usb state m/c is skipped to avoid
	 * any changes to dp/dm lines. As PM supsend and resume can
	 * happen while charger is connected, scheduling sm work during
	 * pm resume will reset the controller and phy which might impact
	 * dp/dm lines (and charging voltage).
	 */
	if (mdwc-&gt;drd_state == DRD_STATE_UNDEFINED &amp;&amp;
		!edev &amp;&amp; !mdwc-&gt;resume_pending)
		return;
	/*
	 * exit LPM first to meet resume timeline from device side.
	 * resume_pending flag would prevent calling
	 * dwc3_msm_resume() in case we are here due to system
	 * wide resume without usb cable connected. This flag is set
	 * only in case of power event irq in lpm.
	 */
	if (mdwc-&gt;resume_pending) {
		dwc3_msm_resume(mdwc);
		mdwc-&gt;resume_pending = false;
	}

	if (atomic_read(&amp;mdwc-&gt;pm_suspended)) {
		dbg_event(0xFF, &quot;RWrk PMSus&quot;, 0);
		/* let pm resume kick in resume work later */
		return;
	}
	dwc3_ext_event_notify(mdwc);
}

设置usb phy：
static int dwc3_msm_resume(struct dwc3_msm *mdwc)
{
	int ret;
	long core_clk_rate;
	struct dwc3 *dwc = platform_get_drvdata(mdwc-&gt;dwc3);
	struct usb_irq *uirq;

	dev_dbg(mdwc-&gt;dev, &quot;%s: exiting lpm\n&quot;, __func__);

	/*
	 * If h/w exited LPM without any events, ensure
	 * h/w is reset before processing any new events.
	 */
	if (!mdwc-&gt;vbus_active &amp;&amp; mdwc-&gt;id_state)
		set_bit(WAIT_FOR_LPM, &amp;mdwc-&gt;inputs);

	mutex_lock(&amp;mdwc-&gt;suspend_resume_mutex);
	if (!atomic_read(&amp;dwc-&gt;in_lpm)) {
		dev_dbg(mdwc-&gt;dev, &quot;%s: Already resumed\n&quot;, __func__);
		mutex_unlock(&amp;mdwc-&gt;suspend_resume_mutex);
		return 0;
	}

	pm_stay_awake(mdwc-&gt;dev);

	if (mdwc-&gt;in_host_mode &amp;&amp; mdwc-&gt;max_rh_port_speed == USB_SPEED_HIGH)
		dwc3_msm_update_bus_bw(mdwc, BUS_VOTE_SVS);
	else
		dwc3_msm_update_bus_bw(mdwc, mdwc-&gt;default_bus_vote);

	/* Vote for TCXO while waking up USB HSPHY */
	ret = clk_prepare_enable(mdwc-&gt;xo_clk);
	if (ret)
		dev_err(mdwc-&gt;dev, &quot;%s failed to vote TCXO buffer%d\n&quot;,
						__func__, ret);

	/* Restore controller power collapse */
	if (mdwc-&gt;lpm_flags &amp; MDWC3_POWER_COLLAPSE) {
		dev_dbg(mdwc-&gt;dev, &quot;%s: exit power collapse\n&quot;, __func__);
		dwc3_msm_config_gdsc(mdwc, 1);
		ret = reset_control_assert(mdwc-&gt;core_reset);
		if (ret)
			dev_err(mdwc-&gt;dev, &quot;%s:core_reset assert failed\n&quot;,
					__func__);
		/* HW requires a short delay for reset to take place properly */
		usleep_range(1000, 1200);
		ret = reset_control_deassert(mdwc-&gt;core_reset);
		if (ret)
			dev_err(mdwc-&gt;dev, &quot;%s:core_reset deassert failed\n&quot;,
					__func__);
		clk_prepare_enable(mdwc-&gt;sleep_clk);
	} else if (dwc-&gt;gdsc_collapse_in_host_suspend &amp;&amp; mdwc-&gt;in_host_mode) {
		dev_dbg(mdwc-&gt;dev, &quot;Turn on GDSC in host mode bus resume\n&quot;);
		dwc3_msm_config_gdsc(mdwc, 1);
	}


	/*
	 * Enable clocks
	 * Turned ON iface_clk before core_clk due to FSM depedency.
	 */
	clk_prepare_enable(mdwc-&gt;iface_clk);
	if (mdwc-&gt;noc_aggr_clk)
		clk_prepare_enable(mdwc-&gt;noc_aggr_clk);

	core_clk_rate = mdwc-&gt;core_clk_rate;
	if (mdwc-&gt;in_host_mode &amp;&amp; mdwc-&gt;max_rh_port_speed == USB_SPEED_HIGH) {
		core_clk_rate = mdwc-&gt;core_clk_rate_hs;
		dev_dbg(mdwc-&gt;dev, &quot;%s: set hs core clk rate %ld\n&quot;, __func__,
			core_clk_rate);
	}

	clk_set_rate(mdwc-&gt;core_clk, core_clk_rate);
	clk_prepare_enable(mdwc-&gt;core_clk);

	/* set Memory core: ON, Memory periphery: ON */
	clk_set_flags(mdwc-&gt;core_clk, CLKFLAG_RETAIN_MEM);
	clk_set_flags(mdwc-&gt;core_clk, CLKFLAG_RETAIN_PERIPH);

	clk_prepare_enable(mdwc-&gt;utmi_clk);
	if (mdwc-&gt;bus_aggr_clk)
		clk_prepare_enable(mdwc-&gt;bus_aggr_clk);

	/*
	 * Disable any wakeup events that were enabled if pwr_event_irq
	 * is used as wakeup interrupt.
	 */
	if (mdwc-&gt;lpm_flags &amp; MDWC3_USE_PWR_EVENT_IRQ_FOR_WAKEUP) {
		disable_irq_nosync(mdwc-&gt;wakeup_irq[PWR_EVNT_IRQ].irq);
		dwc3_msm_set_pwr_events(mdwc, false);
		mdwc-&gt;lpm_flags &amp;= ~MDWC3_USE_PWR_EVENT_IRQ_FOR_WAKEUP;
	}

	/* Resume SS PHY */
	if (dwc-&gt;maximum_speed &gt;= USB_SPEED_SUPER &amp;&amp;
			mdwc-&gt;lpm_flags &amp; MDWC3_SS_PHY_SUSPEND) {
		mdwc-&gt;ss_phy-&gt;flags &amp;= ~(PHY_LANE_A | PHY_LANE_B);
		if (mdwc-&gt;orientation_override)
			mdwc-&gt;ss_phy-&gt;flags |= mdwc-&gt;orientation_override;
		else if (mdwc-&gt;typec_orientation == ORIENTATION_CC1)
			mdwc-&gt;ss_phy-&gt;flags |= PHY_LANE_A;
		else if (mdwc-&gt;typec_orientation == ORIENTATION_CC2)
			mdwc-&gt;ss_phy-&gt;flags |= PHY_LANE_B;
		usb_phy_set_suspend(mdwc-&gt;ss_phy, 0);
		mdwc-&gt;ss_phy-&gt;flags &amp;= ~DEVICE_IN_SS_MODE;
		mdwc-&gt;lpm_flags &amp;= ~MDWC3_SS_PHY_SUSPEND;

		if (mdwc-&gt;in_host_mode) {
			u32 reg = dwc3_readl(dwc-&gt;regs, DWC3_GUSB3PIPECTL(0));

			reg &amp;= ~DWC3_GUSB3PIPECTL_DISRXDETU3;
			dwc3_writel(dwc-&gt;regs, DWC3_GUSB3PIPECTL(0), reg);
		}
	}

	mdwc-&gt;hs_phy-&gt;flags &amp;= ~(PHY_HSFS_MODE | PHY_LS_MODE);
	/* Resume HS PHY */
	usb_phy_set_suspend(mdwc-&gt;hs_phy, 0);

	/* Recover from controller power collapse */
	if (mdwc-&gt;lpm_flags &amp; MDWC3_POWER_COLLAPSE) {
		dev_dbg(mdwc-&gt;dev, &quot;%s: exit power collapse\n&quot;, __func__);

		dwc3_msm_power_collapse_por(mdwc);

		mdwc-&gt;lpm_flags &amp;= ~MDWC3_POWER_COLLAPSE;
	}

	atomic_set(&amp;dwc-&gt;in_lpm, 0);

	/* enable power evt irq for IN P3 detection */
	enable_irq(mdwc-&gt;wakeup_irq[PWR_EVNT_IRQ].irq);

	/* Disable HSPHY auto suspend */
	dwc3_msm_write_reg(mdwc-&gt;base, DWC3_GUSB2PHYCFG(0),
		dwc3_msm_read_reg(mdwc-&gt;base, DWC3_GUSB2PHYCFG(0)) &amp;
				~DWC3_GUSB2PHYCFG_SUSPHY);

	/* Disable wakeup capable for HS_PHY IRQ &amp; SS_PHY_IRQ if enabled */
	if (mdwc-&gt;lpm_flags &amp; MDWC3_ASYNC_IRQ_WAKE_CAPABILITY) {
		if (mdwc-&gt;use_pdc_interrupts ||
			!mdwc-&gt;wakeup_irq[HS_PHY_IRQ].irq) {
			configure_usb_wakeup_interrupts(mdwc, false);
		} else {
			uirq = &amp;mdwc-&gt;wakeup_irq[HS_PHY_IRQ];
			configure_nonpdc_usb_interrupt(mdwc, uirq, false);
			uirq = &amp;mdwc-&gt;wakeup_irq[SS_PHY_IRQ];
			configure_nonpdc_usb_interrupt(mdwc, uirq, false);
		}
		mdwc-&gt;lpm_flags &amp;= ~MDWC3_ASYNC_IRQ_WAKE_CAPABILITY;
	}

	dev_info(mdwc-&gt;dev, &quot;DWC3 exited from low power mode\n&quot;);

	/* Enable core irq */
	if (dwc-&gt;irq)
		enable_irq(dwc-&gt;irq);

	/*
	 * Handle other power events that could not have been handled during
	 * Low Power Mode
	 */
	dwc3_pwr_event_handler(mdwc);

	if (pm_qos_request_active(&amp;mdwc-&gt;pm_qos_req_dma))
		schedule_delayed_work(&amp;mdwc-&gt;perf_vote_work,
			msecs_to_jiffies(1000 * PM_QOS_SAMPLE_SEC));

	dbg_event(0xFF, &quot;Ctl Res&quot;, atomic_read(&amp;dwc-&gt;in_lpm));
	mutex_unlock(&amp;mdwc-&gt;suspend_resume_mutex);

	return 0;
}

主从切换实际是sm_work做的：
static void dwc3_ext_event_notify(struct dwc3_msm *mdwc)
{
	/* Flush processing any pending events before handling new ones */
	flush_delayed_work(&amp;mdwc-&gt;sm_work);

	if (mdwc-&gt;id_state == DWC3_ID_FLOAT) {
		dev_dbg(mdwc-&gt;dev, &quot;XCVR: ID set\n&quot;);
		set_bit(ID, &amp;mdwc-&gt;inputs);
	} else {
		dev_dbg(mdwc-&gt;dev, &quot;XCVR: ID clear\n&quot;);
		clear_bit(ID, &amp;mdwc-&gt;inputs);
	}

	if (mdwc-&gt;vbus_active &amp;&amp; !mdwc-&gt;in_restart) {
		if (mdwc-&gt;hs_phy-&gt;flags &amp; EUD_SPOOF_DISCONNECT) {
			dev_dbg(mdwc-&gt;dev, &quot;XCVR:EUD: BSV clear\n&quot;);
			clear_bit(B_SESS_VLD, &amp;mdwc-&gt;inputs);
		} else {
			dev_dbg(mdwc-&gt;dev, &quot;XCVR: BSV set\n&quot;);
			set_bit(B_SESS_VLD, &amp;mdwc-&gt;inputs);
		}
	} else {
		dev_dbg(mdwc-&gt;dev, &quot;XCVR: BSV clear\n&quot;);
		clear_bit(B_SESS_VLD, &amp;mdwc-&gt;inputs);
	}

	if (mdwc-&gt;suspend) {
		dev_dbg(mdwc-&gt;dev, &quot;XCVR: SUSP set\n&quot;);
		set_bit(B_SUSPEND, &amp;mdwc-&gt;inputs);
	} else {
		dev_dbg(mdwc-&gt;dev, &quot;XCVR: SUSP clear\n&quot;);
		clear_bit(B_SUSPEND, &amp;mdwc-&gt;inputs);
	}

	if (mdwc-&gt;check_eud_state) {
		mdwc-&gt;hs_phy-&gt;flags &amp;=
			~(EUD_SPOOF_CONNECT | EUD_SPOOF_DISCONNECT);
		dev_dbg(mdwc-&gt;dev, &quot;eud: state:%d active:%d hs_phy_flags:0x%x\n&quot;,
			mdwc-&gt;check_eud_state, mdwc-&gt;eud_active,
			mdwc-&gt;hs_phy-&gt;flags);
		if (mdwc-&gt;eud_active) {
			mdwc-&gt;hs_phy-&gt;flags |= EUD_SPOOF_CONNECT;
			dev_dbg(mdwc-&gt;dev, &quot;EUD: XCVR: BSV set\n&quot;);
			set_bit(B_SESS_VLD, &amp;mdwc-&gt;inputs);
		} else {
			mdwc-&gt;hs_phy-&gt;flags |= EUD_SPOOF_DISCONNECT;
			dev_dbg(mdwc-&gt;dev, &quot;EUD: XCVR: BSV clear\n&quot;);
			clear_bit(B_SESS_VLD, &amp;mdwc-&gt;inputs);
		}

		mdwc-&gt;check_eud_state = false;
	}


	dev_dbg(mdwc-&gt;dev, &quot;eud: state:%d active:%d hs_phy_flags:0x%x\n&quot;,
		mdwc-&gt;check_eud_state, mdwc-&gt;eud_active, mdwc-&gt;hs_phy-&gt;flags);

	/* handle case of USB cable disconnect after USB spoof disconnect */
	if (!mdwc-&gt;vbus_active &amp;&amp;
			(mdwc-&gt;hs_phy-&gt;flags &amp; EUD_SPOOF_DISCONNECT)) {
		mdwc-&gt;hs_phy-&gt;flags &amp;= ~EUD_SPOOF_DISCONNECT;
		mdwc-&gt;hs_phy-&gt;flags |= PHY_SUS_OVERRIDE;
		usb_phy_set_suspend(mdwc-&gt;hs_phy, 1);
		mdwc-&gt;hs_phy-&gt;flags &amp;= ~PHY_SUS_OVERRIDE;
		return;
	}

	queue_delayed_work(mdwc-&gt;sm_usb_wq, &amp;mdwc-&gt;sm_work, 0);
}

* INIT_DELAYED_WORK(&amp;mdwc-&gt;sm_work, dwc3_otg_sm_work);
  * queue_delayed_work(mdwc-&gt;sm_usb_wq, &amp;mdwc-&gt;sm_work, 0);
    * dwc3_otg_sm_work
/**
 * dwc3_otg_sm_work - workqueue function.
 *
 * @w: Pointer to the dwc3 otg workqueue
 *
 * NOTE: After any change in drd_state, we must reschdule the state machine.
 */

static void dwc3_otg_sm_work(struct work_struct *w)
{
	struct dwc3_msm *mdwc = container_of(w, struct dwc3_msm, sm_work.work);
	struct dwc3 *dwc = NULL;
	bool work = 0;
	int ret = 0;
	unsigned long delay = 0;
	const char *state;

	if (mdwc-&gt;dwc3)
		dwc = platform_get_drvdata(mdwc-&gt;dwc3);

	if (!dwc) {
		dev_err(mdwc-&gt;dev, &quot;dwc is NULL.\n&quot;);
		return;
	}

	state = dwc3_drd_state_string(mdwc-&gt;drd_state);
	dev_dbg(mdwc-&gt;dev, &quot;%s state\n&quot;, state);
	dbg_event(0xFF, state, 0);

	/* Check OTG state */
	switch (mdwc-&gt;drd_state) {
	case DRD_STATE_UNDEFINED:
		if (mdwc-&gt;dpdm_nb.notifier_call) {
			regulator_unregister_notifier(mdwc-&gt;dpdm_reg,
					&amp;mdwc-&gt;dpdm_nb);
			mdwc-&gt;dpdm_nb.notifier_call = NULL;
		}

		/* put controller and phy in suspend if no cable connected */
		if (test_bit(ID, &amp;mdwc-&gt;inputs) &amp;&amp;
				!test_bit(B_SESS_VLD, &amp;mdwc-&gt;inputs)) {
			dbg_event(0xFF, &quot;undef_id_!bsv&quot;, 0);
			pm_runtime_set_active(mdwc-&gt;dev);
			pm_runtime_enable(mdwc-&gt;dev);
			pm_runtime_get_noresume(mdwc-&gt;dev);
			dwc3_msm_resume(mdwc);
			pm_runtime_put_sync(mdwc-&gt;dev);
			dbg_event(0xFF, &quot;Undef NoUSB&quot;,
				atomic_read(&amp;mdwc-&gt;dev-&gt;power.usage_count));
			mdwc-&gt;drd_state = DRD_STATE_IDLE;
			break;
		}

		dbg_event(0xFF, &quot;Exit UNDEF&quot;, 0);
		mdwc-&gt;drd_state = DRD_STATE_IDLE;
		pm_runtime_set_suspended(mdwc-&gt;dev);
		pm_runtime_enable(mdwc-&gt;dev);
		/* fall-through */
	case DRD_STATE_IDLE:
		if (test_bit(WAIT_FOR_LPM, &amp;mdwc-&gt;inputs)) {
			dev_dbg(mdwc-&gt;dev, &quot;still not in lpm, wait.\n&quot;);
			break;
		}

		if (!test_bit(ID, &amp;mdwc-&gt;inputs)) {
			dev_dbg(mdwc-&gt;dev, &quot;!id\n&quot;);
			mdwc-&gt;drd_state = DRD_STATE_HOST_IDLE;
			work = 1;
		} else if (test_bit(B_SESS_VLD, &amp;mdwc-&gt;inputs)) {
			dev_dbg(mdwc-&gt;dev, &quot;b_sess_vld\n&quot;);
			if (get_psy_type(mdwc) == POWER_SUPPLY_TYPE_USB_FLOAT)
				queue_delayed_work(mdwc-&gt;dwc3_wq,
						&amp;mdwc-&gt;sdp_check,
				msecs_to_jiffies(SDP_CONNETION_CHECK_TIME));

			/*
			 * Increment pm usage count upon cable connect. Count
			 * is decremented in DRD_STATE_PERIPHERAL state on
			 * cable disconnect or in bus suspend.
			 */
			pm_runtime_get_sync(mdwc-&gt;dev);
			dbg_event(0xFF, &quot;BIDLE gsync&quot;,
				atomic_read(&amp;mdwc-&gt;dev-&gt;power.usage_count));
			dwc3_otg_start_peripheral(mdwc, 1);
			mdwc-&gt;drd_state = DRD_STATE_PERIPHERAL;
			work = 1;
		} else {
			dwc3_msm_gadget_vbus_draw(mdwc, 0);
			dev_dbg(mdwc-&gt;dev, &quot;Cable disconnected\n&quot;);
		}
		break;

	case DRD_STATE_PERIPHERAL:
		if (!test_bit(B_SESS_VLD, &amp;mdwc-&gt;inputs) ||
				!test_bit(ID, &amp;mdwc-&gt;inputs)) {
			dev_dbg(mdwc-&gt;dev, &quot;!id || !bsv\n&quot;);
			mdwc-&gt;drd_state = DRD_STATE_IDLE;
			cancel_delayed_work_sync(&amp;mdwc-&gt;sdp_check);
			dwc3_otg_start_peripheral(mdwc, 0);
			/*
			 * Decrement pm usage count upon cable disconnect
			 * which was incremented upon cable connect in
			 * DRD_STATE_IDLE state
			 */
			pm_runtime_put_sync_suspend(mdwc-&gt;dev);
			dbg_event(0xFF, &quot;!BSV psync&quot;,
				atomic_read(&amp;mdwc-&gt;dev-&gt;power.usage_count));
			work = 1;
		} else if (test_bit(B_SUSPEND, &amp;mdwc-&gt;inputs) &amp;&amp;
			test_bit(B_SESS_VLD, &amp;mdwc-&gt;inputs)) {
			dev_dbg(mdwc-&gt;dev, &quot;BPER bsv &amp;&amp; susp\n&quot;);
			mdwc-&gt;drd_state = DRD_STATE_PERIPHERAL_SUSPEND;
			/*
			 * Decrement pm usage count upon bus suspend.
			 * Count was incremented either upon cable
			 * connect in DRD_STATE_IDLE or host
			 * initiated resume after bus suspend in
			 * DRD_STATE_PERIPHERAL_SUSPEND state
			 */
			pm_runtime_mark_last_busy(mdwc-&gt;dev);
			pm_runtime_put_autosuspend(mdwc-&gt;dev);
			dbg_event(0xFF, &quot;SUSP put&quot;,
				atomic_read(&amp;mdwc-&gt;dev-&gt;power.usage_count));
		}
		break;

	case DRD_STATE_PERIPHERAL_SUSPEND:
		if (!test_bit(B_SESS_VLD, &amp;mdwc-&gt;inputs)) {
			dev_dbg(mdwc-&gt;dev, &quot;BSUSP: !bsv\n&quot;);
			mdwc-&gt;drd_state = DRD_STATE_IDLE;
			cancel_delayed_work_sync(&amp;mdwc-&gt;sdp_check);
			dwc3_otg_start_peripheral(mdwc, 0);
		} else if (!test_bit(B_SUSPEND, &amp;mdwc-&gt;inputs)) {
			dev_dbg(mdwc-&gt;dev, &quot;BSUSP !susp\n&quot;);
			mdwc-&gt;drd_state = DRD_STATE_PERIPHERAL;
			/*
			 * Increment pm usage count upon host
			 * initiated resume. Count was decremented
			 * upon bus suspend in
			 * DRD_STATE_PERIPHERAL state.
			 */
			pm_runtime_get_sync(mdwc-&gt;dev);
			dbg_event(0xFF, &quot;!SUSP gsync&quot;,
				atomic_read(&amp;mdwc-&gt;dev-&gt;power.usage_count));
		}
		break;

	case DRD_STATE_HOST_IDLE:
		/* Switch to A-Device*/
		if (test_bit(ID, &amp;mdwc-&gt;inputs)) {
			dev_dbg(mdwc-&gt;dev, &quot;id\n&quot;);
			mdwc-&gt;drd_state = DRD_STATE_IDLE;
			mdwc-&gt;vbus_retry_count = 0;
			work = 1;
		} else {
			ret = dwc3_otg_start_host(mdwc, 1);
			if ((ret == -EPROBE_DEFER) &amp;&amp;
						mdwc-&gt;vbus_retry_count &lt; 3) {
				/*
				 * Get regulator failed as regulator driver is
				 * not up yet. Will try to start host after 1sec
				 */
				dev_dbg(mdwc-&gt;dev, &quot;Unable to get vbus regulator. Retrying...\n&quot;);
				delay = VBUS_REG_CHECK_DELAY;
				work = 1;
				mdwc-&gt;vbus_retry_count++;
			} else if (ret) {
				dev_err(mdwc-&gt;dev, &quot;unable to start host\n&quot;);
				goto ret;
			} else {
				mdwc-&gt;drd_state = DRD_STATE_HOST;
			}
		}
		break;

	case DRD_STATE_HOST:
		if (test_bit(ID, &amp;mdwc-&gt;inputs) || mdwc-&gt;hc_died) {
			dev_dbg(mdwc-&gt;dev, &quot;id || hc_died\n&quot;);
			dwc3_otg_start_host(mdwc, 0);
			mdwc-&gt;drd_state = DRD_STATE_IDLE;
			mdwc-&gt;vbus_retry_count = 0;
			mdwc-&gt;hc_died = false;
			work = 1;
		} else {
			dev_dbg(mdwc-&gt;dev, &quot;still in a_host state. Resuming root hub.\n&quot;);
			dbg_event(0xFF, &quot;XHCIResume&quot;, 0);
			if (dwc)
				pm_runtime_resume(&amp;dwc-&gt;xhci-&gt;dev);
		}
		break;

	default:
		dev_err(mdwc-&gt;dev, &quot;%s: invalid otg-state\n&quot;, __func__);

	}

	if (work)
		queue_delayed_work(mdwc-&gt;sm_usb_wq, &amp;mdwc-&gt;sm_work, delay);

ret:
	return;
}
</pre></div>
</div>
<p>以上得知主从切换的主要函数是<code class="docutils literal notranslate"><span class="pre">dwc3_otg_start_peripheral</span></code>和<code class="docutils literal notranslate"><span class="pre">dwc3_otg_start_host</span></code>。</p>
<p>具体看一下干了些什么：</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * dwc3_otg_start_host -  helper function for starting/stoping the host</span>
<span class="cm"> * controller driver.</span>
<span class="cm"> *</span>
<span class="cm"> * @mdwc: Pointer to the dwc3_msm structure.</span>
<span class="cm"> * @on: start / stop the host controller driver.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success otherwise negative errno.</span>
<span class="cm"> */</span><span class="w"></span>
<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">dwc3_otg_start_host</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">dwc3_msm</span><span class="w"> </span><span class="o">*</span><span class="n">mdwc</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">on</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="k">struct</span><span class="w"> </span><span class="nc">dwc3</span><span class="w"> </span><span class="o">*</span><span class="n">dwc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">platform_get_drvdata</span><span class="p">(</span><span class="n">mdwc</span><span class="o">-&gt;</span><span class="n">dwc3</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="kt">int</span><span class="w"> </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="w">	</span><span class="cm">/*</span>
<span class="cm">	 * The vbus_reg pointer could have multiple values</span>
<span class="cm">	 * NULL: regulator_get() hasn&#39;t been called, or was previously deferred</span>
<span class="cm">	 * IS_ERR: regulator could not be obtained, so skip using it</span>
<span class="cm">	 * Valid pointer otherwise</span>
<span class="cm">	 */</span><span class="w"></span>
<span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">mdwc</span><span class="o">-&gt;</span><span class="n">vbus_reg</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="n">mdwc</span><span class="o">-&gt;</span><span class="n">vbus_reg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">devm_regulator_get_optional</span><span class="p">(</span><span class="n">mdwc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span><span class="w"></span>
<span class="w">					</span><span class="s">&quot;vbus_dwc3&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">mdwc</span><span class="o">-&gt;</span><span class="n">vbus_reg</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"></span>
<span class="w">				</span><span class="n">PTR_ERR</span><span class="p">(</span><span class="n">mdwc</span><span class="o">-&gt;</span><span class="n">vbus_reg</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="o">-</span><span class="n">EPROBE_DEFER</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">			</span><span class="cm">/* regulators may not be ready, so retry again later */</span><span class="w"></span>
<span class="w">			</span><span class="n">mdwc</span><span class="o">-&gt;</span><span class="n">vbus_reg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>
<span class="w">			</span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="n">EPROBE_DEFER</span><span class="p">;</span><span class="w"></span>
<span class="w">		</span><span class="p">}</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>

<span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">on</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="n">dev_dbg</span><span class="p">(</span><span class="n">mdwc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;%s: turn on host</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">__func__</span><span class="p">);</span><span class="w"></span>

<span class="w">		</span><span class="n">mdwc</span><span class="o">-&gt;</span><span class="n">hs_phy</span><span class="o">-&gt;</span><span class="n">flags</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">PHY_HOST_MODE</span><span class="p">;</span><span class="w"></span>
<span class="w">		</span><span class="n">pm_runtime_get_sync</span><span class="p">(</span><span class="n">mdwc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="n">dbg_event</span><span class="p">(</span><span class="mh">0xFF</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;StrtHost gync&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">			</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdwc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">power</span><span class="p">.</span><span class="n">usage_count</span><span class="p">));</span><span class="w"></span>
<span class="w">		</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">dwc</span><span class="o">-&gt;</span><span class="n">maximum_speed</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">USB_SPEED_SUPER</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">			</span><span class="n">mdwc</span><span class="o">-&gt;</span><span class="n">ss_phy</span><span class="o">-&gt;</span><span class="n">flags</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">PHY_HOST_MODE</span><span class="p">;</span><span class="w"></span>
<span class="w">			</span><span class="n">usb_phy_notify_connect</span><span class="p">(</span><span class="n">mdwc</span><span class="o">-&gt;</span><span class="n">ss_phy</span><span class="p">,</span><span class="w"></span>
<span class="w">						</span><span class="n">USB_SPEED_SUPER</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="p">}</span><span class="w"></span>

<span class="w">		</span><span class="n">usb_phy_notify_connect</span><span class="p">(</span><span class="n">mdwc</span><span class="o">-&gt;</span><span class="n">hs_phy</span><span class="p">,</span><span class="w"> </span><span class="n">USB_SPEED_HIGH</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">IS_ERR_OR_NULL</span><span class="p">(</span><span class="n">mdwc</span><span class="o">-&gt;</span><span class="n">vbus_reg</span><span class="p">))</span><span class="w"></span>
<span class="w">			</span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">regulator_enable</span><span class="p">(</span><span class="n">mdwc</span><span class="o">-&gt;</span><span class="n">vbus_reg</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ret</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">			</span><span class="n">dev_err</span><span class="p">(</span><span class="n">mdwc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;unable to enable vbus_reg</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">			</span><span class="n">mdwc</span><span class="o">-&gt;</span><span class="n">hs_phy</span><span class="o">-&gt;</span><span class="n">flags</span><span class="w"> </span><span class="o">&amp;=</span><span class="w"> </span><span class="o">~</span><span class="n">PHY_HOST_MODE</span><span class="p">;</span><span class="w"></span>
<span class="w">			</span><span class="n">mdwc</span><span class="o">-&gt;</span><span class="n">ss_phy</span><span class="o">-&gt;</span><span class="n">flags</span><span class="w"> </span><span class="o">&amp;=</span><span class="w"> </span><span class="o">~</span><span class="n">PHY_HOST_MODE</span><span class="p">;</span><span class="w"></span>
<span class="w">			</span><span class="n">pm_runtime_put_sync</span><span class="p">(</span><span class="n">mdwc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span><span class="w"></span>
<span class="w">			</span><span class="n">dbg_event</span><span class="p">(</span><span class="mh">0xFF</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;vregerr psync&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">				</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdwc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">power</span><span class="p">.</span><span class="n">usage_count</span><span class="p">));</span><span class="w"></span>
<span class="w">			</span><span class="k">return</span><span class="w"> </span><span class="n">ret</span><span class="p">;</span><span class="w"></span>
<span class="w">		</span><span class="p">}</span><span class="w"></span>


<span class="w">		</span><span class="n">mdwc</span><span class="o">-&gt;</span><span class="n">host_nb</span><span class="p">.</span><span class="n">notifier_call</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dwc3_msm_host_notifier</span><span class="p">;</span><span class="w"></span>
<span class="w">		</span><span class="n">usb_register_notify</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdwc</span><span class="o">-&gt;</span><span class="n">host_nb</span><span class="p">);</span><span class="w"></span>

<span class="w">		</span><span class="n">dwc3_set_prtcap</span><span class="p">(</span><span class="n">dwc</span><span class="p">,</span><span class="w"> </span><span class="n">DWC3_GCTL_PRTCAP_HOST</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="n">dwc3_en_sleep_mode</span><span class="p">(</span><span class="n">dwc</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="n">mdwc</span><span class="o">-&gt;</span><span class="n">usbdev_nb</span><span class="p">.</span><span class="n">notifier_call</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">msm_dwc3_usbdev_notify</span><span class="p">;</span><span class="w"></span>
<span class="w">		</span><span class="n">usb_register_atomic_notify</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdwc</span><span class="o">-&gt;</span><span class="n">usbdev_nb</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dwc3_host_init</span><span class="p">(</span><span class="n">dwc</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ret</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">			</span><span class="n">dev_err</span><span class="p">(</span><span class="n">mdwc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span><span class="w"></span>
<span class="w">				</span><span class="s">&quot;%s: failed to add XHCI pdev ret=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">				</span><span class="n">__func__</span><span class="p">,</span><span class="w"> </span><span class="n">ret</span><span class="p">);</span><span class="w"></span>
<span class="w">			</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">IS_ERR_OR_NULL</span><span class="p">(</span><span class="n">mdwc</span><span class="o">-&gt;</span><span class="n">vbus_reg</span><span class="p">))</span><span class="w"></span>
<span class="w">				</span><span class="n">regulator_disable</span><span class="p">(</span><span class="n">mdwc</span><span class="o">-&gt;</span><span class="n">vbus_reg</span><span class="p">);</span><span class="w"></span>

<span class="w">			</span><span class="n">mdwc</span><span class="o">-&gt;</span><span class="n">hs_phy</span><span class="o">-&gt;</span><span class="n">flags</span><span class="w"> </span><span class="o">&amp;=</span><span class="w"> </span><span class="o">~</span><span class="n">PHY_HOST_MODE</span><span class="p">;</span><span class="w"></span>
<span class="w">			</span><span class="n">mdwc</span><span class="o">-&gt;</span><span class="n">ss_phy</span><span class="o">-&gt;</span><span class="n">flags</span><span class="w"> </span><span class="o">&amp;=</span><span class="w"> </span><span class="o">~</span><span class="n">PHY_HOST_MODE</span><span class="p">;</span><span class="w"></span>
<span class="w">			</span><span class="n">pm_runtime_put_sync</span><span class="p">(</span><span class="n">mdwc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span><span class="w"></span>
<span class="w">			</span><span class="n">dbg_event</span><span class="p">(</span><span class="mh">0xFF</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;pdeverr psync&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">				</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdwc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">power</span><span class="p">.</span><span class="n">usage_count</span><span class="p">));</span><span class="w"></span>
<span class="w">			</span><span class="n">usb_unregister_notify</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdwc</span><span class="o">-&gt;</span><span class="n">host_nb</span><span class="p">);</span><span class="w"></span>
<span class="w">			</span><span class="k">return</span><span class="w"> </span><span class="n">ret</span><span class="p">;</span><span class="w"></span>
<span class="w">		</span><span class="p">}</span><span class="w"></span>

<span class="w">		</span><span class="n">mdwc</span><span class="o">-&gt;</span><span class="n">in_host_mode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="w">		</span><span class="n">dwc3_usb3_phy_suspend</span><span class="p">(</span><span class="n">dwc</span><span class="p">,</span><span class="w"> </span><span class="nb">true</span><span class="p">);</span><span class="w"></span>

<span class="w">		</span><span class="cm">/* Reduce the U3 exit handshake timer from 8us to approximately</span>
<span class="cm">		 * 300ns to avoid lfps handshake interoperability issues</span>
<span class="cm">		 */</span><span class="w"></span>
<span class="w">		</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">dwc</span><span class="o">-&gt;</span><span class="n">revision</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">DWC3_USB31_REVISION_170A</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">			</span><span class="n">dwc3_msm_write_reg_field</span><span class="p">(</span><span class="n">mdwc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">,</span><span class="w"></span>
<span class="w">					</span><span class="n">DWC31_LINK_LU3LFPSRXTIM</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="w"></span>
<span class="w">					</span><span class="n">GEN2_U3_EXIT_RSP_RX_CLK_MASK</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">);</span><span class="w"></span>
<span class="w">			</span><span class="n">dwc3_msm_write_reg_field</span><span class="p">(</span><span class="n">mdwc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">,</span><span class="w"></span>
<span class="w">					</span><span class="n">DWC31_LINK_LU3LFPSRXTIM</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="w"></span>
<span class="w">					</span><span class="n">GEN1_U3_EXIT_RSP_RX_CLK_MASK</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">);</span><span class="w"></span>
<span class="w">			</span><span class="n">dev_dbg</span><span class="p">(</span><span class="n">mdwc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;LU3:%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">				</span><span class="n">dwc3_msm_read_reg</span><span class="p">(</span><span class="n">mdwc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">,</span><span class="w"></span>
<span class="w">					</span><span class="n">DWC31_LINK_LU3LFPSRXTIM</span><span class="p">(</span><span class="mi">0</span><span class="p">)));</span><span class="w"></span>
<span class="w">		</span><span class="p">}</span><span class="w"></span>

<span class="w">		</span><span class="cm">/* xHCI should have incremented child count as necessary */</span><span class="w"></span>
<span class="w">		</span><span class="n">dbg_event</span><span class="p">(</span><span class="mh">0xFF</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;StrtHost psync&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">			</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdwc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">power</span><span class="p">.</span><span class="n">usage_count</span><span class="p">));</span><span class="w"></span>
<span class="w">		</span><span class="n">pm_runtime_mark_last_busy</span><span class="p">(</span><span class="n">mdwc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="n">pm_runtime_put_sync_autosuspend</span><span class="p">(</span><span class="n">mdwc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span><span class="w"></span>
<span class="cp">#ifdef CONFIG_SMP</span>
<span class="w">		</span><span class="n">mdwc</span><span class="o">-&gt;</span><span class="n">pm_qos_req_dma</span><span class="p">.</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PM_QOS_REQ_AFFINE_IRQ</span><span class="p">;</span><span class="w"></span>
<span class="w">		</span><span class="n">mdwc</span><span class="o">-&gt;</span><span class="n">pm_qos_req_dma</span><span class="p">.</span><span class="n">irq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dwc</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">;</span><span class="w"></span>
<span class="cp">#endif</span>
<span class="w">		</span><span class="n">pm_qos_add_request</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdwc</span><span class="o">-&gt;</span><span class="n">pm_qos_req_dma</span><span class="p">,</span><span class="w"></span>
<span class="w">				</span><span class="n">PM_QOS_CPU_DMA_LATENCY</span><span class="p">,</span><span class="w"> </span><span class="n">PM_QOS_DEFAULT_VALUE</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="cm">/* start in perf mode for better performance initially */</span><span class="w"></span>
<span class="w">		</span><span class="n">msm_dwc3_perf_vote_update</span><span class="p">(</span><span class="n">mdwc</span><span class="p">,</span><span class="w"> </span><span class="nb">true</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="n">schedule_delayed_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdwc</span><span class="o">-&gt;</span><span class="n">perf_vote_work</span><span class="p">,</span><span class="w"></span>
<span class="w">				</span><span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="mi">1000</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">PM_QOS_SAMPLE_SEC</span><span class="p">));</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="n">dev_dbg</span><span class="p">(</span><span class="n">mdwc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;%s: turn off host</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">__func__</span><span class="p">);</span><span class="w"></span>

<span class="w">		</span><span class="n">usb_unregister_atomic_notify</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdwc</span><span class="o">-&gt;</span><span class="n">usbdev_nb</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">IS_ERR_OR_NULL</span><span class="p">(</span><span class="n">mdwc</span><span class="o">-&gt;</span><span class="n">vbus_reg</span><span class="p">))</span><span class="w"></span>
<span class="w">			</span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">regulator_disable</span><span class="p">(</span><span class="n">mdwc</span><span class="o">-&gt;</span><span class="n">vbus_reg</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ret</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">			</span><span class="n">dev_err</span><span class="p">(</span><span class="n">mdwc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;unable to disable vbus_reg</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">			</span><span class="k">return</span><span class="w"> </span><span class="n">ret</span><span class="p">;</span><span class="w"></span>
<span class="w">		</span><span class="p">}</span><span class="w"></span>

<span class="w">		</span><span class="n">cancel_delayed_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdwc</span><span class="o">-&gt;</span><span class="n">perf_vote_work</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="n">msm_dwc3_perf_vote_update</span><span class="p">(</span><span class="n">mdwc</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="n">pm_qos_remove_request</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdwc</span><span class="o">-&gt;</span><span class="n">pm_qos_req_dma</span><span class="p">);</span><span class="w"></span>

<span class="w">		</span><span class="n">pm_runtime_get_sync</span><span class="p">(</span><span class="n">mdwc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="n">dbg_event</span><span class="p">(</span><span class="mh">0xFF</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;StopHost gsync&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">			</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdwc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">power</span><span class="p">.</span><span class="n">usage_count</span><span class="p">));</span><span class="w"></span>
<span class="w">		</span><span class="n">usb_phy_notify_disconnect</span><span class="p">(</span><span class="n">mdwc</span><span class="o">-&gt;</span><span class="n">hs_phy</span><span class="p">,</span><span class="w"> </span><span class="n">USB_SPEED_HIGH</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">mdwc</span><span class="o">-&gt;</span><span class="n">ss_phy</span><span class="o">-&gt;</span><span class="n">flags</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">PHY_HOST_MODE</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">			</span><span class="n">usb_phy_notify_disconnect</span><span class="p">(</span><span class="n">mdwc</span><span class="o">-&gt;</span><span class="n">ss_phy</span><span class="p">,</span><span class="w"></span>
<span class="w">					</span><span class="n">USB_SPEED_SUPER</span><span class="p">);</span><span class="w"></span>
<span class="w">			</span><span class="n">mdwc</span><span class="o">-&gt;</span><span class="n">ss_phy</span><span class="o">-&gt;</span><span class="n">flags</span><span class="w"> </span><span class="o">&amp;=</span><span class="w"> </span><span class="o">~</span><span class="n">PHY_HOST_MODE</span><span class="p">;</span><span class="w"></span>
<span class="w">		</span><span class="p">}</span><span class="w"></span>

<span class="w">		</span><span class="n">mdwc</span><span class="o">-&gt;</span><span class="n">hs_phy</span><span class="o">-&gt;</span><span class="n">flags</span><span class="w"> </span><span class="o">&amp;=</span><span class="w"> </span><span class="o">~</span><span class="n">PHY_HOST_MODE</span><span class="p">;</span><span class="w"></span>
<span class="w">		</span><span class="n">dwc3_host_exit</span><span class="p">(</span><span class="n">dwc</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="n">usb_unregister_notify</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdwc</span><span class="o">-&gt;</span><span class="n">host_nb</span><span class="p">);</span><span class="w"></span>

<span class="w">		</span><span class="n">dwc3_set_prtcap</span><span class="p">(</span><span class="n">dwc</span><span class="p">,</span><span class="w"> </span><span class="n">DWC3_GCTL_PRTCAP_DEVICE</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="n">dwc3_usb3_phy_suspend</span><span class="p">(</span><span class="n">dwc</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="n">mdwc</span><span class="o">-&gt;</span><span class="n">in_host_mode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>

<span class="w">		</span><span class="cm">/* wait for LPM, to ensure h/w is reset after stop_host */</span><span class="w"></span>
<span class="w">		</span><span class="n">set_bit</span><span class="p">(</span><span class="n">WAIT_FOR_LPM</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">mdwc</span><span class="o">-&gt;</span><span class="n">inputs</span><span class="p">);</span><span class="w"></span>

<span class="w">		</span><span class="n">pm_runtime_put_sync_suspend</span><span class="p">(</span><span class="n">mdwc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="n">dbg_event</span><span class="p">(</span><span class="mh">0xFF</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;StopHost psync&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">			</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdwc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">power</span><span class="p">.</span><span class="n">usage_count</span><span class="p">));</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>

<span class="w">	</span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="cm">/**</span>
<span class="cm"> * dwc3_otg_start_peripheral -  bind/unbind the peripheral controller.</span>
<span class="cm"> *</span>
<span class="cm"> * @mdwc: Pointer to the dwc3_msm structure.</span>
<span class="cm"> * @on:   Turn ON/OFF the gadget.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success otherwise negative errno.</span>
<span class="cm"> */</span><span class="w"></span>
<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">dwc3_otg_start_peripheral</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">dwc3_msm</span><span class="w"> </span><span class="o">*</span><span class="n">mdwc</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">on</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="k">struct</span><span class="w"> </span><span class="nc">dwc3</span><span class="w"> </span><span class="o">*</span><span class="n">dwc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">platform_get_drvdata</span><span class="p">(</span><span class="n">mdwc</span><span class="o">-&gt;</span><span class="n">dwc3</span><span class="p">);</span><span class="w"></span>

<span class="w">	</span><span class="n">pm_runtime_get_sync</span><span class="p">(</span><span class="n">mdwc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="n">dbg_event</span><span class="p">(</span><span class="mh">0xFF</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;StrtGdgt gsync&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">		</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdwc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">power</span><span class="p">.</span><span class="n">usage_count</span><span class="p">));</span><span class="w"></span>

<span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">on</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="n">dev_dbg</span><span class="p">(</span><span class="n">mdwc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;%s: turn on gadget %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">					</span><span class="n">__func__</span><span class="p">,</span><span class="w"> </span><span class="n">dwc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">name</span><span class="p">);</span><span class="w"></span>

<span class="w">		</span><span class="n">dwc3_override_vbus_status</span><span class="p">(</span><span class="n">mdwc</span><span class="p">,</span><span class="w"> </span><span class="nb">true</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="n">usb_phy_notify_connect</span><span class="p">(</span><span class="n">mdwc</span><span class="o">-&gt;</span><span class="n">hs_phy</span><span class="p">,</span><span class="w"> </span><span class="n">USB_SPEED_HIGH</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="n">usb_phy_notify_connect</span><span class="p">(</span><span class="n">mdwc</span><span class="o">-&gt;</span><span class="n">ss_phy</span><span class="p">,</span><span class="w"> </span><span class="n">USB_SPEED_SUPER</span><span class="p">);</span><span class="w"></span>

<span class="w">		</span><span class="cm">/*</span>
<span class="cm">		 * Core reset is not required during start peripheral. Only</span>
<span class="cm">		 * DBM reset is required, hence perform only DBM reset here.</span>
<span class="cm">		 */</span><span class="w"></span>
<span class="w">		</span><span class="n">dwc3_msm_block_reset</span><span class="p">(</span><span class="n">mdwc</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="n">dwc3_set_prtcap</span><span class="p">(</span><span class="n">dwc</span><span class="p">,</span><span class="w"> </span><span class="n">DWC3_GCTL_PRTCAP_DEVICE</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="n">dwc3_dis_sleep_mode</span><span class="p">(</span><span class="n">dwc</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="n">mdwc</span><span class="o">-&gt;</span><span class="n">in_device_mode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>

<span class="w">		</span><span class="cm">/* Reduce the U3 exit handshake timer from 8us to approximately</span>
<span class="cm">		 * 300ns to avoid lfps handshake interoperability issues</span>
<span class="cm">		 */</span><span class="w"></span>
<span class="w">		</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">dwc</span><span class="o">-&gt;</span><span class="n">revision</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">DWC3_USB31_REVISION_170A</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">			</span><span class="n">dwc3_msm_write_reg_field</span><span class="p">(</span><span class="n">mdwc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">,</span><span class="w"></span>
<span class="w">					</span><span class="n">DWC31_LINK_LU3LFPSRXTIM</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="w"></span>
<span class="w">					</span><span class="n">GEN2_U3_EXIT_RSP_RX_CLK_MASK</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">);</span><span class="w"></span>
<span class="w">			</span><span class="n">dwc3_msm_write_reg_field</span><span class="p">(</span><span class="n">mdwc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">,</span><span class="w"></span>
<span class="w">					</span><span class="n">DWC31_LINK_LU3LFPSRXTIM</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="w"></span>
<span class="w">					</span><span class="n">GEN1_U3_EXIT_RSP_RX_CLK_MASK</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">);</span><span class="w"></span>
<span class="w">			</span><span class="n">dev_dbg</span><span class="p">(</span><span class="n">mdwc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;LU3:%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">				</span><span class="n">dwc3_msm_read_reg</span><span class="p">(</span><span class="n">mdwc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">,</span><span class="w"></span>
<span class="w">					</span><span class="n">DWC31_LINK_LU3LFPSRXTIM</span><span class="p">(</span><span class="mi">0</span><span class="p">)));</span><span class="w"></span>
<span class="w">		</span><span class="p">}</span><span class="w"></span>

<span class="w">		</span><span class="n">usb_gadget_vbus_connect</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dwc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">);</span><span class="w"></span>
<span class="cp">#ifdef CONFIG_SMP</span>
<span class="w">		</span><span class="n">mdwc</span><span class="o">-&gt;</span><span class="n">pm_qos_req_dma</span><span class="p">.</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PM_QOS_REQ_AFFINE_IRQ</span><span class="p">;</span><span class="w"></span>
<span class="w">		</span><span class="n">mdwc</span><span class="o">-&gt;</span><span class="n">pm_qos_req_dma</span><span class="p">.</span><span class="n">irq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dwc</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">;</span><span class="w"></span>
<span class="cp">#endif</span>
<span class="w">		</span><span class="n">pm_qos_add_request</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdwc</span><span class="o">-&gt;</span><span class="n">pm_qos_req_dma</span><span class="p">,</span><span class="w"></span>
<span class="w">				</span><span class="n">PM_QOS_CPU_DMA_LATENCY</span><span class="p">,</span><span class="w"> </span><span class="n">PM_QOS_DEFAULT_VALUE</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="cm">/* start in perf mode for better performance initially */</span><span class="w"></span>
<span class="w">		</span><span class="n">msm_dwc3_perf_vote_update</span><span class="p">(</span><span class="n">mdwc</span><span class="p">,</span><span class="w"> </span><span class="nb">true</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="n">schedule_delayed_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdwc</span><span class="o">-&gt;</span><span class="n">perf_vote_work</span><span class="p">,</span><span class="w"></span>
<span class="w">				</span><span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="mi">1000</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">PM_QOS_SAMPLE_SEC</span><span class="p">));</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="n">dev_dbg</span><span class="p">(</span><span class="n">mdwc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;%s: turn off gadget %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">					</span><span class="n">__func__</span><span class="p">,</span><span class="w"> </span><span class="n">dwc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">name</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="n">cancel_delayed_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdwc</span><span class="o">-&gt;</span><span class="n">perf_vote_work</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="n">msm_dwc3_perf_vote_update</span><span class="p">(</span><span class="n">mdwc</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="n">pm_qos_remove_request</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdwc</span><span class="o">-&gt;</span><span class="n">pm_qos_req_dma</span><span class="p">);</span><span class="w"></span>

<span class="w">		</span><span class="n">mdwc</span><span class="o">-&gt;</span><span class="n">in_device_mode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="w">		</span><span class="n">usb_gadget_vbus_disconnect</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dwc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="n">usb_phy_notify_disconnect</span><span class="p">(</span><span class="n">mdwc</span><span class="o">-&gt;</span><span class="n">hs_phy</span><span class="p">,</span><span class="w"> </span><span class="n">USB_SPEED_HIGH</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="n">usb_phy_notify_disconnect</span><span class="p">(</span><span class="n">mdwc</span><span class="o">-&gt;</span><span class="n">ss_phy</span><span class="p">,</span><span class="w"> </span><span class="n">USB_SPEED_SUPER</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="n">dwc3_override_vbus_status</span><span class="p">(</span><span class="n">mdwc</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="n">dwc3_usb3_phy_suspend</span><span class="p">(</span><span class="n">dwc</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">);</span><span class="w"></span>

<span class="w">		</span><span class="cm">/* wait for LPM, to ensure h/w is reset after stop_peripheral */</span><span class="w"></span>
<span class="w">		</span><span class="n">set_bit</span><span class="p">(</span><span class="n">WAIT_FOR_LPM</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">mdwc</span><span class="o">-&gt;</span><span class="n">inputs</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>

<span class="w">	</span><span class="n">pm_runtime_put_sync</span><span class="p">(</span><span class="n">mdwc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="n">dbg_event</span><span class="p">(</span><span class="mh">0xFF</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;StopGdgt psync&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">		</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdwc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">power</span><span class="p">.</span><span class="n">usage_count</span><span class="p">));</span><span class="w"></span>

<span class="w">	</span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="usb-device">
<h2>USB device切换<a class="headerlink" href="#usb-device" title="Permalink to this heading"></a></h2>
<p>前面BC12检测完后，将调用<code class="docutils literal notranslate"><span class="pre">qusb_phy_notify_extcon(qphy,</span> <span class="pre">EXTCON_USB,</span> <span class="pre">1)</span></code> 通知dw3驱动切换device</p>
</section>
</section>
<section id="usbpower-supply-type-unknown">
<h1>拔usb时设置充电类型为POWER_SUPPLY_TYPE_UNKNOWN<a class="headerlink" href="#usbpower-supply-type-unknown" title="Permalink to this heading"></a></h1>
<ul class="simple">
<li><p>目前smblite是在拔插中断中判断vbus是否在位，不在位则设置为POWER_SUPPLY_TYPE_UNKNOWN，打印如下：</p></li>
</ul>
<div class="highlight-log notranslate"><div class="highlight"><pre><span></span>   51.107378] PM2250_charger: smblite_usbin_uv_irq_handler: IRQ: usbin-uv
[   51.109555] PM2250_charger: smblite_usb_plugin_irq_handler: smblite_usb_plugin_irq_handler
[   51.109588] PM2250_charger: smblite_lib_set_charge_param: AICL 5V threshold = 4200 (0x00)
[   51.109622] PM2250_charger: smblite_lib_usb_plugin_locked: IRQ: usbin-plugin detached
</pre></div>
</div>
<ul class="simple">
<li><p>程序流程：</p></li>
</ul>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="o">*</span><span class="w"> </span><span class="n">smblite_usb_plugin_irq_handler</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">irq</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">data</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="o">*</span><span class="w"> </span><span class="n">smblite_lib_usb_plugin_locked</span><span class="p">(</span><span class="n">chg</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="o">*</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">vbus_rising</span><span class="p">)</span><span class="w"></span>
<span class="w">	  </span><span class="o">*</span><span class="w"> </span><span class="n">smblite_lib_update_usb_type</span><span class="p">(</span><span class="n">chg</span><span class="p">,</span><span class="w"> </span><span class="n">POWER_SUPPLY_TYPE_UNKNOWN</span><span class="p">);</span><span class="w"></span>
<span class="w">	    </span><span class="o">*</span><span class="w"> </span><span class="n">chg</span><span class="o">-&gt;</span><span class="n">real_charger_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">type</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="device">
<h1>device流程实例<a class="headerlink" href="#device" title="Permalink to this heading"></a></h1>
<div class="highlight-log notranslate"><div class="highlight"><pre><span></span>source plug in:
[   74.748103] rt-pd-manager soc:rt_pd_manager: usb_dwork_handler Device
[   74.753185] &lt;   74.670&gt;TCPC-TCPC:wake_lock=1
[   74.753185] &lt;   74.670&gt;TCPC-TCPC:sink_vbus: 5000 mV, 100 mA
[   74.753185] &lt;   74.670&gt;Enable TYPEC_RT_TIMER_NOT_LEGACY
[   74.753185] &lt;
[   74.753187]  74.670&gt;TCPC-TYPEC:Attached-&gt; SINK
[   74.753187] &lt;   74.670&gt;TCPC-TCPC:usb_port_attached
[   74.753187] &lt;   74.671&gt;TCPC-DC&gt; dc_dfp_none
[   74.753187] &lt;   74.671&gt;TCPC-PE:PD
[   48.386548] pax-pd-manager soc:pax_pd_manager: pd_tcp_notifier_call Charger plug in, polarity = 0
[   48.404179] pax-pd-manager soc:pax_pd_manager: usb_dwork_handler Device
[   48.410913] extcon extcon2: extcon_set_state_sync id = 2 state = 0
[   48.417736] extcon extcon2: extcon_set_state_sync state 1
[   48.423351] extcon extcon2: extcon_set_state_sync id = 1 state = 1
[   48.429615] mp2721 0-003f: type=1, chg_type=0, count=2
[   48.429620] mp2721 0-003f: restart pax_wait_bc12_alarm_timer_func
[   48.429626] mp2721 0-003f: pax_wait_bc12_start_timer: alarm timer start:-1, 48 471600084
[   48.429631] mp2721 0-003f: device check bc12 fail!
[   48.430040] extcon extcon2: extcon_set_state_sync state 1
[   48.449529] extcon extcon2: extcon_sync state 1
[   48.465202] extcon extcon2: extcon_sync state 2 index = 0
[   48.471262] extcon extcon2: extcon_sync state 3
[   48.476160] msm-qusb-phy 1613000.qusb: Got VBUS notification: 1
[   48.482220] mp2721 0-003f: type=1, chg_type=0, count=3
[   48.482223] mp2721 0-003f: restart pax_wait_bc12_alarm_timer_func
[   48.482230] mp2721 0-003f: pax_wait_bc12_start_timer: alarm timer start:-1, 48 524203366
[   48.482235] mp2721 0-003f: device check bc12 fail!
[   48.507245] extcon extcon2: name_show = NAME=soc:pax_pd_manager
[   48.513191] extcon extcon2: state_show = STATE=USB=1
[   48.513191] USB-HOST=0
[   48.521141] msm-qusb-phy 1613000.qusb: state: 0
[   48.530050] msm-qusb-phy 1613000.qusb: qusb_phy_enable_power turn on regulators
[   48.537465] mp2721 0-003f: type=1, chg_type=0, count=4
[   48.537469] mp2721 0-003f: restart pax_wait_bc12_alarm_timer_func
[   48.537475] mp2721 0-003f: pax_wait_bc12_start_timer: alarm timer start:-1, 48 579448678
[   48.537480] mp2721 0-003f: device check bc12 fail!
[   48.563235] msm-qusb-phy 1613000.qusb: min_vol:925000 max_vol:970000
[   48.579924] msm-qusb-phy 1613000.qusb: qusb_phy_enable_clocks(): on:1
[   48.587511] mp2721 0-003f: type=1, chg_type=0, count=5
[   48.592682] mp2721 0-003f: restart pax_wait_bc12_alarm_timer_func
[   48.598814] mp2721 0-003f: pax_wait_bc12_start_timer: alarm timer start:-1, 48 640786490
[   48.606938] mp2721 0-003f: device check bc12 fail!
[   48.621453] msm-qusb-phy 1613000.qusb: state: 1
[   48.648845] mp2721 0-003f: type=1, chg_type=0, count=6
[   48.654010] mp2721 0-003f: restart pax_wait_bc12_alarm_timer_func
[   48.660135] mp2721 0-003f: pax_wait_bc12_start_timer: alarm timer start:-1, 48 702107845
[   48.668261] mp2721 0-003f: device check bc12 fail!
[   48.676209] msm-qusb-phy 1613000.qusb: state: 2
[   48.681101] msm-qusb-phy 1613000.qusb: state: 1 reg: 0x0
[   48.686592] msm-qusb-phy 1613000.qusb: state: 2
[   48.710171] mp2721 0-003f: type=1, chg_type=0, count=7
[   48.715334] mp2721 0-003f: restart pax_wait_bc12_alarm_timer_func
[   48.721447] mp2721 0-003f: pax_wait_bc12_start_timer: alarm timer start:-1, 48 763417688
[   48.729580] mp2721 0-003f: device check bc12 fail!
[   48.771487] mp2721 0-003f: type=1, chg_type=0, count=8
[   48.776649] mp2721 0-003f: restart pax_wait_bc12_alarm_timer_func
[   48.776656] mp2721 0-003f: pax_wait_bc12_start_timer: alarm timer start:-1, 48 818629303
[   48.776663] mp2721 0-003f: device check bc12 fail!
[   48.788213] msm-qusb-phy 1613000.qusb: state: 3
[   48.820139] msm-qusb-phy 1613000.qusb: state: 2 reg: 0x0
[   48.826684] mp2721 0-003f: type=1, chg_type=0, count=9
[   48.831853] mp2721 0-003f: restart pax_wait_bc12_alarm_timer_func
[   48.837974] mp2721 0-003f: pax_wait_bc12_start_timer: alarm timer start:-1, 48 879946751
[   48.846091] mp2721 0-003f: device check bc12 fail!
[   48.886176] msm-qusb-phy 1613000.qusb: qusb_phy_enable_clocks(): on:0
[   48.892753] mp2721 0-003f: type=1, chg_type=0, count=10
[   48.892757] mp2721 0-003f: restart pax_wait_bc12_alarm_timer_func
[   48.892762] mp2721 0-003f: pax_wait_bc12_start_timer: alarm timer start:-1, 48 934736647
[   48.892767] mp2721 0-003f: device check bc12 fail!
[   48.942797] mp2721 0-003f: type=1, chg_type=0, count=11
[   48.948042] mp2721 0-003f: restart pax_wait_bc12_alarm_timer_func
[   48.954162] mp2721 0-003f: pax_wait_bc12_start_timer: alarm timer start:-1, 48 996134824
[   48.962297] mp2721 0-003f: device check bc12 fail!
[   48.972099] msm-qusb-phy 1613000.qusb: qusb_phy_enable_power turn off regulators
[   48.980846] msm-qusb-phy 1613000.qusb: min_vol:0 max_vol:970000
[   48.986876] msm-qusb-phy 1613000.qusb: QUSB PHY&#39;s regulators are turned OFF.
[   48.994081] msm-qusb-phy 1613000.qusb: Notify charger type: 4
[   49.004177] mp2721 0-003f: type=1, chg_type=0, count=12
[   49.009425] mp2721 0-003f: restart pax_wait_bc12_alarm_timer_func
[   49.015547] mp2721 0-003f: pax_wait_bc12_start_timer: alarm timer start:-1, 49 57517011
[   49.023586] mp2721 0-003f: device check bc12 fail!
[   49.029583] mp2721 0-003f: mp2721_set_property() set charge_type:4, ret:0
[   49.037074] msm-qusb-phy 1613000.qusb: Notify event: 1 for extcon_id: 1
[   49.043889] extcon extcon3: extcon_set_state_sync id = 1 state = 1
[   49.050686] extcon extcon3: extcon_set_state_sync state 1
[   49.060712] extcon extcon3: extcon_sync state 1
[   49.065557] mp2721 0-003f: type=1, chg_type=4, count=13
[   49.065579] mp2721 0-003f: device check bc12 fail!
[   49.065628] plug status: plug in
[   49.071225] extcon extcon3: extcon_sync state 2 index = 0
[   49.087428] extcon extcon3: extcon_sync state 3
[   49.092125] msm-dwc3 4e00000.ssusb: vbus:1 event received
[   49.099253] extcon extcon3: name_show = NAME=1613000.qusb
[   49.100370] msm-dwc3 4e00000.ssusb: dwc3_resume_work: dwc3 resume work
[   49.104686] extcon extcon3: state_show = STATE=USB=1
[   49.104686] USB-HOST=0
[   49.109038] msm-qusb-phy 1613000.qusb: state: 5
[   49.155382] msm-dwc3 4e00000.ssusb: XCVR: ID set
[   49.163556] msm-dwc3 4e00000.ssusb: XCVR: BSV set
[   49.180118] msm-dwc3 4e00000.ssusb: XCVR: SUSP clear
[   49.185375] msm-dwc3 4e00000.ssusb: eud: state:0 active:0 hs_phy_flags:0x0
[   49.212318] msm-dwc3 4e00000.ssusb: idle state
[   49.217269] msm-dwc3 4e00000.ssusb: b_sess_vld
[   49.221918] msm-dwc3 4e00000.ssusb: DWC3-msm runtime resume
[   49.242776] msm-dwc3 4e00000.ssusb: dwc3_msm_resume: exiting lpm
[   49.256189] msm-dwc3 4e00000.ssusb: dwc3_msm_resume: exit power collapse
[   49.281388] msm-qusb-phy 1613000.qusb: qusb_phy_enable_power turn on regulators
[   49.316391] msm-qusb-phy 1613000.qusb: min_vol:925000 max_vol:970000
[   49.347048] msm-qusb-phy 1613000.qusb: qusb_phy_enable_clocks(): on:1
[   49.372279] msm-dwc3 4e00000.ssusb: dwc3_msm_resume: exit power collapse
[   49.423957] msm-qusb-phy 1613000.qusb: qusb_phy_init
[   49.456549] msm-qusb-phy 1613000.qusb: QUSB2PHY_PLL_STATUS:30
[   49.483932] msm-usb-ssphy-qmp 1615000.ssphy: USB QMP PHY: Update TYPEC CTRL(2)
[   49.524418] msm-qusb-phy 1613000.qusb: qusb_phy_set_suspend: USB PHY is already suspended
[   49.560749] msm-dwc3 4e00000.ssusb: DWC3_CONTROLLER_POST_RESET_EVENT received
[   49.584225] msm-dwc3 4e00000.ssusb: msm_dwc3_pwr_irq received
[   49.584231] msm-dwc3 4e00000.ssusb: dwc3_pwr_event_handler irq_stat=8000C
[   49.596805] msm-dwc3 4e00000.ssusb: dwc3_pwr_event_handler link state = 0x0004
[   49.601896] msm-dwc3 4e00000.ssusb: dwc3_pwr_event_handler irq_stat=8000C
[   49.604045] msm-dwc3 4e00000.ssusb: dwc3_pwr_event_handler: unexpected PWR_EVNT, irq_stat=80000
[   49.621312] mp2721 0-003f: chg_dump: CHG [online: 1, type: SDP, status: Charging, fault: OK, health: Good, ICHG = 4000mA, AICR = 2000mA, MIVR = 4440mV, IEOC = 240mA, CV = 4350mV]
[   49.627252] msm-dwc3 4e00000.ssusb: dwc3_pwr_event_handler link state = 0x0004
[   49.658680] msm-dwc3 4e00000.ssusb: dwc3_pwr_event_handler: unexpected PWR_EVNT, irq_stat=80000
[   49.672169] msm-dwc3 4e00000.ssusb: dwc3_otg_start_peripheral: turn on gadget dwc3-gadget
[   49.692780] msm-qusb-phy 1613000.qusb: QUSB PHY: connect notification cable_connected=1
[   49.706225] msm-dwc3 4e00000.ssusb: DWC3_GSI_EVT_BUF_SETUP
[   49.711740] msm-dwc3 4e00000.ssusb: Evt buf ffffff80098ad000 dma affdb000 length 4096
[   49.719606] msm-dwc3 4e00000.ssusb: Evt buf ffffff80098b5000 dma affda000 length 4096
[   49.727468] msm-dwc3 4e00000.ssusb: Evt buf ffffff80098bd000 dma affd9000 length 4096
[   49.786785] msm-dwc3 4e00000.ssusb: peripheral state

plug out:
[   73.168794] rt-pd-manager soc:rt_pd_manager: pd_tcp_notifier_call Charger plug out
[   73.176642] rt-pd-manager soc:rt_pd_manager: usb_dwork_handler Idle
[   73.177428] set prop 125 is not supported
[   73.183395] PM2250_charger: smblite_lib_get_prop_usb_online: POWER_PATH_STATUS = 0x01
[   73.188369] PM2250_charger: smblite_lib_get_charge_param: input current limit status = 0 (0x00)
[   73.190253] SET_PLUG_EN: 1
[   73.195323] msm-qusb-phy 1613000.qusb: Got VBUS notification: 0
[   73.195940] msm-qusb-phy 1613000.qusb: state: 5
[   73.195944] msm-qusb-phy 1613000.qusb: Notify event: 0 for extcon_id: 1
[   73.196221] PM2250_charger: smblite_lib_get_prop_batt_health: CHARGER_VBAT_STATUS_REG = 0x04
[   73.196375] PM2250_charger: smblite_lib_get_prop_usb_online: POWER_PATH_STATUS = 0x01
[   73.204006] set prop 122 is not supported
[   73.204471] PM2250_charger: smblite_lib_get_prop_batt_health: CHARGER_VBAT_STATUS_REG = 0x04
[   73.205042] PM2250_charger: smblite_lib_get_charge_param: input current limit status = 0 (0x00)
[   73.205179] PM2250_charger: smblite_lib_get_prop_batt_health: CHARGER_VBAT_STATUS_REG = 0x04
[   73.211462] PM2250_charger: smblite_lib_get_prop_usb_online: POWER_PATH_STATUS = 0x01
[   73.211539] PM2250_charger: smblite_lib_get_prop_batt_health: CHARGER_VBAT_STATUS_REG = 0x04
[   73.211675] PM2250_charger: smblite_lib_get_prop_usb_online: POWER_PATH_STATUS = 0x01
[   73.234879] PM2250_charger: smblite_lib_get_prop_usb_online: POWER_PATH_STATUS = 0x01
[   73.245143] PM2250_charger: smblite_lib_get_prop_batt_health: CHARGER_VBAT_STATUS_REG = 0x04
[   73.262564] PM2250_charger: smblite_lib_get_prop_usb_online: POWER_PATH_STATUS = 0x01

console:/ $ [   73.330003] PM2250_charger: smblite_lib_get_prop_usb_online: POWER_PATH_STATUS = 0x01
[   73.338079] PM2250_charger: smblite_lib_get_prop_batt_health: CHARGER_VBAT_STATUS_REG = 0x00
[   73.346910] PM2250_charger: smblite_lib_get_prop_usb_online: POWER_PATH_STATUS = 0x01
[   73.357028] PM2250_charger: smblite_lib_get_prop_usb_online: POWER_PATH_STATUS = 0x01
[   73.365073] PM2250_charger: smblite_lib_get_prop_batt_health: CHARGER_VBAT_STATUS_REG = 0x00
[   73.374007] PM2250_charger: smblite_lib_get_prop_usb_online: POWER_PATH_STATUS = 0x01
</pre></div>
</div>
</section>
<section id="pax-extcon">
<h1>PAX extcon实例<a class="headerlink" href="#pax-extcon" title="Permalink to this heading"></a></h1>
<p>目前将qcom charger的extcon通知改为我们自己PD驱动去通知，在qusb接收notify中加<code class="docutils literal notranslate"><span class="pre">dump_stack</span></code>打印如下，表示是从pax接收的通知：</p>
<div class="highlight-log notranslate"><div class="highlight"><pre><span></span>[Tue Aug  2 20:34:05 2022] &lt; 1553.131&gt;TCPC-TCPC:RA_DETACH\x0a&lt; 1553.131&gt;TCPC-TCPC:tcpci_alert_cc_changed ++
[Tue Aug  2 20:34:05 2022] pax-pd-manager soc:pax_pd_manager: pd_tcp_notifier_call - sink vbus
[Tue Aug  2 20:34:05 2022] pax-pd-manager soc:pax_pd_manager: pd_tcp_notifier_call event = 14
[Tue Aug  2 20:34:05 2022] pax-pd-manager soc:pax_pd_manager: pd_tcp_notifier_call Charger plug in, polarity = 0 //PD识别插入usb
[Tue Aug  2 20:34:05 2022] set_charger_plug_status status 1
[Tue Aug  2 20:34:05 2022] plug status: 1
[Tue Aug  2 20:34:05 2022] ///PD dbg info 37d
[Tue Aug  2 20:34:05 2022] &lt; 1553.194&gt;TCPC-TYPEC:[CC_Alert] 0/7
[Tue Aug  2 20:34:05 2022] pax-pd-manager soc:pax_pd_manager: usb_dwork_handler Device
[Tue Aug  2 20:34:05 2022] PAX_CHG: handle_typec_attach_dettach: ++ en:1 g_info-&gt;sink_mv_new = 0
[Tue Aug  2 20:34:05 2022] extcon extcon2: extcon_set_state_sync id = 2 state = 0
[Tue Aug  2 20:34:05 2022] PAX_CHG_MP2721: mp2721_enable_vbus_ovp en:0
[Tue Aug  2 20:34:05 2022] pax_is_charger_on chr_type = 5
[Tue Aug  2 20:34:05 2022] extcon extcon2: extcon_set_state_sync state 1
[Tue Aug  2 20:34:05 2022] extcon extcon2: extcon_set_state_sync id = 1 state = 1
[Tue Aug  2 20:34:05 2022] extcon extcon2: extcon_set_state_sync state 1
[Tue Aug  2 20:34:05 2022] extcon extcon2: extcon_sync state 1
[Tue Aug  2 20:34:05 2022] extcon extcon2: extcon_sync state 2 index = 0
[Tue Aug  2 20:34:05 2022] extcon extcon2: extcon_sync state 3
[Tue Aug  2 20:34:05 2022] CPU: 1 PID: 46 Comm: kworker/1:1 Tainted: G        W         4.19.157 #1
[Tue Aug  2 20:34:05 2022] Hardware name: Qualcomm Technologies, Inc. Scuba IOT IDP (DT)
[Tue Aug  2 20:34:05 2022] Workqueue: events usb_dwork_handler
[Tue Aug  2 20:34:05 2022] Call trace:
[Tue Aug  2 20:34:05 2022] dump_backtrace+0x0/0x250
[Tue Aug  2 20:34:05 2022] show_stack+0x14/0x20
[Tue Aug  2 20:34:05 2022] dump_stack+0xc8/0x104
[Tue Aug  2 20:34:05 2022] qusb_phy_vbus_notifier+0x20/0x78
[Tue Aug  2 20:34:05 2022] raw_notifier_call_chain+0x78/0xb8
[Tue Aug  2 20:34:05 2022] extcon_sync+0x120/0x330
[Tue Aug  2 20:34:05 2022] extcon_set_state_sync+0xd4/0xf8
[Tue Aug  2 20:34:05 2022] usb_dwork_handler+0x164/0x170
[Tue Aug  2 20:34:05 2022] process_one_work+0x278/0x468
[Tue Aug  2 20:34:05 2022] worker_thread+0x238/0x4c8
[Tue Aug  2 20:34:05 2022] kthread+0x148/0x158
[Tue Aug  2 20:34:05 2022] ret_from_fork+0x10/0x1c
[Tue Aug  2 20:34:05 2022] msm-qusb-phy 1613000.qusb: Got VBUS notification: 1
</pre></div>
</div>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, wugn.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
  

<script charset="UTF-8" id="LA_COLLECT" src="//sdk.51.la/js-sdk-pro.min.js"></script>
<script>LA.init({id: "JjOE14XScyd75b2C",ck: "JjOE14XScyd75b2C"})</script>

<br/>
<script id="LA-DATA-WIDGET" crossorigin="anonymous" charset="UTF-8" src="https://v6-widget.51.la/v6/JjOE14XScyd75b2C/quote.js?theme=0&f=12&display=1,0,0,0,0,0,1,1"></script>



</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>