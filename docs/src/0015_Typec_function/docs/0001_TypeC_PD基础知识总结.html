<!DOCTYPE html>
<html class="writer-html5" lang="zh-CN" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>wugn</title>

      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/default.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/translations.js"></script>
        <script src="../../../_static/js/baidutongji.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="索引" href="../../../genindex.html" />
    <link rel="search" title="搜索" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../index.html" class="icon icon-home"> wugn_note
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="在文档中搜索" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <!-- Local TOC -->
              <div class="local-toc"><ul>
<li><a class="reference internal" href="#">概述</a></li>
<li><a class="reference internal" href="#id2">参考</a></li>
<li><a class="reference internal" href="#typec">TypeC 基本特性</a></li>
<li><a class="reference internal" href="#type-c-portdata-rolepower-role">Type-C Port的Data Role、Power Role</a></li>
<li><a class="reference internal" href="#id3">硬件引脚定义</a></li>
<li><a class="reference internal" href="#cc">为什需要CC检测</a></li>
<li><a class="reference internal" href="#type-cpd">Type-C和PD有什么区别</a><ul>
<li><a class="reference internal" href="#pd-type-c">PD是指传输协议，Type-c是指接口。</a></li>
<li><a class="reference internal" href="#type-c-pd">市场上Type-C/PD有哪几种分类？</a></li>
</ul>
</li>
<li><a class="reference internal" href="#pd-dual-role">PD Dual Role功能</a><ul>
<li><a class="reference internal" href="#type-c-data">Type-C Data角色定义</a></li>
<li><a class="reference internal" href="#type-c-power">Type-C Power角色定义</a></li>
<li><a class="reference internal" href="#power-role-swap">Power Role Swap功能介绍</a></li>
<li><a class="reference internal" href="#data-role-swap">Data Role Swap功能介绍</a></li>
<li><a class="reference internal" href="#fast-role-swap">Fast Role Swap功能介绍</a></li>
<li><a class="reference internal" href="#id4">总结</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id5">CC正反方向确认</a></li>
<li><a class="reference internal" href="#id6">TypeC 如何确定供电能力</a><ul>
<li><a class="reference internal" href="#dfprp">DFP的上拉电阻Rp</a></li>
<li><a class="reference internal" href="#upfrd">UPF的下拉电阻Rd</a></li>
<li><a class="reference internal" href="#vconn">VCONN电源</a></li>
<li><a class="reference internal" href="#ra">数据线上的Ra</a></li>
<li><a class="reference internal" href="#id7">举例</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id8">TypeC 如何确定充电方向</a><ul>
<li><a class="reference internal" href="#source-sink">Source 到 Sink</a></li>
<li><a class="reference internal" href="#source-drp">Source 到 DRP</a></li>
<li><a class="reference internal" href="#drp-sink">DRP 到 Sink</a></li>
<li><a class="reference internal" href="#drp-drp">DRP 到 DRP</a><ul>
<li><a class="reference internal" href="#drprole">1.两个DRP端口相连怎样分配role</a></li>
<li><a class="reference internal" href="#drpfail">2.疑问：是否会出现两个DRP切换周期一直同步而导致的配对过程无限fail的情况</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#type-c">带电子标签的Type-C数据线</a></li>
<li><a class="reference internal" href="#id9">音频设备</a><ul>
<li><a class="reference internal" href="#id10">数字耳机</a></li>
<li><a class="reference internal" href="#id11">模拟耳机</a></li>
</ul>
</li>
<li><a class="reference internal" href="#dp-pcie">DP 模式 和 PCIe 模式</a><ul>
<li><a class="reference internal" href="#dp">DP接口</a></li>
<li><a class="reference internal" href="#usb-type-c-displayport">USB Type-C &amp; DisplayPort</a></li>
<li><a class="reference internal" href="#usb-dp-source-sink">USB&amp;DP Source &amp; Sink 连接情况</a></li>
<li><a class="reference internal" href="#dp-alt-mode">如何触发 DP Alt Mode</a></li>
<li><a class="reference internal" href="#mux-pi3usb30532">mux驱动实例（PI3USB30532）</a></li>
</ul>
</li>
<li><a class="reference internal" href="#mtk-log">MTK log实例分析</a><ul>
<li><a class="reference internal" href="#m8drp-drp">1.M8项目DRP 到 DRP</a></li>
</ul>
</li>
<li><a class="reference internal" href="#pps">PPS介绍</a><ul>
<li><a class="reference internal" href="#ppspd">pps协议和pd有什么区别</a></li>
</ul>
</li>
</ul>
</div>
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">wugn_note</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs"> 
<li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
<li>概述</li>
<li style="float: right;margin-left: 10px;"><a href="javascript:history.forward()">Forward</a></li>
<li style="float: right;margin-left: 10px;"><a href="javascript:history.back()">Go Back</a> | </li>
<li style="float: right;margin-left: 10px;"><a href="/index.html">Home</a> | </li>

      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="id1">
<h1>概述<a class="headerlink" href="#id1" title="此标题的永久链接"></a></h1>
<p>Linux TypeC功能介绍，总结详细，看着一篇就够。</p>
</section>
<section id="id2">
<h1>参考<a class="headerlink" href="#id2" title="此标题的永久链接"></a></h1>
<ul class="simple">
<li><p><a class="reference external" href="https://www.usb.org/documents">官方网站资料下载</a></p></li>
<li><p><a class="reference external" href="https://www.cnblogs.com/linhaostudy/p/15176304.html">TypeC基础知识</a></p></li>
<li><p><span class="xref myst">USB Type-C Spec R2.1 - May 2021.pdf</span></p></li>
<li><p><a class="reference external" href="https://www.jianshu.com/p/2ac67e2290b1">TypeC充电方向小结</a></p></li>
<li><p><a class="reference external" href="https://zhuanlan.zhihu.com/p/26460426">一次失败的USB Type C告白</a></p></li>
<li><p><a class="reference external" href="https://blog.csdn.net/weixin_43772512/article/details/123307773?spm=1001.2101.3001.6650.2&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-2-123307773-blog-108134556.pc_relevant_default&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-2-123307773-blog-108134556.pc_relevant_default&amp;utm_relevant_index=5">一文详解Type C-CC引脚的作用</a></p></li>
<li><p><a class="reference external" href="https://zhuanlan.zhihu.com/p/145827014">细谈Type-C、PD原理（上）</a></p></li>
<li><p><a class="reference external" href="https://www.graniteriverlabs.com.cn/technical-blog/usb-pd-power-delivery-spec-versions/">Power Delivery的源起与规格</a></p></li>
<li><p><a class="reference external" href="https://www.graniteriverlabs.com.cn/technical-blog/application-notes-usbc-role-swap/">USB Type-C Power Delivery 的角色交换功能</a></p></li>
</ul>
</section>
<section id="typec">
<h1>TypeC 基本特性<a class="headerlink" href="#typec" title="此标题的永久链接"></a></h1>
<ul class="simple">
<li><p>正反插</p></li>
<li><p>速度快 10Gbps</p></li>
<li><p>但不支持Dual Role功能，及power、data是绑定的，不能独立协商。</p></li>
</ul>
</section>
<section id="type-c-portdata-rolepower-role">
<h1>Type-C Port的Data Role、Power Role<a class="headerlink" href="#type-c-portdata-rolepower-role" title="此标题的永久链接"></a></h1>
<p>2.1 Type-C的 Data Role</p>
<p>在USB2.0端口，USB根据数据传输的方向定义了HOST/Device/OTG三种角色，其中OTG即可作为HOST，也可作为Device，在Type-C中，也有类似的定义，只是名字有了些许修改。如下所示：</p>
<p>（1）DFP(Downstream Facing Port)：</p>
<p>下行端口，可以理解为Host或者是HUB，DFP提供VBUS、VCONN，可以接收数据。在协议规范中DFP特指数据的下行传输，笼统意义上指的是数据下行和对外提供电源的设备。其中DFP-U表示USB的Host,DFP-D表示DP的Source</p>
<p>（2）UFP（Upstream Facing Port）：</p>
<p>上行端口，可以理解为Device，UFP从VBUS中取电，并可提供数据。典型设备是U盘，移动硬盘。其中UFP-U表示USB的Device,UFP-D表示DP的Sink</p>
<p>（3）DRP（Dual Role Port）：请注意DRP分为DRD(Dual Role Data)/DRP(Dual Role Power)</p>
<p>双角色端口，类似于以前的OTG，DRP既可以做DFP(Host)，也可以做UFP(Device)，也可以在DFP与UFP间动态切换。典型的DRP设备是笔记本电脑。设备刚连接时作为哪一种角色，由端口的Power Role（参考后面的介绍）决定；后续也可以通过switch过程更改（如果支持USB PD协议的话）。</p>
<p>2.2 Type-C的Power Role</p>
<p>根据USB PORT的供电（或者受电）情况，USB Type-C将port划分为Source、Sink等power角色</p>
<p>如下图显示常用设备的Data Role和Power Role</p>
<p><img alt="0001_0024.png" src="../../../_images/0001_0024.png" /></p>
<p>Power Role 详细可以分为：</p>
<p>a）Source Only</p>
<p>b）默认Source，但是偶尔能够通过PD SWAP切换为SINK模式</p>
<p>c）Sink Only</p>
<p>d）默认SINK，但是偶尔能够通过PD SWAP切换为Source模式</p>
<p>e）Source/SINK 轮换</p>
<p>f）Sourcing Device （能供电的Device，显示器）</p>
<p>g）Sinking Host（吃电的Host，笔记本电脑）</p>
</section>
<section id="id3">
<h1>硬件引脚定义<a class="headerlink" href="#id3" title="此标题的永久链接"></a></h1>
<p><img alt="0001_0000.png" src="../../../_images/0001_0000.png" /></p>
<ul class="simple">
<li><p>VBus：总线电源，USB PD协议可配置电压，最大20V 5A,Vbus 电源 和 GND 都有 4 个，这也是为何可以达到 100W 的原因。</p></li>
<li><p>GND：地线</p></li>
<li><p>TxRx：Tx1 Rx1   Tx2 Rx2 两组数据传输信号，USB3.1标准</p></li>
<li><p>CC：CC1和CC2，两个关键引脚，作用很多：</p>
<ul>
<li><p>区分正反面</p></li>
<li><p>区分 DFP （Host）和 UFP（Device）</p></li>
<li><p>配置 VBUS，有 USB TypeC 和 USB Power Delivery 两种模式</p></li>
<li><p>配置 Vconn，当线缆中有芯片时，一个 CC 传输信号，一个 CC 变成供电 Vconn</p></li>
<li><p>配置其他模式，比如接音频时、dp时、pcie时 等等。</p></li>
</ul>
</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>探测连接，区分正反面，区分DFP和UFP，也就是主从（虽然typec支持正反插，但typec的点定义并不完全对称，比如Rx1，翻转插头再插入就是Rx2，所以需要系统识别插头的正反插情况，用来正确配置Tx和Rx的连接通讯，虽然定义里有CC1和CC2，但是线缆里只有一根cc线，正反插可以连接不同的引脚，通过读取上下拉电平，从而识别插头的方向）；

配置Vbus，有USB Type-C和USB Power Delivery两种模式；
配置Vconn，当线缆里有芯片的时候，一个cc传输信号，一个cc变成供电Vconn，用来给线缆里的芯片供电（3.3V或5V）；
配置其他模式，如接音频配件时，DP，PCIe时；
</pre></div>
</div>
<ul class="simple">
<li><p>D+D-：用来兼容USB2.0协议的数据传输，音频复用时也是L R信号</p></li>
<li><p>SBU：复用引脚，和usb协议本身关系不大，复用为其他端口时使用</p></li>
</ul>
</section>
<section id="cc">
<h1>为什需要CC检测<a class="headerlink" href="#cc" title="此标题的永久链接"></a></h1>
<ul class="simple">
<li><p>主要原因是如果信号线还是被简单地一分二的话，不连续的信号线阻抗将严重破坏数据传输质量，因此必须由MUX切换来保证信号路径阻抗的一致性，以确保信号传输质量。</p></li>
</ul>
<p>虽然USB Type-C插座和插头的两排管脚对称，USB数据信号都有两组重复的通道，但主控芯片通常只有一组TX/RX和D+/-通道（某些芯片有两组TX/RX和D+/-通道）。</p>
<p>由于USB2.0的数据率最高只有480Mbps, 可以不考虑信号走线的阻抗连续性，USB2.0的D+/-信号可以不被MUX控制而直接从主控芯片走线，然后一分二连接至USB Type-C插座的两组D+/-管脚上。</p>
<p>但USB3.0或者USB3.1的数据率高达5Gbps或者10Gbps，如果信号线还是被简单地一分二的话，不连续的信号线阻抗将严重破坏数据传输质量，因此必须由MUX切换来保证信号路径阻抗的一致性，以确保信号传输质量。</p>
<p>下图中右侧所示的MUX从TX1/RX1和TX2/RX2中选择一路连接至主控芯片，而这个MUX就必须被CC管脚控制。</p>
<p>在USB2.0应用中，无需考虑CC方向检测问题，但USB3.0或者USB3.1应用中，必须考虑CC方向检测问题。</p>
<p><img alt="0001_0001.png" src="../../../_images/0001_0001.png" /></p>
</section>
<section id="type-cpd">
<h1>Type-C和PD有什么区别<a class="headerlink" href="#type-cpd" title="此标题的永久链接"></a></h1>
<p>在日常生活中，经常会有小伙伴将USB PD快充 与 Type-C接口混为一谈，或者将PD快充接口叫成Type-C 接口，其实这种认识是完全错误的。USB PD是一种快充协议，而Type-C接口是一种USB接口外形标准，两者完全不是一个概念！</p>
<section id="pd-type-c">
<h2>PD是指传输协议，Type-c是指接口。<a class="headerlink" href="#pd-type-c" title="此标题的永久链接"></a></h2>
<p>PD协议是目前的快充协议之一，是由USB-IF组织制定的一种快速充电规范。USB PD透过USB电缆和连接器增加电力输送，扩展USB应用中的电缆总线供电能力。该规范可实现更高的电压和电流，输送的功率最高可达100瓦，并可以自由改变电力的输送方向。目前该快充协议发展至今已有多个版本，包括PD2.0 / PD3.0 / PD3.1等。其中，最新版本USB PD3.1，相较USB PD3.0最大的区别是在输出 20V 电压的基础上，新增了 28、36、48V 三组输出电压档位，将 USB PD 3.0 最大输出的 100W 功率提升到 140W、180W 和 240W，让接口可以承载更高的功率，从而服务更大功率的设备，如游戏本、家电，甚至是电动工具、电瓶车等。</p>
<p>Type-C是充电接口，具备传统USB-A口不具备的多种优点，可以正反随插；能够支持USB3.1（Gen1和Gen2）、DisplayPort和USBPD等一系列新标准，最高速率可达10Gbps，Type-C端口默认最高可支持5V3A。</p>
</section>
<section id="type-c-pd">
<h2>市场上Type-C/PD有哪几种分类？<a class="headerlink" href="#type-c-pd" title="此标题的永久链接"></a></h2>
<p>市场上TypeC的产品种类很多，但真正全功能的很少。因为如果你把这个TypeC所有的功能都集成进去的话,这个口的整个的成本会变得非常贵。</p>
<p>实际上很多情况下，设备只是具备了TypeC的某一部分功能：</p>
<ul class="simple">
<li><p>只有Type-C，即支持正反插，普通数据传输；</p></li>
<li><p>支持Type-C，支持PD协议，可快速充电；</p></li>
<li><p>支持Type-C，支持PD协议，支持高速信号，支持超快充电；</p></li>
<li><p>全功能，支持Type-C，支持PD协议，支持高速信号，支持超快充电，支持HDMI、DisplayPort等其他协议。</p></li>
</ul>
</section>
</section>
<section id="pd-dual-role">
<h1>PD Dual Role功能<a class="headerlink" href="#pd-dual-role" title="此标题的永久链接"></a></h1>
<p>参考:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://www.graniteriverlabs.com.cn/technical-blog/application-notes-usbc-role-swap/">USB Type-C Power Delivery 的角色交换功能</a></p></li>
</ul>
<p>在还没有Type-C及Power Delivery（PD）问世前，传统的USB 世界里是没有Dual Role这个角色的，Data与Power 角色是非独立运作的，言下之意是作为Host 的一方必然成为DFP及Source，而作为Device的一方则为UFP及Sink。然而，Type-C PD的出现打破了这个规则，Data与Power 角色可以独立运作，作为DFP的角色可以成为Sink，反之，UFP也能成为Source。</p>
<p>本篇文章将为大家说明，在PD沟通协议的帮助下，USB Type-C 的Power和Data角色如何沟通及切换，也就是常听到的Power Role Swap（PR Swap）、VCONN Swap（VCONN Swap）、Data Role Swap（DR Swap）和Fast Role Swap （FR Swap）。</p>
<p>首先简单、快速地介绍一下Type-C角色的定义以及架构，分为Data及Power角色</p>
<section id="type-c-data">
<h2>Type-C Data角色定义<a class="headerlink" href="#type-c-data" title="此标题的永久链接"></a></h2>
<p><img alt="0001_0026.png" src="../../../_images/0001_0026.png" /></p>
</section>
<section id="type-c-power">
<h2>Type-C Power角色定义<a class="headerlink" href="#type-c-power" title="此标题的永久链接"></a></h2>
<p><img alt="0001_0027.png" src="../../../_images/0001_0027.png" /></p>
</section>
<section id="power-role-swap">
<h2>Power Role Swap功能介绍<a class="headerlink" href="#power-role-swap" title="此标题的永久链接"></a></h2>
<p>当今天做PD沟通的两端皆为DRP时，若双方都没有Try.SRC或Try.SNK的能力（尝试作为SRC或SNK），那么当双方对接上后作为Source 或Sink的机率是随机的，所以在完成初步的PD协议后成为Source或是成为Sink 的一方可能并不是产品偏好的状态或是当前合适的角色，因此双方在完成初步的PD 协议后，会依据产品当下的电力状态（如Source/Sink Capability或有无External Power）及其产品偏好发起Power 角色调换的要求，即Power Role Swap（PR Swap）。</p>
<p>举例来说，一般情况下Type-C笔电通常会在对接刚完成后成为Source，但当笔电接上带有外接电源的Dock时，Dock或笔电经常会发起Power Role Swap。原因是大多数的笔电其Source Cap.只有15W且带有电池需要被充电，而Dock 的Source Cap.常是大于15W甚至是60W以上，所以当笔电电源不足或未接上笔电本身的电源供应器时，多数情况下Dock作为Source的能力会比笔电来的好，当然，这并不是绝对的，是否能够完成PR Swap，仍需视双方是否能够完成PR Swap 的协议来决定。</p>
<p>那么，谁能够负责发起PR_Swap的讯息呢？笔电还是Dock？Source还是Sink？答案是，Source和Sink 双方皆可。但收到PR_Swap 要求的一方也可以视自身能力和当前状况响应「接受（Accept）」、「拒绝（Reject）」或「等待（Wait）」的讯息来决定是否进行PR Swap的动作。</p>
<p>下图我们以Sink发起PR_Swap讯息为例，说明PR Swap 一连串的过程及PD规范中对于PR Swap时CC切换和VBus电压转换的流程，图三则是利用GRL-A1记录下VBus在PR Swap 过程的变化:
<img alt="0001_0028.png" src="../../../_images/0001_0028.png" />
<img alt="0001_0029.png" src="../../../_images/0001_0029.png" /></p>
<p>PR Swap流程图说明：</p>
<ul class="simple">
<li><p>#1 Sink 在发起PR_Swap后，</p></li>
<li><p>#2、#3 Source接受PR Swap后发出Accept 的讯息并将CC Pin上的Rp切换到Rd后发出PS_RDY成为New Sink。假如初始Source 不接受PR Swap或是正在忙碌需要Sink 等待，则可在收到PR_Swap的请求后分别发出Reject 和Wait的讯息。</p></li>
<li><p>#4当初始Sink 收到从New Sink发出的PS_RDY后，原始Sink 也会将Rd切换到Rp成为New Source并发出PS_RDY，此时，PR Swap基本上就完成了。 最后New Source 会再发出新的Source Cap.与New Sink完成新的PD协议。</p></li>
</ul>
<p>对于Source、Sink电压转换、切换时间规范，可以参考下图四和和表二，在PD测试规范中明确规范了Initial Source 的VBus在收到Initial Sink对Accept讯息发出的GoodCRC后，要在tSrcTransition时间开始切换到standby 状态，并在tSrcSwapStdby (t2) 时间降至0V，切换成New Sink，最后发出PS_RDY从而启动PSSoucreOnTimer。而Initial Sink 在收到Accept讯息后，启动PSSourceOffTimer，在Initial Soure切换到Standby之前关掉电流的拉载，并在收到New Sink 的PS_RDY后停止PSSourceOffTimer，转换成为New Source，最后在tNewSrc(t3)时间重新上电回到Vsafe5V发出PS_RDY。New Sink收到NewSource发出的PS_RDY后回GoodCRC，New Source便可开始新的PD 协议。</p>
<p>PD Spec. 规范Sink 要求PR Swap 的切换流程：</p>
<p><img alt="0001_0030.png" src="../../../_images/0001_0030.png" /></p>
<p>PR Swap时间参数：</p>
<p><img alt="0001_0031.png" src="../../../_images/0001_0031.png" /></p>
<p>值得留意的是，在整个PR Swap的过程中，我们完全没有提到Data和VCONN的角色，因为Data的角色及VCONN Source并不会因PR Swap而改变，即使VBus会因PR Swap的过程将VBus切断再重新上电，但PD重新沟通后的Data和VCONN皆不会因为PR Swap对调而改变。意即，若一开始为DFP，那么在PR Swap过后，DFP仍为DFP，VCONN Source的一方仍为VCONN Source。</p>
</section>
<section id="data-role-swap">
<h2>Data Role Swap功能介绍<a class="headerlink" href="#data-role-swap" title="此标题的永久链接"></a></h2>
<p>了解Power Role的角色转换之后，接着我们看到Data角色的转换，Data Role Swap （DR Swap）同样是利用PD协议来完成。那么为什么需要DR Swap呢？因为对于DRP 的Data角色来说，双方一对接上，并在完成第一次的PD协议之前，随机成为Source的一方会预设为DFP，反之，Sink则为UFP，所以当初步的PD协议完成后，产品一样也可以依照需求提出DR Swap的要求。</p>
<p>DR Swap的整个流程相对于PR Swap来说简单的多，要留意的是，若收到DR_Swap Requst的当下，DFP/UFP已进入任一Active Mode，那么在进行DR Swap前需先执行Hard Reset使双方离开Active Mode 再重新PD 协议，若Cable也在Active Mode时，则Cable也需先离开Active Mode。</p>
<p>那DR Swap过程对于VBus、VCONN有影响吗？除非双方已进入Active Mode 所以在DR Swap前需要进行Hard Reset 的动作，否则，VBus 、VCONN在DR Swap的过程中是不会中断的，亦即VBus 会维持供电，CC上的Rp、Rd也不会调动。</p>
</section>
<section id="fast-role-swap">
<h2>Fast Role Swap功能介绍<a class="headerlink" href="#fast-role-swap" title="此标题的永久链接"></a></h2>
<p>最后介绍Fast Role Swap（FR_Swap），FR Swap 其实也是一种PR Swap，只是FR Swap是发生在较紧急的状态下需要快速的切换Power 角色，因此整个流程会跟PR Swap有些许的不同。</p>
<p>举例来说，下图是一般状态下Host、Dock、Device的连接状态，Dock作为Host 和Device一开始的Source供电来源（Initial Source），但Dock本身的电源突然断了，此时为了维持Device的连接及数据的传输，Host和dock之间便会进行FR Swap的动作，使Host快速地成为Source。</p>
<p>另外，并非所以市售产品都支持FR Swap，要能够进行FR Swap的先决条件必须连接双方都支持此项功能，FR Swap才得以进行。</p>
<p><img alt="0001_0032.png" src="../../../_images/0001_0032.png" /></p>
<p>下图可以完整的了解到整个FR Swap 的流程。当Dock侦测到电压下降，会随即发出一个Fast Role Swap signal，Host 接收到讯号后，便会传送FR_Swap的讯息用以完成Source 和Sink 角色的交换，后面的沟通流程大致与PR Swap相同。除了在Role Swap讯息沟通前会有一个Fast Role Swap Signal外，FR Swap与PR Swap 最大的不同， 可以说是VBus的切换时间， 若原先Dock与Host之间的VBus电压 &gt;5V，那么当Sink 发现VBus &lt; VSafe5V时，Sink随时都会供给VBus电源，即便此时的Sink 尚未完成FR Swap的 PD 沟通成为Source，Sink（Host）在此时为了维持与Dock之间的连接以及和Device的数据传输而紧急供给VSafe5V。</p>
<p><img alt="0001_0033.png" src="../../../_images/0001_0033.png" /></p>
</section>
<section id="id4">
<h2>总结<a class="headerlink" href="#id4" title="此标题的永久链接"></a></h2>
<p>Role Swap的设计给予Type-C Power和Data角色转换更大的弹性，即便连接上时有Source为DFP、Sink为UFP的预设角色，双方仍可以根据当下的连接状态重新沟通决定Power/Data的角色，且不会因为Power/Data Role Swap而改变 Data/Power的角色。</p>
</section>
</section>
<section id="id5">
<h1>CC正反方向确认<a class="headerlink" href="#id5" title="此标题的永久链接"></a></h1>
<p>CC信号有两根线，CC1和CC2，大部分USB线（不带芯片的线缆）里面只有一根CC线，DFP可根据两根CC线上的电压，判断是否已经插入设备。通过判断哪根CC线上有下拉电阻来判断方向，下图的说明已经非常清晰。</p>
<p><img alt="0001_0002.png" src="../../../_images/0001_00021.png" /></p>
<ul class="simple">
<li><p>如果CC1引脚检测到有效的Rp/Rd连接（对应的电压），则认为电缆连接未翻转。</p></li>
<li><p>如果CC2引脚检测到有效的Rp/Rd连接（对应的电压），则认为电缆连接已翻转。</p></li>
</ul>
<p>“有效的Rp/Rd连接”指在CC上形成了有效的电压。从DFP的角度看，下表列出了所有可能的连接状态，</p>
<p><img alt="0001_0003.png" src="../../../_images/0001_00032.png" /></p>
<p>DFP（下行端口）为主机端口，UFP（上行端口）为设备端口。如图所示，在DFP上有两个CC引脚，DFP通过检测三种不同形式的UFP端下拉电阻（Open开路、Ra=0.8-1.2K、Rd=5.1K）来识别各种配置模式。</p>
<p><img alt="0001_0017.png" src="../../../_images/0001_0017.png" />
<img alt="0001_0018.png" src="../../../_images/0001_0018.png" /></p>
</section>
<section id="id6">
<h1>TypeC 如何确定供电能力<a class="headerlink" href="#id6" title="此标题的永久链接"></a></h1>
<p>在没有供电协议(PD)功能时，Type-C接口可以提供5V的电压和900mA、1.5A或者3A的电流。供电方通过Rp上拉电阻值代表不同的电流能力，当连接上耗电方后，耗电方通过检测Rp的值就能确定供电方能够提供的电流能力。在有供电协议功能时，Type-C接口可以提供更高、更灵活的供电能力，最高可提供20V、5A的供电能力。</p>
<section id="dfprp">
<h2>DFP的上拉电阻Rp<a class="headerlink" href="#dfprp" title="此标题的永久链接"></a></h2>
<p>Rp有6个参数（5V档位和3.3V档位各3个），指示着不同的供电能力。</p>
<p>DFP的CC1和CC2信号上都必须有上拉电阻Rp，上拉到5V或3.3V。或者CC1和CC2都用电流源上拉。最终的目的是在插入后，能检测到CC1或CC2上的电压，进而判断是否翻转以及DFP的电流能力。如下是所有可能的配置。可以选择右边三列中的任何一列作为上拉方式，比如Fairchild的FUSB300就是用330uA上拉，TI的TUSB320LAI用的是80uA的上拉，不同的上拉方式在CC引脚上形成的电压不同，不同的电压对应不同的电流能力。</p>
<p><img alt="0001_0004.png" src="../../../_images/0001_00041.png" /></p>
</section>
<section id="upfrd">
<h2>UPF的下拉电阻Rd<a class="headerlink" href="#upfrd" title="此标题的永久链接"></a></h2>
<p>UFP的CC1和CC2管脚都要有一个下拉电阻Rd到GND（或者使用电压钳位），都是5.1K电阻下地，能否检测电源供电能力，取决于电阻的精度。Rd的处理方式如下表：</p>
<p><img alt="0001_0005.png" src="../../../_images/0001_00051.png" /></p>
<p>注意，最后一列的电流源连接至的电压，是指3.1节中表格的最后一列电流源的上拉电压。
结合这个表格，和3.1节的表格，我们把每种可能的上下拉范围都计算出了最终形成的电压范围，如下表（这个表算错了）。</p>
<p>举例来说，当DFP给CC引脚提供330uA的电流时，CC引脚上电压则为330uA * 5.1kOhms = 1.683V。根据下表，DFP则被识别为vRd-3.0标准。当DFP用10k电阻把CC引脚上拉至4.75~5.5V时，这里算成5v,CC引脚上的电压则为5/(10+5.1)*5.1=1.688V，DFP也会被识别为vRd-3.0标准。</p>
<p><img alt="0001_0006.png" src="../../../_images/0001_00061.png" /></p>
<p>UFP CC检测芯片会检测这个电压，通过判断电压范围来决定下一步操作。下表是CC管脚上不同的电压对应的DFP能提供的电流能力。第二列列出的每一种电压范围，都分别覆盖了上表计算出的电压。Rp/Ra的计算是同理的。</p>
<p><img alt="0001_0007.png" src="../../../_images/0001_0007.png" /></p>
</section>
<section id="vconn">
<h2>VCONN电源<a class="headerlink" href="#vconn" title="此标题的永久链接"></a></h2>
<p>VCONN的允许范围是4.75V~5.5V，要求供电能力是1W。默认情况下DFP提供这个电源。如果两个DRP连接，则双方可以通过USB PD协议协商来交换VCONN供电方。
支持PD的USB3.0接口均需支持VCONN，可以通过下面两种方式之一提供VCONN电源。</p>
<ul class="simple">
<li><p>如果其中一个CC引脚上检测到有效的Rp/Rd连接，则VCONN电源可以接到另一个对应的CC引脚。</p></li>
<li><p>如果其中一个CC引脚上检测到有效的Rp/Rd连接，先检查另一个CC引脚是否也有Rp/Ra连接，然后再提供VCONN。</p></li>
<li><p>先检测是否有Ra存在，如果有说明需要Vconn供电，此时再提供Vconn。检测过程不需要Vconn存在。</p></li>
</ul>
<p>注意，每一个CC引脚内部都有一个开关，轮训CC和VCONN功能，下图是一个典型的连接方式：</p>
<p><img alt="0001_0008.png" src="../../../_images/0001_00081.png" /></p>
</section>
<section id="ra">
<h2>数据线上的Ra<a class="headerlink" href="#ra" title="此标题的永久链接"></a></h2>
<p>带电子标签的线缆，其中一个CC管脚被更名为VCONN，用于给电子标签芯片供电。这个VCONN管脚与GND之间需要一个Ra电阻，这个电阻值范围是800Ω~1.2KΩ。</p>
</section>
<section id="id7">
<h2>举例<a class="headerlink" href="#id7" title="此标题的永久链接"></a></h2>
<ul class="simple">
<li><p>最初的时候，源端插座上的CC1和CC2都被电阻Rp上拉至高电平，吸端的CC1和CC2都被下拉电阻Rd下拉至低电平。</p></li>
<li><p>电缆接通以后，CC1或CC2根据电缆的插入方向而被上拉至较高电压。本案中的电缆没有处于扭转状态，源端的CC1和吸端的CC1之间被接通，CC1上出现由Rp和Rd分压以后的电压，此电压将由吸端进行测量并由此知道源端的电流供应能力是多少。</p></li>
<li><p>在此案例中，接通以后的CC1的电压大约是1.65V，意味着源端最大能供应3A电流。</p></li>
<li><p>CC线的连接被确定以后，VBUS上的5V电压将被接通。</p></li>
<li><p>在不含电源传输协议的系统中，总线上的电流供应能力由分压器Rp/Rd确定，但源端只会供应5V电压。</p></li>
</ul>
<p><img alt="0001_0023.png" src="../../../_images/0001_0023.png" /></p>
</section>
</section>
<section id="id8">
<h1>TypeC 如何确定充电方向<a class="headerlink" href="#id8" title="此标题的永久链接"></a></h1>
<p>TypeC 设备有三种形式：</p>
<ul class="simple">
<li><p>DFP（Downstream Facing Port）：只能作 Source（Host），CC线上拉电阻Rp，比如充电器。</p></li>
<li><p>UFP（Upstream Facing Port）：只能作 Sink（Device），CC线下拉电阻Rd；比如 U盘、鼠标、键盘、老款的手机（UFP TypeC 头的手机）。</p></li>
<li><p>DRP：两者都可以作。通过switch切换Rp Rd，比如新款的手机（DRP TypeC头的手机），平板，笔记本。</p></li>
</ul>
<p>所以，如果我们手上有一个 TypeC 的手机，有可能有两种情况：</p>
<ul class="simple">
<li><p>手机上是 UFP 的 C 母头。无论是接到充电器还是电脑，都会被充电。</p></li>
<li><p>手机上是 DRP 的 C 母头。</p></li>
<li><p>2.1 插到充电器，因为充电器只能作 DFP，所以手机会切换为 UFP，进而被充电</p></li>
<li><p>2.2 插到笔记本、另一台手机 或是 充电宝：</p>
<ul>
<li><p>2.2.1 手机、电脑、充电宝 会随机当 host 和 sink，每次插拔后角色互换（前提是支持 PD 协议）</p></li>
<li><p>2.2.2 手机、电脑、充电宝 有一方有作为 host 端的偏好设定。此时有偏好设定的一方会称为 host 端。</p></li>
</ul>
</li>
</ul>
<p>注：偏好设定是最新的 TypeC 规范中对 DRP 部分的描述，新增了两种类型：</p>
<ul class="simple">
<li><p>DRP try source：和DRP或者DRP try sink相连时，会连成Source。</p></li>
<li><p>DRP try sink：和DRP或者DRP try source相连时，会连成sink。</p></li>
</ul>
<p>接下来是几种角色端口的交互行为。</p>
<p>source连接状态图：</p>
<p><img alt="0001_0014.png" src="../../../_images/0001_0014.png" /></p>
<ul class="simple">
<li><p>sink连接状态图：</p></li>
</ul>
<p><img alt="0001_0015.png" src="../../../_images/0001_0015.png" /></p>
<ul class="simple">
<li><p>DRP连接状态图：</p></li>
</ul>
<p><img alt="0001_0016.png" src="../../../_images/0001_0016.png" /></p>
<section id="source-sink">
<h2>Source 到 Sink<a class="headerlink" href="#source-sink" title="此标题的永久链接"></a></h2>
<ul class="simple">
<li><p><span class="xref myst">参考spec</span></p></li>
</ul>
<p><img alt="0001_0012.png" src="../../../_images/0001_0012.png" /></p>
<ul class="simple">
<li><p>source 端状态：</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>1.有CC时，插入typec时Unattached.SRC -&gt; AttachWait.SRC，source通过CC检测到sink的下拉电阻Rd后，从状态AttachWait.SRC变成Attached.SRC:
 Unattached.SRC -&gt; AttachWait.SRC -&gt; Attached.SRC

2.没有CC，usb2.0没有AttachWait.SRC状态：
Unattached.SRC -&gt; Attached.SRC

3.拔出检测到CC悬空：
Attached.SRC -&gt; Unattached.SRC

第一步，Source和Sink在Unattached状态
第二步，Source通过CC检测到Sink的Rd，经过AttachWait.SRC进入Attached.SRC。Source并打开VBUS和VCONN。
第三步，Sink从Unattached.SNK经过AttachWait.SNK转为Attached.SNK。USB2.0不支持附件模式，直接跳过AttachWait.SNK状态，该过程是通过检测VBUS完成。
第四步，当Source和Sink在Attached状态了，Source调整Rp值限制Sink拉的电流，Sink检测和监视vRd看VBUS可用的电流，Source监视CC的Detach行为进入Unattached.SRC，Sink监视VBUS的Detach行为进入Unattached.SNK。
</pre></div>
</div>
<ul class="simple">
<li><p>sink 端状态：</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>1.有CC时，插入typec时Unattached.SNK -&gt; AttachWait.SNK，SINK通过检测到有效的vbus，从状态AttachWait.SNK变成Attached.SNK:
 Unattached.SNK -&gt; AttachWait.SNK -&gt; Attached.SNK

2.没有CC，usb2.0没有AttachWait.SINK状态：
Unattached.SNK -&gt; Attached.SNK

3.拔出检测到vbus关闭：
Attached.SNK -&gt; Unattached.SNK
</pre></div>
</div>
<p>简单描述一下就是，source和sink通过typec连接后，source通过CC检测到sink的下拉电阻Rd，认为有sink连接，source打开VBUS和VCONN（在另一条CC上），双方建立连接，并且source可以通过调整上拉电阻Rp的大小来控制vRd的电压值，sink通过检测vRd的大小从而得知sink能从vbus上拉多大的电流。</p>
</section>
<section id="source-drp">
<h2>Source 到 DRP<a class="headerlink" href="#source-drp" title="此标题的永久链接"></a></h2>
<p>引用TypeC SPEC：</p>
<p><img alt="0001_0013.png" src="../../../_images/0001_0013.png" /></p>
<p>DRP在未建立连接前，会不断切换连接上下拉电阻Rp和Rd（具体切换细节在下面分解）。</p>
<p>source和DRP通过typec连接后，在DRP连接Rd时，source通过CC检测到Rd，之后打开VBUS和VCONN；DRP检测到source的Rp，之后等source打开Vbus后，确认转换为sink，并正式建立连接。</p>
</section>
<section id="drp-sink">
<h2>DRP 到 Sink<a class="headerlink" href="#drp-sink" title="此标题的永久链接"></a></h2>
<p>情况与上一种情况类似，不再赘述。</p>
</section>
<section id="drp-drp">
<h2>DRP 到 DRP<a class="headerlink" href="#drp-drp" title="此标题的永久链接"></a></h2>
<section id="drprole">
<h3>1.两个DRP端口相连怎样分配role<a class="headerlink" href="#drprole" title="此标题的永久链接"></a></h3>
<p>现实中，我们的手机都是DRP，既能做DFP，又能做UFP，那么是如何切换呢？</p>
<p>DRP在待机模式下每50ms在DFP和UFP间切换一次。当切换至DFP时，CC管脚上必须有一个上拉至VBUS的电阻Rp或者输出一个电流源，当切换至UFP时，CC管脚上必须有一个下拉至GND的电阻Rd。此切换动作必须由CC Logic芯片来完成。当DFP检测到UFP插入之后才可以输出VBUS，当UFP拔出以后必须关闭VBUS。此动作必须由CC Logic芯片来完成。下面是一个CC逻辑芯片框图，CC上有一个开关，在不断切换功能。</p>
<p><img alt="0001_0009.png" src="../../../_images/0001_00091.png" /></p>
<p>此为某手机内部CC Logic芯片的内部框架图，可以看到CC Pin内部有个开关在RP与RD切换。</p>
<p><img alt="0001_0020.png" src="../../../_images/0001_0020.png" /></p>
</section>
<section id="drpfail">
<h3>2.疑问：是否会出现两个DRP切换周期一直同步而导致的配对过程无限fail的情况<a class="headerlink" href="#drpfail" title="此标题的永久链接"></a></h3>
<p>此种情况最为复杂，因为DRP也可以分为三种角色，普通DRP，DRP try source，DRP try sink，即有些DRP，在DRP之间的连接中，会有prefer的角色，比如笔记本和手机，肯定都是DRP，但是笔记本可能会设定为try source，因为笔记本毕竟电池容量比较大，如果将笔记本和手机相连，最好还是笔记本作为source给手机充电，而不要反过来，但是笔记本与墙插充电器相连时，笔记本肯定是sink。</p>
<p>在typec spec中，DRP和DRP相连的行为中，提到了3个case，case2和case3就是有一方DRP是try source或try sink的情况，这两种情况比较复杂，这里不展开了，有兴趣可以详细查阅，这里只给出case1，两个普通DRP之间相连的情况。</p>
<p><img alt="0001_0010.png" src="../../../_images/0001_00101.png" /></p>
<p>未正式建立连接时，两个DRP都在各自不断切换上下拉电阻，当有一时刻，DRP1是上拉电阻，DRP2是下拉电阻状态，然后接下来就和Source 到 Sink的情况是一样的。因为两个DRP状态是不断切换的，所以连接时刻的DRP各自的状态就决定了连接后的主从关系，当然如果某一时刻两个DRP都是上拉或下拉，那连接行为最终会失败，DRP重新进入不断切换状态等待连接。</p>
<p>那是否会有一种极端情况，两个DRP切换状态太同步了，一直是同上拉，同下拉，那这两个DRP是不是就一直不能连接了，这就涉及到了DRP切换周期的问题。</p>
<p>还是回溯到SPEC中：</p>
<p><img alt="0001_0011.png" src="../../../_images/0001_0011.png" /></p>
<p>可以看出，SPEC定义了DRP 切换source和sink的一个完整swap周期为tDRP，其中dcSRC.DRP为整个周期中DRP作为source的百分比。SPEC明确说明了，用于控制这个周期和百分比的时钟，不能来自于一个特别准确的时钟源如晶振或陶瓷晶振等，以此来最小化两个DRP在配对过程中出现无限失败的问题。而对于各周期的上下限也非常宽裕，所以实际情况下各DRP的周期会不尽相同，不会出现两个DRP切换周期一直同步而导致的配对过程无限fail的情况。</p>
<p>所以结论是，两个DRP连接结果是主从随机的，这也符合我一开始用两台手机试验的结果。</p>
</section>
</section>
</section>
<section id="type-c">
<h1>带电子标签的Type-C数据线<a class="headerlink" href="#type-c" title="此标题的永久链接"></a></h1>
<p>如果Type-C数据线上带了芯片（我们称之为电子标签），这个芯片可以通过USB供电规范2.0 BMC协议与USB端口通信。电子标签电缆可用VCONN供电，也可以直接由Vbus供电，最高可消耗70mW的功率。如下类型的电缆必须要电子标签：</p>
<ul class="simple">
<li><p>兼容USB3.1的USB Type-C电缆。</p></li>
<li><p>100W供电电缆。能够实现60W以上功率承载能力的任何电缆都必须有电子标签，并且能够与DFP端口通信。带电子标签的电缆如果插入不支持USB供电规范2.0的插座中，其行为与标准的无源电缆完全相同。</p></li>
</ul>
</section>
<section id="id9">
<h1>音频设备<a class="headerlink" href="#id9" title="此标题的永久链接"></a></h1>
<p>当CC1和CC2引脚同时使用Ra下拉时，主机将把设备识别成音频设备，然后从USB信号切换至音频信号。</p>
<p>Host端如何识别到音频模式呢？把CC引脚和VCON连接，并且下拉电阻小于Ra/2(则小于400ohm)，或者分别对地，下拉电阻小于Ra(小于800ohm)，则Host会识别为音频模式。</p>
<p><img alt="0001_0021.png" src="../../../_images/0001_0021.png" /></p>
<p>从图中也可以同时看出来，接入音频设备时，Dp接入耳机的右声道，Dn接入耳机的左声道。SBU则连接至MIC。</p>
<p><img alt="0001_0022.png" src="../../../_images/0001_0022.png" /></p>
<section id="id10">
<h2>数字耳机<a class="headerlink" href="#id10" title="此标题的永久链接"></a></h2>
<p>Type-C接口的数字耳机是一个UFP（Device），手机是DFP。耳机的CC1和CC2引脚上必须有Rd，实际上，乐视数字耳机的CC管脚上有一颗5.1K电阻。</p>
</section>
<section id="id11">
<h2>模拟耳机<a class="headerlink" href="#id11" title="此标题的永久链接"></a></h2>
<p>协议要求模拟耳机转接线上把两个CC引脚直接接到GND（必须小于Ra）。</p>
</section>
</section>
<section id="dp-pcie">
<h1>DP 模式 和 PCIe 模式<a class="headerlink" href="#dp-pcie" title="此标题的永久链接"></a></h1>
<p>在USB3.2 Gen1和Gen2 中，他们使用一组两个差分对四根线分别实现 5Gbps 和 10Gbps 的收发活动即SSTX 差分对和SSRX 差分对。</p>
<p>因此在USB中 一组收发 可以实现 10Gbps的 双向传输，USB3.2 Gen2x2可以启用两组共四对信号，因此可以实现 20Gbps 双向传输（是的，Gen2不需要D+D-来传输，Gen2 跟 Gen2x2 只是量变，Gen1 到 Gen2 才是质变，而只使用D+D- 的USB2.0则跟USB3.0可以算是两个物种了）</p>
<p><img alt="0001_0034.png" src="../../../_images/0001_0034.png" /></p>
<section id="dp">
<h2>DP接口<a class="headerlink" href="#dp" title="此标题的永久链接"></a></h2>
<p>一个完整的DP接口同样含有4对主要连接差分对，Mian Link Lane 0~3 (以下简称ML）</p>
<p>在HBR2下可以完成 每Lane 5.4Gbps的单向传输，HBR3下则是8.1Gbps</p>
<p>除此之外，DP接口还内置了Configuration 1&amp;2 用于协议配置，Auxiliary Channel +&amp;- （以下简称Aux对）用于音频传输，有趣的是，DP同样可以在仅 ML0，ML1 两条Lane的模式下工作。
USB PD是在CC(Configuration Channel) pin上传输，PD有个VDM (Vendor defined message)功能，定义了装置端ID，读到支持DP或PCIe的装置，DFP就进入替代（alternate）模式。</p>
</section>
<section id="usb-type-c-displayport">
<h2>USB Type-C &amp; DisplayPort<a class="headerlink" href="#usb-type-c-displayport" title="此标题的永久链接"></a></h2>
<p>如果DFP认到device为DP，便切换MUX/Configuration Switch，让Type-C USB3.1信号脚改为传输DP信号。AUX辅助由Type-C的SBU1,SUB2来传。HPD是检测脚，和CC差不多，所以共用。</p>
<p>而 DP 有 lane0-3 四组差分信号， Type-C 有 RX/TX1-2 也是四组差分信号，所以完全替代没问题。而且在 DP 协议里的替代模式，可以 USB 信号和 DP 信号同时传输，RX/TX1 传输 USB 数据，RX/TX2 替换为 lane0,1 两组数据传输，此时可支持到 4k。</p>
<ul class="simple">
<li><p>（1）DP Alt Mode 4Lane
DP有lane0-3四组差分信号， Type-C有RX/TX1-2也是四组差分信号，所以完全替代没问题。</p></li>
</ul>
<p><img alt="0001_0035.png" src="../../../_images/0001_0035.png" /></p>
<p>当激活成 DP Alt Mode 4Lane 时：</p>
<p><img alt="0001_0036.png" src="../../../_images/0001_0036.png" /></p>
<ul class="simple">
<li><p>（2）DP Alt Mode 2Lane
DP协议里的替代模式，可以USB信号和DP信号同时传输，RX/TX1传输USB数据，RX/TX2替换为lane0,1两组数据传输，此时可支持到4k。</p></li>
</ul>
<p><img alt="0001_0037.png" src="../../../_images/0001_0037.png" /></p>
<p>当激活 DP Alt Mode 2Lane （Multi-Function DisplayPort,MFDP) 时，针脚功能如下：</p>
<p><img alt="0001_0038.png" src="../../../_images/0001_0038.png" /></p>
</section>
<section id="usb-dp-source-sink">
<h2>USB&amp;DP Source &amp; Sink 连接情况<a class="headerlink" href="#usb-dp-source-sink" title="此标题的永久链接"></a></h2>
<p><img alt="0001_0039.png" src="../../../_images/0001_0039.png" />
<img alt="0001_0040.png" src="../../../_images/0001_0040.png" />
<img alt="0001_0041.png" src="../../../_images/0001_0041.png" /></p>
<p>如果 DFP 认到 device 为 DP，便切换 MUX/Configuration Switch，让 Type-C USB3.1 信号脚改为传输 PCIe 信号。同样的，PCIe 使用 RX/TX2 和 SBU1,SUB2 来传输数据，RX/TX1 传输 USB 数据。这样的好处就是一个接口同时使用两种设备，当然了，转换线就可以做到，不用任何芯片。</p>
<p><img alt="0001_0025.png" src="../../../_images/0001_0025.png" /></p>
</section>
<section id="dp-alt-mode">
<h2>如何触发 DP Alt Mode<a class="headerlink" href="#dp-alt-mode" title="此标题的永久链接"></a></h2>
<p>如上文提到的， 不管是DP Alt Mode 还是上面提到的 Virtual Link，抑或是雷电，都是作为Alt Mode 触发的，而触发方式，都是通过Power Delivery 的通信功能.</p>
<p><img alt="0001_0042.png" src="../../../_images/0001_0042.png" /></p>
<ul class="simple">
<li><p>Type-C Alt Mode 大致配置流程如下：</p>
<ul>
<li><p>1、USB 连接 通过CC侦测到</p></li>
<li><p>2、VBUS 引脚 提供默认电源配置 5V&#64;500mA</p></li>
<li><p>3、VBUS 所需的额外USB电力传输可以进行协商，Battery Charge 1.2（BC 1.2）或USB PD 都可以选择</p></li>
<li><p>4、使用 结构化 供应商定义报文（VDM） 需要USB PD 来发送来协商 Alt Mode 握手</p></li>
<li><p>5、USB 枚举</p></li>
<li><p>6、如果 DP Alt Mode 协商已经完成，继续进行DP link training来建立DP连接</p></li>
<li><p>7、USB和DP频道准备就绪进行Type-C 数据和视频信号传输。</p></li>
</ul>
</li>
</ul>
</section>
<section id="mux-pi3usb30532">
<h2>mux驱动实例（PI3USB30532）<a class="headerlink" href="#mux-pi3usb30532" title="此标题的永久链接"></a></h2>
<p>PI3USB30532用于通过USB 3.0 Type-C连接器切换USB 3.0和/或DP1.2 (PIUSB30532)或USB 3.1 Gen1/Gen2和/或DP1.2/DP1.4 (PI3USB31532)信号。PI3USB30532复用USB 3.0的一个通道，USB 3.0的一个通道，和DP1.2的2通道或DP1.2的4通道到USB Type-C连接器。而PI3USB31532将USB 3.1 Gen1/Gen2的一个通道、USB 3.1 Gen1/Gen2的一个通道和DP1.2/1.4的2通道或DP1.2/DP1.4的4通道复用到USB Type-C连接器。此外，AUX/HPD通道也多路复用到c型连接器。PI3USB30532和PI3USB31532为高速信号和低功耗提供了良好的信号完整性。</p>
<p><img alt="0001_0043.png" src="../../../_images/0001_0043.png" /></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">drivers/usb/typec/mux/pi3usb30532.c</span></code>将接口<code class="docutils literal notranslate"><span class="pre">pi3usb30532_mux_set;</span></code>和<code class="docutils literal notranslate"><span class="pre">pi3usb30532_sw_set</span></code>注册到typec中，typec根据DP Alt Mode 协商后，使用该接口继续进行DP link training来建立DP连接。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pi3usb30532_mux_set</span></code>有四种配置：</p>
<ul>
<li><p>CONF_OPEN</p></li>
<li><p>CONF_USB3 （USB3.0）</p></li>
<li><p>4LANE_DP（DP Alt Mode 4Lane）</p></li>
<li><p>USB3_AND_2LANE_DP （DP Alt Mode 2Lane + USB）</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">pi3usb30532_sw_set</span></code>有两种配置：</p>
<ul>
<li><p>CONF_OPEN</p></li>
<li><p>CONF_SWAP</p></li>
</ul>
</li>
</ul>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">pi3usb30532_set_conf</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">pi3usb30532</span><span class="w"> </span><span class="o">*</span><span class="n">pi</span><span class="p">,</span><span class="w"> </span><span class="n">u8</span><span class="w"> </span><span class="n">new_conf</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">conf</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">new_conf</span><span class="p">)</span><span class="w"></span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i2c_smbus_write_byte_data</span><span class="p">(</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">client</span><span class="p">,</span><span class="w"> </span><span class="n">PI3USB30532_CONF</span><span class="p">,</span><span class="w"> </span><span class="n">new_conf</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ret</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Error writing conf: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">ret</span><span class="p">);</span><span class="w"></span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="n">ret</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">conf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new_conf</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">pi3usb30532_sw_set</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">typec_switch</span><span class="w"> </span><span class="o">*</span><span class="n">sw</span><span class="p">,</span><span class="w"></span>
<span class="w">                              </span><span class="k">enum</span><span class="w"> </span><span class="nc">typec_orientation</span><span class="w"> </span><span class="n">orientation</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">pi3usb30532</span><span class="w"> </span><span class="o">*</span><span class="n">pi</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">typec_switch_get_drvdata</span><span class="p">(</span><span class="n">sw</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">u8</span><span class="w"> </span><span class="n">new_conf</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">ret</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">new_conf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">conf</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">orientation</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="no">TYPEC_ORIENTATION_NONE</span><span class="p">:</span><span class="w"></span>
<span class="w">                </span><span class="n">new_conf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PI3USB30532_CONF_OPEN</span><span class="p">;</span><span class="w"></span>
<span class="w">                </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="no">TYPEC_ORIENTATION_NORMAL</span><span class="p">:</span><span class="w"></span>
<span class="w">                </span><span class="n">new_conf</span><span class="w"> </span><span class="o">&amp;=</span><span class="w"> </span><span class="o">~</span><span class="n">PI3USB30532_CONF_SWAP</span><span class="p">;</span><span class="w"></span>
<span class="w">                </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="no">TYPEC_ORIENTATION_REVERSE</span><span class="p">:</span><span class="w"></span>
<span class="w">                </span><span class="n">new_conf</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">PI3USB30532_CONF_SWAP</span><span class="p">;</span><span class="w"></span>
<span class="w">                </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pi3usb30532_set_conf</span><span class="p">(</span><span class="n">pi</span><span class="p">,</span><span class="w"> </span><span class="n">new_conf</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">ret</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">pi3usb30532_mux_set</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">typec_mux</span><span class="w"> </span><span class="o">*</span><span class="n">mux</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">state</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">pi3usb30532</span><span class="w"> </span><span class="o">*</span><span class="n">pi</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">typec_mux_get_drvdata</span><span class="p">(</span><span class="n">mux</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">u8</span><span class="w"> </span><span class="n">new_conf</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">ret</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">new_conf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">conf</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">state</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="no">TYPEC_STATE_SAFE</span><span class="p">:</span><span class="w"></span>
<span class="w">                </span><span class="n">new_conf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PI3USB30532_CONF_OPEN</span><span class="p">;</span><span class="w"></span>
<span class="w">                </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="no">TYPEC_STATE_USB</span><span class="p">:</span><span class="w"></span>
<span class="w">                </span><span class="n">new_conf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">new_conf</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">PI3USB30532_CONF_SWAP</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"></span>
<span class="w">                           </span><span class="n">PI3USB30532_CONF_USB3</span><span class="p">;</span><span class="w"></span>
<span class="w">                </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="no">TYPEC_DP_STATE_C</span><span class="p">:</span><span class="w"></span>
<span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="no">TYPEC_DP_STATE_E</span><span class="p">:</span><span class="w"></span>
<span class="w">                </span><span class="n">new_conf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">new_conf</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">PI3USB30532_CONF_SWAP</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"></span>
<span class="w">                           </span><span class="n">PI3USB30532_CONF_4LANE_DP</span><span class="p">;</span><span class="w"></span>
<span class="w">                </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="no">TYPEC_DP_STATE_D</span><span class="p">:</span><span class="w"></span>
<span class="w">                </span><span class="n">new_conf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">new_conf</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">PI3USB30532_CONF_SWAP</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"></span>
<span class="w">                           </span><span class="n">PI3USB30532_CONF_USB3_AND_2LANE_DP</span><span class="p">;</span><span class="w"></span>
<span class="w">                </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">default</span><span class="o">:</span><span class="w"></span>
<span class="w">                </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pi3usb30532_set_conf</span><span class="p">(</span><span class="n">pi</span><span class="p">,</span><span class="w"> </span><span class="n">new_conf</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">ret</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">pi3usb30532_probe</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">i2c_client</span><span class="w"> </span><span class="o">*</span><span class="n">client</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">device</span><span class="w"> </span><span class="o">*</span><span class="n">dev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">typec_switch_desc</span><span class="w"> </span><span class="n">sw_desc</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">typec_mux_desc</span><span class="w"> </span><span class="n">mux_desc</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">pi3usb30532</span><span class="w"> </span><span class="o">*</span><span class="n">pi</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">ret</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="n">pi</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">devm_kzalloc</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">pi</span><span class="p">),</span><span class="w"> </span><span class="n">GFP_KERNEL</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">pi</span><span class="p">)</span><span class="w"></span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">client</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">client</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i2c_smbus_read_byte_data</span><span class="p">(</span><span class="n">client</span><span class="p">,</span><span class="w"> </span><span class="n">PI3USB30532_CONF</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ret</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Error reading config register %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">ret</span><span class="p">);</span><span class="w"></span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="n">ret</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">conf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ret</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="n">sw_desc</span><span class="p">.</span><span class="n">drvdata</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pi</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">sw_desc</span><span class="p">.</span><span class="n">fwnode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">fwnode</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">sw_desc</span><span class="p">.</span><span class="n">set</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pi3usb30532_sw_set</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">sw</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">typec_switch_register</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">sw_desc</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">sw</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Error registering typec switch: %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">                        </span><span class="n">PTR_ERR</span><span class="p">(</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">sw</span><span class="p">));</span><span class="w"></span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="n">PTR_ERR</span><span class="p">(</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">sw</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="n">mux_desc</span><span class="p">.</span><span class="n">drvdata</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pi</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">mux_desc</span><span class="p">.</span><span class="n">fwnode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">fwnode</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">mux_desc</span><span class="p">.</span><span class="n">set</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pi3usb30532_mux_set</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">mux</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">typec_mux_register</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">mux_desc</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">mux</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="n">typec_switch_unregister</span><span class="p">(</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">sw</span><span class="p">);</span><span class="w"></span>
<span class="w">                </span><span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Error registering typec mux: %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">                        </span><span class="n">PTR_ERR</span><span class="p">(</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">mux</span><span class="p">));</span><span class="w"></span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="n">PTR_ERR</span><span class="p">(</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">mux</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="n">i2c_set_clientdata</span><span class="p">(</span><span class="n">client</span><span class="p">,</span><span class="w"> </span><span class="n">pi</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>通过<code class="docutils literal notranslate"><span class="pre">typec_mux_register</span></code>和<code class="docutils literal notranslate"><span class="pre">typec_switch_register</span></code>注册mux和switch，<code class="docutils literal notranslate"><span class="pre">drivers/usb/typec/mux.c</span></code>:</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * typec_switch_register - Register USB Type-C orientation switch</span>
<span class="cm"> * @parent: Parent device</span>
<span class="cm"> * @desc: Orientation switch description</span>
<span class="cm"> *</span>
<span class="cm"> * This function registers a switch that can be used for routing the correct</span>
<span class="cm"> * data pairs depending on the cable plug orientation from the USB Type-C</span>
<span class="cm"> * connector to the USB controllers. USB Type-C plugs can be inserted</span>
<span class="cm"> * right-side-up or upside-down.</span>
<span class="cm"> */</span><span class="w"></span>
<span class="k">struct</span><span class="w"> </span><span class="nc">typec_switch</span><span class="w"> </span><span class="o">*</span><span class="w"></span>
<span class="n">typec_switch_register</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">device</span><span class="w"> </span><span class="o">*</span><span class="n">parent</span><span class="p">,</span><span class="w"></span>
<span class="w">		      </span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">typec_switch_desc</span><span class="w"> </span><span class="o">*</span><span class="n">desc</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="k">struct</span><span class="w"> </span><span class="nc">typec_switch</span><span class="w"> </span><span class="o">*</span><span class="n">sw</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="kt">int</span><span class="w"> </span><span class="n">ret</span><span class="p">;</span><span class="w"></span>

<span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">desc</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="o">!</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">set</span><span class="p">)</span><span class="w"></span>
<span class="w">		</span><span class="k">return</span><span class="w"> </span><span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span><span class="w"></span>

<span class="w">	</span><span class="n">sw</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">sw</span><span class="p">),</span><span class="w"> </span><span class="n">GFP_KERNEL</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">sw</span><span class="p">)</span><span class="w"></span>
<span class="w">		</span><span class="k">return</span><span class="w"> </span><span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span><span class="w"></span>

<span class="w">	</span><span class="n">sw</span><span class="o">-&gt;</span><span class="n">set</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">set</span><span class="p">;</span><span class="w"></span>

<span class="w">	</span><span class="n">device_initialize</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sw</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="n">sw</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">parent</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">sw</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">fwnode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">fwnode</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">sw</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="k">class</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">typec_mux_class</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">sw</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">typec_switch_dev_type</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">sw</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">driver_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">drvdata</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">dev_set_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sw</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;%s-switch&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">dev_name</span><span class="p">(</span><span class="n">parent</span><span class="p">));</span><span class="w"></span>

<span class="w">	</span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">device_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sw</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ret</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="n">dev_err</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;failed to register switch (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">ret</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="n">put_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sw</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="k">return</span><span class="w"> </span><span class="n">ERR_PTR</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>

<span class="w">	</span><span class="k">return</span><span class="w"> </span><span class="n">sw</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">typec_switch_register</span><span class="p">);</span><span class="w"></span>

<span class="cm">/**</span>
<span class="cm"> * typec_mux_register - Register Multiplexer routing USB Type-C pins</span>
<span class="cm"> * @parent: Parent device</span>
<span class="cm"> * @desc: Multiplexer description</span>
<span class="cm"> *</span>
<span class="cm"> * USB Type-C connectors can be used for alternate modes of operation besides</span>
<span class="cm"> * USB when Accessory/Alternate Modes are supported. With some of those modes,</span>
<span class="cm"> * the pins on the connector need to be reconfigured. This function registers</span>
<span class="cm"> * multiplexer switches routing the pins on the connector.</span>
<span class="cm"> */</span><span class="w"></span>
<span class="k">struct</span><span class="w"> </span><span class="nc">typec_mux</span><span class="w"> </span><span class="o">*</span><span class="w"></span>
<span class="n">typec_mux_register</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">device</span><span class="w"> </span><span class="o">*</span><span class="n">parent</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">typec_mux_desc</span><span class="w"> </span><span class="o">*</span><span class="n">desc</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="k">struct</span><span class="w"> </span><span class="nc">typec_mux</span><span class="w"> </span><span class="o">*</span><span class="n">mux</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="kt">int</span><span class="w"> </span><span class="n">ret</span><span class="p">;</span><span class="w"></span>

<span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">desc</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="o">!</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">set</span><span class="p">)</span><span class="w"></span>
<span class="w">		</span><span class="k">return</span><span class="w"> </span><span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span><span class="w"></span>

<span class="w">	</span><span class="n">mux</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">mux</span><span class="p">),</span><span class="w"> </span><span class="n">GFP_KERNEL</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">mux</span><span class="p">)</span><span class="w"></span>
<span class="w">		</span><span class="k">return</span><span class="w"> </span><span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span><span class="w"></span>

<span class="w">	</span><span class="n">mux</span><span class="o">-&gt;</span><span class="n">set</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">set</span><span class="p">;</span><span class="w"></span>

<span class="w">	</span><span class="n">device_initialize</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mux</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="n">mux</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">parent</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">mux</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">fwnode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">fwnode</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">mux</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="k">class</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">typec_mux_class</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">mux</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">typec_mux_dev_type</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">mux</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">driver_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">drvdata</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">dev_set_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mux</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;%s-mux&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">dev_name</span><span class="p">(</span><span class="n">parent</span><span class="p">));</span><span class="w"></span>

<span class="w">	</span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">device_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mux</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ret</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="n">dev_err</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;failed to register mux (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">ret</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="n">put_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mux</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="k">return</span><span class="w"> </span><span class="n">ERR_PTR</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>

<span class="w">	</span><span class="k">return</span><span class="w"> </span><span class="n">mux</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">typec_mux_register</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
<section id="mtk-log">
<h1>MTK log实例分析<a class="headerlink" href="#mtk-log" title="此标题的永久链接"></a></h1>
<section id="m8drp-drp">
<h2>1.M8项目DRP 到 DRP<a class="headerlink" href="#m8drp-drp" title="此标题的永久链接"></a></h2>
<ul class="simple">
<li><p>前提：</p></li>
</ul>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span>cc电压状态有以下几个状态：
0代表CC1 6代表CC2
[CC_Change] 0/6
[CC_Alert] 0/6
enum tcpc_cc_voltage_status {
	TYPEC_CC_VOLT_OPEN = 0,
	TYPEC_CC_VOLT_RA = 1,
	TYPEC_CC_VOLT_RD = 2,

	TYPEC_CC_VOLT_SNK_DFT = 5,
	TYPEC_CC_VOLT_SNK_1_5 = 6,
	TYPEC_CC_VOLT_SNK_3_0 = 7,

	TYPEC_CC_DRP_TOGGLING = 15,
};

vbus变化打印
打印如下：
TCPC-TCPC:ps_change=0  小于0.8v
TCPC-TCPC:ps_change=1   0.8~4.5v
TCPC-TCPC:ps_change=2   大于4.5v
</pre></div>
</div>
<ul class="simple">
<li><p><span class="xref myst">log原文</span></p></li>
<li><p>以下是sink端log分析，主要分为以下几个过程：</p></li>
</ul>
<div class="highlight-log notranslate"><div class="highlight"><pre><span></span>&lt;5&gt;[92779.894626] .(6)[112:pd_dbg_info]&lt;92779.894&gt;TCPC-TCPC:Wakeup //打开timer
&lt;5&gt;[92779.894626] &lt;92779.894&gt;TCPC-TCPC:wakeup_timer
&lt;5&gt;[92780.042338] &lt;92780.017&gt;TCPC-TYPEC:** Try.SRC //尝试source
行 13997: &lt;5&gt;[92798.314323] &lt;92798.310&gt;TCPC-TYPEC:[CC_Change] 0/0
行 13999: &lt;5&gt;[92798.314342] .(4)[112:pd_dbg_info]98.311&gt;TCPC-TYPEC:** Unattached.SNK  //拔出状态，准备SINK
行 14000: &lt;5&gt;[92798.314342] &lt;92798.311&gt;TCPC-TYPEC:norp_src=1
行 14001: &lt;5&gt;[92798.314342] &lt;92798.311&gt;TCPC-TYPEC:Attached-&gt; NULL(repeat)
行 14003: &lt;5&gt;[92798.314363] .(4)[112:pd_dbg_info]&gt;TCPC-TYPEC:[CC_Alert] 15/15 //DRP翻转成SINK
行 14004: &lt;5&gt;[92798.314363] &lt;92798.312&gt;TCPC-TYPEC:[Warning] DRP Toggling
行 14005: &lt;5&gt;[92798.314363] &lt;92798.313&gt;TCPC-TCPC:ps_change=1      //vbus 0.8~4.5v
行 14023: &lt;5&gt;[92798.611818] .(4)[112:pd_dbg_info]&lt;92798.611&gt;TCPC-TYPEC:[Warning] DRP Toggling
行 14228: &lt;5&gt;[92814.025910] .(5)[112:pd_dbg_info]&lt;92814.025&gt;TCPC-TCPC:bat_update_work_func battery update soc = 96
行 14229: &lt;5&gt;[92814.025910] &lt;92814.025&gt;TCPC-TCPC:bat_update_work_func Battery Discharging
行 15118: &lt;5&gt;[92866.701853] .(5)[112:pd_dbg_info]&lt;92866.701&gt;TCPC-TCPC:Wakeup
行 15119: &lt;5&gt;[92866.701853] &lt;92866.701&gt;TCPC-TCPC:wakeup_timer
行 15121: &lt;5&gt;[92866.730338] .(5)[112:pd_dbg_info]&lt;92866.702&gt;TCPC-TYPEC:[CC_Alert] 2/0    //作为SINK端Rd下拉
行 15122: &lt;5&gt;[92866.730338] &lt;92866.702&gt;TCPC-TCPC:[Warning] ps_changed 1 -&gt;0   //vbus电压小于0.8v
行 15123: &lt;5&gt;[92866.730338] &lt;92866.703&gt;TCPC-TYPEC:** AttachWait.SRC //等待source
行 15124: &lt;5&gt;[92866.730379] .(5)[112:pd_dbg_info]&lt;92866.704&gt;TCPC-TCPC:ps_change=0
行 15126: &lt;5&gt;[92866.823891] .(5)[112:pd_dbg_info]&lt;92866.823&gt;TCPC-TYPEC:[CC_Change] 2/0
行 15127: &lt;5&gt;[92866.823891] &lt;92866.823&gt;TCPC-TYPEC:** Attached.SRC //完成source
行 15128: &lt;5&gt;[92866.823891] &lt;92866.823&gt;TCPC-TYPEC:wait_ps=SRC_VSafe5V
行 15161: &lt;5&gt;[92866.850316] .(5)[112:pd_dbg_info]&lt;92866.825&gt;TCPC-TYPEC:Attached-&gt; NULL(repeat)  //拔出
行 15162: &lt;5&gt;[92866.850316] &lt;92866.831&gt;TCPC-TCPC:ps_change=2
行 15163: &lt;5&gt;[92866.850316] &lt;92866.832&gt;TCPC-TYPEC:wait_ps=Disable
行 15165: &lt;5&gt;[92866.850320] .(5)[112:pd_dbg_info]32&gt;TCPC-TYPEC:Attached-&gt; SOURCE
行 15166: &lt;5&gt;[92866.850320] &lt;92866.832&gt;TCPC-TCPC:usb_port_attached
行 15170: &lt;5&gt;[92866.850334] &lt;92866.835&gt;TCPC-TYPEC:[CC_Alert] 0/0
行 15171: &lt;5&gt;[92866.850334] &lt;92866.841&gt;TCPC-TYPEC:[CC_Change] 0/0
行 15172: &lt;5&gt;[92866.850334] &lt;92866.841&gt;TCPC-TYPEC:** TryWait.SNK.PE
行 15174: &lt;5&gt;[92866.850348] &lt;92866.841&gt;TCPC-TYPEC:Attached-&gt; NULL //拔出
行 15175: &lt;5&gt;[92866.850348] &lt;92866.841&gt;TCPC-TCPC:usb_port_detached
行 15180: &lt;5&gt;[92866.850361] &lt;92866.845&gt;TCPC-TYPEC:** TryWait.SNK  //准备SINK，主要检查vbus
行 15194: &lt;5&gt;[92866.878376] .(5)[112:pd_dbg_info]&lt;92866.857&gt;TCPC-TCPC:ps_change=1
行 15201: &lt;5&gt;[92866.969317] .(5)[112:pd_dbg_info]&lt;92866.968&gt;TCPC-TYPEC:[CC_Change] 5/0
行 15202: &lt;5&gt;[92866.969317] &lt;92866.968&gt;TCPC-TYPEC:wait_ps=SNK_VSafe5V  //SNK检测到vbus电压
行 15203: &lt;5&gt;[92866.969317] &lt;92866.969&gt;TCPC-TYPEC:Attached-&gt; NULL(repeat)
行 15212: &lt;5&gt;[92867.227921] .(5)[112:pd_dbg_info]&lt;92867.227&gt;TCPC-TCPC:ps_change=0
行 15262: &lt;5&gt;[92867.254469] .(5)[112:pd_dbg_info]&lt;92867.234&gt;TCPC-TYPEC:[CC_Alert] 6/0  //检测到source端供电电流能力为SNK_1_5，1.5A
行 15263: &lt;5&gt;[92867.254469] &lt;92867.239&gt;TCPC-TCPC:ps_change=2 //vbus检测到5v
行 15264: &lt;5&gt;[92867.254469] &lt;92867.240&gt;TCPC-TYPEC:wait_ps=Disable
行 15267: &lt;5&gt;[92867.254495] &lt;92867.241&gt;TCPC-TYPEC:Attached-&gt; SINK  //完成SINK
行 15268: &lt;5&gt;[92867.254495] &lt;92867.241&gt;TCPC-TCPC:usb_port_attached
行 15339: &lt;5&gt;[92867.282383] .(5)[112:pd_dbg_info]&lt;92867.258&gt;TCPC-TCPC:bat_update_work_func battery update soc = 96
行 15340: &lt;5&gt;[92867.282383] &lt;92867.258&gt;TCPC-TCPC:bat_update_work_func Battery Charging //打开充电功能
行 15397: &lt;5&gt;[92867.310324] .(5)[112:pd_dbg_info]&lt;92867.292&gt;TCPC-TYPEC:type=1, ret,chg_type=0,0, count=1  
行 15429: &lt;5&gt;[92867.342321] .(3)[112:pd_dbg_info]&lt;92867.342&gt;TCPC-TYPEC:type=1, ret,chg_type=0,0, count=2
行 15431: &lt;5&gt;[92867.370348] .(3)[112:pd_dbg_info]&lt;92867.354&gt;TCPC-TYPEC:[CC_Change] 6/0
行 15432: &lt;5&gt;[92867.370348] &lt;92867.354&gt;TCPC-TYPEC:Attached-&gt; SINK(repeat)
行 15435: &lt;5&gt;[92867.398346] .(3)[112:pd_dbg_info]&lt;92867.392&gt;TCPC-TYPEC:type=1, ret,chg_type=0,0, count=3
行 15449: &lt;5&gt;[92867.442864] .(0)[112:pd_dbg_info]&lt;92867.442&gt;TCPC-TYPEC:type=1, ret,chg_type=0,0, count=4
行 15523: &lt;5&gt;[92867.492661] .(0)[112:pd_dbg_info]&lt;92867.492&gt;TCPC-TYPEC:type=1, ret,chg_type=0,0, count=5
行 15529: &lt;5&gt;[92867.543028] .(7)[112:pd_dbg_info]&lt;92867.542&gt;TCPC-TYPEC:type=1, ret,chg_type=0,0, count=6
行 15532: &lt;5&gt;[92867.593605] .(5)[112:pd_dbg_info]&lt;92867.593&gt;TCPC-TYPEC:type=1, ret,chg_type=0,0, count=7
行 15535: &lt;5&gt;[92867.643618] .(5)[112:pd_dbg_info]&lt;92867.643&gt;TCPC-TYPEC:type=1, ret,chg_type=0,0, count=8
行 15540: &lt;5&gt;[92867.694125] .(5)[112:pd_dbg_info]&lt;92867.693&gt;TCPC-TYPEC:type=1, ret,chg_type=0,0, count=9
行 15616: &lt;5&gt;[92867.718341] .(6)[112:pd_dbg_info]&lt;92867.702&gt;TCPC-TCPC:bat_update_work_func battery update soc = 96
行 15617: &lt;5&gt;[92867.718341] &lt;92867.702&gt;TCPC-TCPC:bat_update_work_func Battery Charging
行 15647: &lt;5&gt;[92867.746357] .(6)[112:pd_dbg_info]&lt;92867.737&gt;TCPC-TCPC:bat_update_work_func battery update soc = 96
行 15648: &lt;5&gt;[92867.746357] &lt;92867.737&gt;TCPC-TCPC:bat_update_work_func Battery Charging
行 15650: &lt;5&gt;[92867.746365] .(6)[112:pd_dbg_info]867.744&gt;TCPC-TYPEC:type=1, ret,chg_type=0,1, count=10 //轮询10次，等待bc1.2完成，bc1.2识别成SDP
行 15778: &lt;5&gt;[92867.866274] .(5)[112:pd_dbg_info]&lt;92867.839&gt;TCPC-TYPEC:[CC_Alert] 7/0
行 15779: &lt;5&gt;[92867.866274] &lt;92867.839&gt;TCPC-TYPEC:RpLvl Alert  // source端调整Rp电阻，将供电能力调为3A
行 15795: &lt;5&gt;[92867.866317] &lt;92867.849&gt;TCPC-TYPEC:[CC_Change] 7/0
行 15796: &lt;5&gt;[92867.866317] &lt;92867.849&gt;TCPC-TYPEC:RpLvl Change
行 15797: &lt;5&gt;[92867.866317] &lt;92867.849&gt;TCPC-TYPEC:Attach
行 15813: &lt;5&gt;[92867.894292] .(5)[112:pd_dbg_info]&lt;92867.879&gt;TCPC-TYPEC:[CC_Alert] 6/0
行 15814: &lt;5&gt;[92867.894292] &lt;92867.879&gt;TCPC-TYPEC:RpLvl Alert
行 15818: &lt;5&gt;[92867.894297] &lt;92867.889&gt;TCPC-TYPEC:RpLvl Change
行 15819: &lt;5&gt;[92867.894297] &lt;92867.890&gt;TCPC-TYPEC:Attached-&gt; SINK(repeat)
行 15848: &lt;5&gt;[92867.950317] .(7)[112:pd_dbg_info]&lt;92867.923&gt;TCPC-TYPEC:[CC_Alert] 7/0 //完成3A调整
行 15849: &lt;5&gt;[92867.950317] &lt;92867.923&gt;TCPC-TYPEC:RpLvl Alert
行 15853: &lt;5&gt;[92867.950325] &lt;92867.933&gt;TCPC-TYPEC:RpLvl Change
行 15854: &lt;5&gt;[92867.950325] &lt;92867.934&gt;TCPC-TYPEC:Attached-&gt; SINK(repeat)

拔出usb：
05-15 01:00:15.391215 &lt;5&gt;[91450.062141]  (4)[5042:kworker/4:0]xxx_CHG: mtk_charger_plug_out
05-15 01:00:15.391233 &lt;5&gt;[91450.062159]  (4)[5042:kworker/4:0]_pd_notifier_call evt:1 state:PD_RUN
05-15 01:00:15.391577 &lt;6&gt;[91450.062503]  (4)[5042:kworker/4:0]mt6370_pmu_charger mt6370_pmu_charger: __mt6370_set_mivr: mivr = 4500000 (0x06)
05-15 01:00:15.392007 &lt;6&gt;[91450.062933]  (4)[5042:kworker/4:0]mt6370_pmu_charger mt6370_pmu_charger: mt6370_plug_out

05-15 01:00:15.403735 &lt;5&gt;[91450.074661]  (4)[112:pd_dbg_info]&lt;91450.046&gt;TCPC-TYPEC:Detach_CC (PD)

05-15 01:00:15.403735 &lt;5&gt;[91450.074661] &lt;91450.057&gt;TCPC-TYPEC:[CC_Change] 0/0 //cc线断了

05-15 01:00:15.403735 &lt;5&gt;[91450.074661] &lt;91450.057&gt;TCPC-TYPEC:** UnattachWait.PE

05-15 01:00:15.403735 &lt;5&gt;[91450.074661] &lt;91450.05
05-15 01:00:15.403744 &lt;5&gt;[91450.074670]  (4)[112:pd_dbg_info]7&gt;TCPC-TYPEC:Attached-&gt; NULL

05-15 01:00:15.403744 &lt;5&gt;[91450.074670] &lt;91450.057&gt;TCPC-TCPC:usb_port_detached

05-15 01:00:15.403744 &lt;5&gt;[91450.074670] &lt;91450.057&gt;TCPC-PE:PD -&gt; IDLE1 (CUN)

05-15 01:00:15.403744 &lt;5&gt;[91450.074670] &lt;91450.057&gt;TCPC-PE:b
05-15 01:00:15.403776 &lt;5&gt;[91450.074702]  (4)[112:pd_dbg_info]ist_test_mode=0

05-15 01:00:15.403776 &lt;5&gt;[91450.074702] &lt;91450.057&gt;TCPC-PE:PD -&gt; IDLE2 (CUN)

05-15 01:00:15.403776 &lt;5&gt;[91450.074702] &lt;91450.059&gt;TCPC-PE:pd_state=0

05-15 01:00:15.403776 &lt;5&gt;[91450.074702] &lt;91450.060&gt;TCPC-TYPEC:** Unattached.SNK
</pre></div>
</div>
<ul class="simple">
<li><p>以下是source端log：</p></li>
</ul>
<div class="highlight-log notranslate"><div class="highlight"><pre><span></span>cc电压状态有以下几个状态：
0代表CC1 6代表CC2
[CC_Change] 0/6
[CC_Alert] 0/6
enum tcpc_cc_voltage_status {
	TYPEC_CC_VOLT_OPEN = 0,
	TYPEC_CC_VOLT_RA = 1,
	TYPEC_CC_VOLT_RD = 2,

	TYPEC_CC_VOLT_SNK_DFT = 5,
	TYPEC_CC_VOLT_SNK_1_5 = 6,
	TYPEC_CC_VOLT_SNK_3_0 = 7,

	TYPEC_CC_DRP_TOGGLING = 15,
};

vbus变化打印
打印如下：
TCPC-TCPC:ps_change=0  小于0.8v
TCPC-TCPC:ps_change=1   0.8~4.5v
TCPC-TCPC:ps_change=2   大于4.5v

static const char *const typec_wait_ps_name[] = {
	&quot;Disable&quot;,
	&quot;SNK_VSafe5V&quot;,
	&quot;SRC_VSafe0V&quot;,
	&quot;SRC_VSafe5V&quot;,
	&quot;DBG_VSafe5V&quot;,
};

1.source端检测到sink有效Rd下拉电阻。
2.source端打开vbus 5v并等待结果。
3.完成Attached-&gt; SOURCE。
行 22965: 05-17 17:05:16.224433 &lt;5&gt;[55665.546700] .(7)[106:pd_dbg_info]&lt;55665.546&gt;TCPC-TCPC:Wakeup
行 22967: 05-17 17:05:16.224433 &lt;5&gt;[55665.546700] &lt;55665.546&gt;TCPC-TCPC:wakeup_timer //打开timer 捕获CC和vbus状态
行 22970: 05-17 17:05:16.253066 &lt;5&gt;[55665.575333] .(7)[106:pd_dbg_info]&lt;55665.547&gt;TCPC-TYPEC:[CC_Alert] 0/5
行 22972: 05-17 17:05:16.253066 &lt;5&gt;[55665.575333] &lt;55665.547&gt;TCPC-TCPC:[Warning] ps_changed 1 -&gt;0
行 22974: 05-17 17:05:16.253066 &lt;5&gt;[55665.575333] &lt;55665.548&gt;TCPC-TYPEC:** AttachWait.SNK
行 22976: 05-17 17:05:16.253129 &lt;5&gt;[55665.575396] .(7)[106:pd_dbg_info]&lt;55665.550&gt;TCPC-TYPEC:[CC_Alert] 0/6
行 22978: 05-17 17:05:16.253129 &lt;5&gt;[55665.575396] &lt;55665.550&gt;TCPC-TCPC:ps_change=0
行 22982: 05-17 17:05:16.346854 &lt;5&gt;[55665.669121] .(7)[106:pd_dbg_info]&lt;55665.668&gt;TCPC-TYPEC:[CC_Change] 0/6
行 22984: 05-17 17:05:16.346854 &lt;5&gt;[55665.669121] &lt;55665.668&gt;TCPC-TYPEC:wait_ps=SNK_VSafe5V
行 22989: 05-17 17:05:16.373078 &lt;5&gt;[55665.695345] .(7)[106:pd_dbg_info]&lt;55665.675&gt;TCPC-TCPC:ps_change=2
行 22991: 05-17 17:05:16.373078 &lt;5&gt;[55665.695345] &lt;55665.677&gt;TCPC-TYPEC:wait_ps=Disable
行 22993: 05-17 17:05:16.373078 &lt;5&gt;[55665.695345] &lt;55665.677&gt;TCPC-TYPEC:** Try.SRC //尝试source
行 22995: 05-17 17:05:16.373078 &lt;5&gt;[55665.695345] &lt;55665.680&gt;TCPC-TYPEC
行 22998: 05-17 17:05:16.373119 &lt;5&gt;[55665.695386] &lt;55665.690&gt;TCPC-TYPEC:[CC_Alert] 0/2 //source端检测到有效Rd电阻
行 23001: 05-17 17:05:16.401070 &lt;5&gt;[55665.723337] .(7)[106:pd_dbg_info]&lt;55665.701&gt;TCPC-TYPEC:[CC_Change] 0/2
行 23003: 05-17 17:05:16.401070 &lt;5&gt;[55665.723337] &lt;55665.701&gt;TCPC-TYPEC:wait_ps=SRC_VSafe0V //先等待source vbus 5v
行 23005: 05-17 17:05:16.401070 &lt;5&gt;[55665.723337] &lt;55665.706&gt;TCPC-TCPC:ps_change=1
行 23014: 05-17 17:05:16.763037 &lt;5&gt;[55666.085304] .(4)[106:pd_dbg_info]&lt;55666.085&gt;TCPC-TCPC:ps_change=0
行 23039: 05-17 17:05:16.789008 &lt;5&gt;[55666.111275] .(4)[106:pd_dbg_info]&lt;55666.085&gt;TCPC-TYPEC:wait_ps=Disable
行 23041: 05-17 17:05:16.789008 &lt;5&gt;[55666.111275] &lt;55666.085&gt;TCPC-TYPEC:** Attached.SRC
行 23043: 05-17 17:05:16.789008 &lt;5&gt;[55666.111275] &lt;55666.085&gt;TCPC-TYPEC:wait_ps=SRC_VSafe5V //source打开vbus
行 23046: 05-17 17:05:16.789018 &lt;5&gt;[55666.111285] .(4)[106:pd_dbg_info]091&gt;TCPC-TCPC:ps_change=2 //vbus 5v
行 23048: 05-17 17:05:16.789018 &lt;5&gt;[55666.111285] &lt;55666.092&gt;TCPC-TYPEC:wait_ps=Disable
行 23050: 05-17 17:05:16.789018 &lt;5&gt;[55666.111285] &lt;55666.092&gt;TCPC-TYPEC:Attached-&gt; SOURCE //完成source

拔出usb：
行 23573: 05-17 17:05:25.709967 &lt;5&gt;[55675.032234] &lt;55675.032&gt;TCPC-TCPC:bat_update_work_func Battery Discharging
行 23624: 05-17 17:05:25.864445 &lt;5&gt;[55675.186712] .(4)[106:pd_dbg_info]&lt;55675.186&gt;TCPC-TYPEC:[CC_Alert] 0/0
行 23659: 05-17 17:05:25.888978 &lt;5&gt;[55675.211245] .(4)[106:pd_dbg_info]&lt;55675.191&gt;TCPC-TYPEC:[CC_Change] 0/0
行 23661: 05-17 17:05:25.888978 &lt;5&gt;[55675.211245] &lt;55675.191&gt;TCPC-TYPEC:** TryWait.SNK.PE
行 23663: 05-17 17:05:25.888978 &lt;5&gt;[55675.211245] &lt;55675.191&gt;TCPC-TYPEC:Attached-&gt; NULL
行 23666: 05-17 17:05:25.888985 &lt;5&gt;[55675.211252] .(4)[106:pd_dbg_info]2&gt;TCPC-TCPC:usb_port_detached
行 23675: 05-17 17:05:25.889008 &lt;5&gt;[55675.211275] .(4)[106:pd_dbg_info]75.196&gt;TCPC-TYPEC:** TryWait.SNK
行 23677: 05-17 17:05:25.889008 &lt;5&gt;[55675.211275] &lt;55675.199&gt;TCPC-TCPC:ps_change=1
行 23679: 05-17 17:05:25.889008 &lt;5&gt;[55675.211275] &lt;55675.207&gt;TCPC-TYPEC:[CC_Change] 0/0
行 23681: 05-17 17:05:25.889008 &lt;5&gt;[55675.211275] &lt;55675.207&gt;TCPC-TYPEC
行 23684: 05-17 17:05:25.889036 &lt;5&gt;[55675.211303] &lt;55675.208&gt;TCPC-TYPEC:[CC_Alert] 15/15
</pre></div>
</div>
</section>
</section>
<section id="pps">
<h1>PPS介绍<a class="headerlink" href="#pps" title="此标题的永久链接"></a></h1>
<p>PD快充协议芯片上的PPS，代表可编程电源（Programmable Power Supply）, 其功能允许电流和电压逐步变化。它降低了充电过程中的转换损耗，确保充电更有效。当充电更有效时，产生热量更少，并且产生较少的热量时，电池的寿命也将延长。</p>
<section id="ppspd">
<h2>pps协议和pd有什么区别<a class="headerlink" href="#ppspd" title="此标题的永久链接"></a></h2>
<p>2017 年，支持 USB 技术进步的组织 USB 实施者论坛 (USB-IF) 将 PPS 快速充电添加到 USB PD 3.0 标准中，为当今的快速充电设备创建了一个统一的解决方案。PPS 和 PD 协议可以无缝协作。PPS 允许在充电器和设备之间重新协商非标准电流和电压。</p>
<ol class="arabic simple">
<li><p>PPS让USB接口的输出电压范围，从5V扩展到3.0V~21V。</p></li>
</ol>
<p>这是一个很重要的改动，因为快速充电存在着高压小电流和低压大电流两大派系。从3.0V~21V的供电范围，让PPS可以满足各种技术流派的快速充电。</p>
<ol class="arabic simple" start="2">
<li><p>PPS可调整电压幅度为20mV，可以实现低压大电流直充。</p></li>
</ol>
<p>20mV一档的电压调整幅度，让低压大电流直充方式成为可能，实际上关于这个技术的争议很大，因为有部分手机厂商希望直接在适配器上实现恒流直充控制，而不是放在手机端。</p>
<ol class="arabic simple" start="3">
<li><p>PPS有脉动机制，保证充电过程的安全性。</p></li>
</ol>
<p>PPS一旦进入大电流模式，安全性变得非常重要，因此PPS协议规定，最少每10S，负载和适配器之间要保持一次脉动沟通，避免充电过程失控。</p>
<p>(1) USB-PD介绍，英文全称为USB Power Delivery，是USB的标准化组织USB-IF推出的一个快速充电的标准。</p>
<p>2017年2月，USB-IF组织发布了USB-PD 3.0标准的重要更新，即在USB-PD 3.0标准的基础上增加了可编程电源PPS(Programmable Power Supply)，旨在为当今的快速充电解决方案提供统一的规范。</p>
<p>(2) PPS 是 2017 年 USB-IF 标准化组织在 USB PD 3.0 标准中可编程电源（Programmable Power Supply）协议的缩写，作为一项额外的补充协议。</p>
<p>PPS 在快充方面带来了更多的新玩法。首先相比高压快充的前辈 PD 2.0、PD 3.0（不带 PPS），PPS 支持的高效「直充」方式。</p>
<p>以下是某器件包含不同的PDO（电源数据对象）输出参数；对应不同功率大小，也有相应的APDO（增强电源数据对象）输出特性，组合非常灵活。</p>
<p><img alt="0001_0044.png" src="../../../_images/0001_0044.png" /></p>
</section>
</section>


           </div>
             <div class="articleComments">
                <comments>
  <script src="https://utteranc.es/client.js"
    repo="iswbm/magic-python"
    issue-term="pathname"
    theme="github-light"
    crossorigin="anonymous"
    async>
  </script>
</comments>
             </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; 版权所有 2022, wugn.</p>
  </div>

  利用 <a href="https://www.sphinx-doc.org/">Sphinx</a> 构建，使用了 
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">主题</a>
    由 <a href="https://readthedocs.org">Read the Docs</a>开发.
  

<script charset="UTF-8" id="LA_COLLECT" src="//sdk.51.la/js-sdk-pro.min.js"></script>
<script>LA.init({id: "JoV5csIHTGhHiGQ4",ck: "JoV5csIHTGhHiGQ4"})</script>

<br/>
<script id="LA-DATA-WIDGET" crossorigin="anonymous" charset="UTF-8" src="https://v6-widget.51.la/v6/JoV5csIHTGhHiGQ4/quote.js?theme=#4C8AC2,#BB2626,#040000,#333333,#AE3535,#1690FF,14&f=14"></script>



</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>