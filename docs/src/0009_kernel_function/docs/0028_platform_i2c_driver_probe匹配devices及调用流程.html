<!DOCTYPE html>
<html class="writer-html5" lang="zh-CN" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>wugn</title>

      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/default.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/translations.js"></script>
        <script src="../../../_static/js/baidutongji.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="索引" href="../../../genindex.html" />
    <link rel="search" title="搜索" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../index.html" class="icon icon-home"> wugn_note
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="在文档中搜索" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <!-- Local TOC -->
              <div class="local-toc"><ul>
<li><a class="reference internal" href="#">概述</a></li>
<li><a class="reference internal" href="#id2">简介</a></li>
<li><a class="reference internal" href="#id3">参考</a></li>
<li><a class="reference internal" href="#platform-driver">platform driver软件架构</a></li>
<li><a class="reference internal" href="#i2c">i2c驱动架构</a></li>
<li><a class="reference internal" href="#i2c-add-driverdevice">i2c_add_driver绑定device全过程</a></li>
<li><a class="reference internal" href="#platform-driver-registerdevice">platform_driver_register绑定device全过程</a></li>
<li><a class="reference internal" href="#id4">结论</a></li>
<li><a class="reference internal" href="#id5">打印</a></li>
</ul>
</div>
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">wugn_note</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs"> 
<li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
<li>概述</li>
<li style="float: right;margin-left: 10px;"><a href="javascript:history.forward()">Forward</a></li>
<li style="float: right;margin-left: 10px;"><a href="javascript:history.back()">Go Back</a> | </li>
<li style="float: right;margin-left: 10px;"><a href="/index.html">Home</a> | </li>

      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="id1">
<h1>概述<a class="headerlink" href="#id1" title="此标题的永久链接"></a></h1>
<p>本文主要讲解一下platform driver是如何匹配platform device并执行probe函数的。</p>
</section>
<section id="id2">
<h1>简介<a class="headerlink" href="#id2" title="此标题的永久链接"></a></h1>
<p>之前的文章<a class="reference internal" href="0016_Android%E5%A6%82%E4%BD%95%E8%B0%83%E6%95%B4%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F.html"><span class="doc std std-doc">0016_Android如何调整内核模块加载顺序.md</span></a>中，我们了解到所有驱动模块的程序编译到Linux内核中，由<code class="docutils literal notranslate"><span class="pre">do_initcall</span></code>函数按照顺讯加载，本文主要讲解一下platform driver是如何匹配platform device并执行probe函数的。</p>
</section>
<section id="id3">
<h1>参考<a class="headerlink" href="#id3" title="此标题的永久链接"></a></h1>
<ul class="simple">
<li><p><a class="reference external" href="https://www.cnblogs.com/lyndonlu/articles/15723743.html">linux 设备树解析及probe调用流程</a></p></li>
<li><p><a class="reference external" href="https://blog.csdn.net/ajigegege/article/details/11017471#">Linux驱动 device 的probe函数是怎么被调用的</a></p></li>
</ul>
</section>
<section id="platform-driver">
<h1>platform driver软件架构<a class="headerlink" href="#platform-driver" title="此标题的永久链接"></a></h1>
<p>在驱动程序中，我们通常会定义一个platform_driver的结构体，其中包含了各种操作函数：</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">dev_pm_ops</span><span class="w"> </span><span class="n">pax_bat_pm_ops</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">suspend</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">pax_battery_suspend</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">resume</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">pax_battery_resume</span><span class="p">,</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">of_device_id</span><span class="w"> </span><span class="n">pax_battery_of_match</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="p">{.</span><span class="n">compatible</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;pax,battery&quot;</span><span class="p">,},</span><span class="w"></span>
<span class="w">	</span><span class="p">{},</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">of</span><span class="p">,</span><span class="w"> </span><span class="n">pax_battery_of_match</span><span class="p">);</span><span class="w"></span>

<span class="k">static</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">platform_driver</span><span class="w"> </span><span class="n">pax_battery_driver</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="p">.</span><span class="n">probe</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pax_battery_probe</span><span class="p">,</span><span class="w"></span>
<span class="w">	</span><span class="p">.</span><span class="n">remove</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pax_battery_remove</span><span class="p">,</span><span class="w"></span>
<span class="w">	</span><span class="p">.</span><span class="n">driver</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		   </span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;battery&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">		   </span><span class="p">.</span><span class="n">of_match_table</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pax_battery_of_match</span><span class="p">,</span><span class="w"></span>
<span class="cp">#ifdef CONFIG_PM</span>
<span class="w">			</span><span class="p">.</span><span class="n">pm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">pax_bat_pm_ops</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="p">.</span><span class="n">id_table</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">xxx_id</span><span class="p">,</span><span class="w"></span>
<span class="cp">#endif</span>
<span class="w">	</span><span class="p">},</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">__init</span><span class="w"> </span><span class="nf">pax_battery_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="k">return</span><span class="w"> </span><span class="n">platform_driver_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pax_battery_driver</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="n">device_initcall_sync</span><span class="p">(</span><span class="n">pax_battery_init</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>其中，<code class="docutils literal notranslate"><span class="pre">of_match_table</span></code>和<code class="docutils literal notranslate"><span class="pre">id_table</span></code>都是用来在设备树中和设备匹配，且都是通过<code class="docutils literal notranslate"><span class="pre">compatible</span></code>，前者优先级更高，后者则会在前者未匹配的情况下去掉compatible的供应商信息后再匹配，即id_table只匹配device名字。举个例子，可以看到下面这个device和driver的compatible是不匹配的，但是它的id_table和device名字都是pn553，所以也会匹配上，</p>
<div class="highlight-log notranslate"><div class="highlight"><pre><span></span>device:
&amp;qupv3_se5_i2c {
    status = &quot;okay&quot;;
               pn553@28 {
                       compatible = &quot;nxp,pn553&quot;;
                       reg = &lt;0x28&gt;;
                       nxp,pn557-irq = &lt;&amp;tlmm 105 0&gt;;
                       nxp,pn557-ven = &lt;&amp;tlmm 111 0&gt;;
                       nxp,pn557-fw-dwnld = &lt;&amp;tlmm 112 0&gt;;
               };
};

driver:
/* kept same as dts */
static const struct i2c_device_id nfc_i2c_dev_id[] = { { &quot;pn553&quot;, 0 },
						       {} };

static const struct of_device_id nfc_i2c_dev_match_table[] = {
	{
		.compatible = &quot;nxp,pn557&quot;,
	},
	{}
};

static const struct dev_pm_ops nfc_i2c_dev_pm_ops = { SET_SYSTEM_SLEEP_PM_OPS(
	nfc_i2c_dev_suspend, nfc_i2c_dev_resume) };

static struct i2c_driver nfc_i2c_dev_driver = {
	.id_table = nfc_i2c_dev_id,
	.probe = nfc_i2c_dev_probe,
	.remove = nfc_i2c_dev_remove,
	.driver = {
		.name = &quot;nxp,pn557&quot;,
		.pm = &amp;nfc_i2c_dev_pm_ops,
		.of_match_table = nfc_i2c_dev_match_table,
		.probe_type = PROBE_PREFER_ASYNCHRONOUS,
	},
};
</pre></div>
</div>
<p>platform_driver结构体的定义之中会找到许多函数指针:</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">platform_driver</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">probe</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">platform_device</span><span class="w"> </span><span class="o">*</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">remove</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">platform_device</span><span class="w"> </span><span class="o">*</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">shutdown</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">platform_device</span><span class="w"> </span><span class="o">*</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">suspend</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">platform_device</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n">pm_message_t</span><span class="w"> </span><span class="n">state</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">resume</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">platform_device</span><span class="w"> </span><span class="o">*</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="k">struct</span><span class="w"> </span><span class="nc">device_driver</span><span class="w"> </span><span class="n">driver</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="k">struct</span><span class="w"> </span><span class="nc">platform_device_id</span><span class="w"> </span><span class="o">*</span><span class="n">id_table</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
<span class="k">struct</span><span class="w"> </span><span class="nc">device_driver</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w">		</span><span class="o">*</span><span class="n">name</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="k">struct</span><span class="w"> </span><span class="nc">bus_type</span><span class="w">		</span><span class="o">*</span><span class="n">bus</span><span class="p">;</span><span class="w"></span>
<span class="w"> </span>
<span class="w">	</span><span class="k">struct</span><span class="w"> </span><span class="nc">module</span><span class="w">		</span><span class="o">*</span><span class="n">owner</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w">		</span><span class="o">*</span><span class="n">mod_name</span><span class="p">;</span><span class="w"> </span><span class="cm">/* used for built-in modules*/</span><span class="w"></span>
<span class="w"> </span>
<span class="w">	</span><span class="kt">bool</span><span class="w"> </span><span class="n">suppress_bind_attrs</span><span class="p">;</span><span class="w"> </span><span class="cm">/* disables bind/unbind via sysfs */</span><span class="w"></span>
<span class="w"> </span>
<span class="w">	</span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">probe</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">device</span><span class="w"> </span><span class="o">*</span><span class="n">dev</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">remove</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">device</span><span class="w"> </span><span class="o">*</span><span class="n">dev</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">shutdown</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">device</span><span class="w"> </span><span class="o">*</span><span class="n">dev</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">suspend</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">device</span><span class="w"> </span><span class="o">*</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="n">pm_message_t</span><span class="w"> </span><span class="n">state</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">resume</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">device</span><span class="w"> </span><span class="o">*</span><span class="n">dev</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">attribute_group</span><span class="w"> </span><span class="o">**</span><span class="n">groups</span><span class="p">;</span><span class="w"></span>
<span class="w"> </span>
<span class="w">	</span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">dev_pm_ops</span><span class="w"> </span><span class="o">*</span><span class="n">pm</span><span class="p">;</span><span class="w"></span>
<span class="w"> </span>
<span class="w">	</span><span class="k">struct</span><span class="w"> </span><span class="nc">driver_private</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>之后我们初始化时会调用函数platform_driver_register进行注册，把platform的函数指针传入了driver结构体中。这样device_driver和platform_driver都有了具体的值,但是好像还是不知道如何执行到我们定义的probe函数。
到现在为止，仅仅是设备加入到了系统中，设备还没有与驱动联系到一起。下面分析驱动的加载过程，就可以看到驱动是怎么样和设备关联到一起的。</p>
</section>
<section id="i2c">
<h1>i2c驱动架构<a class="headerlink" href="#i2c" title="此标题的永久链接"></a></h1>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>i2c driver：从设备驱动层
需要和应用进行交互，封装数据。
————————————————————————————————————————

i2c core：i2c核心层
维护i2c总线（bus），其中包括：i2c driver、i2c device链表
————————————————————————————————————————

i2c device：i2c控制层、初始化i2c控制器
完成从设备将数据写入和读取。
————————————————
</pre></div>
</div>
<p><img alt="0028_0000.png" src="../../../_images/0028_00001.png" /></p>
</section>
<section id="i2c-add-driverdevice">
<h1>i2c_add_driver绑定device全过程<a class="headerlink" href="#i2c-add-driverdevice" title="此标题的永久链接"></a></h1>
<p>我们一般写i2c驱动都是通过<code class="docutils literal notranslate"><span class="pre">i2c_add_driver</span></code>接口新增i2c_client，然后i2c-core-base(i2c总线)去执行匹配流程：</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">__init</span><span class="w"> </span><span class="nf">cw2017_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="kt">int</span><span class="w"> </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="w">	</span><span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;enter</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i2c_add_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cw2017_i2c_driver</span><span class="p">);</span><span class="w"></span>

<span class="w">	</span><span class="k">return</span><span class="w"> </span><span class="n">ret</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="n">module_init</span><span class="p">(</span><span class="n">cw2017_init</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>具体driver和devices匹配流程如下：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">drivers/i2c/i2c-core-base.c</span></code>:</p></li>
</ul>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span>* i2c_add_driver(driver)
  └── i2c_register_driver(THIS_MODULE, driver)
      └── driver_register(&amp;driver-&gt;driver);
          └── ret = bus_add_driver(drv);
              └── driver_attach(drv);//调用driver_attach()匹配总线上的设备
                  └── bus_for_each_dev(drv-&gt;bus, NULL, drv, __driver_attach);//历遍总线上的驱动，每次都调用回调函数fn()（这里是__device_attach），如果fn()返回1则匹配成功
                      └── while (!error &amp;&amp; (dev = next_device(&amp;i))) error = fn(dev, data); //形参fn表示__driver_attach，也就是对每个设备执行__driver_attach
                          ├── ret = driver_match_device(drv, dev); //用drv-&gt;bus的match方法进行匹配，如果成功就会继续调用driver_probe_device
                          │   └── return drv-&gt;bus-&gt;match ? drv-&gt;bus-&gt;match(dev, drv) : 1;
                          │       └── struct bus_type i2c_bus_type = { .match          = i2c_device_match,} //调用到i2c总线的.match，也就是i2c_device_match
                          │           ├── i2c_device_match //重要
                          │           ├── if (i2c_of_match_device(drv-&gt;of_match_table, client)) return 1; //第一种优先匹配compatible
                          │           │   └── match = of_match_device(matches, &amp;client-&gt;dev);
                          │           │       └── return of_match_node(matches, dev-&gt;of_node);
                          │           │           └── match = __of_match_node(matches, node);
                          │           │               └── for (; matches-&gt;name[0] || matches-&gt;type[0] || matches-&gt;compatible[0]; matches++) 
                          │           │                   └── score = __of_device_is_compatible(node, matches-&gt;compatible,matches-&gt;type, matches-&gt;name);
                          │           │                       └── prop = __of_find_property(device, &quot;compatible&quot;, NULL);
                          │           │                           └── if (of_compat_cmp(cp, compat, strlen(compat)) == 0) break; //最终跟到是去匹配驱动的.compatible和设备(dts)的compatible是否匹配
                          │           └── if (i2c_match_id(driver-&gt;id_table, client)) return 1;
                          │               └── if (strcmp(pdev-&gt;name, id-&gt;name) == 0) return id; //重要，这里只匹配device名称和driver id_table
                          ├── if (ret == 0) return 0; //未匹配
                          ├── else if (ret == -EPROBE_DEFER) 
                          │   └── driver_deferred_probe_add(dev);
                          │       └── list_add_tail(&amp;dev-&gt;p-&gt;deferred_probe, &amp;deferred_probe_pending_list); //用来记录哪些驱动被 deferred probe
                          └── if (!dev-&gt;p-&gt;dead &amp;&amp; !dev-&gt;driver)
                              └── driver_probe_device(drv, dev);
                                  └── ret = really_probe(dev, drv); //drivers/base/dd.c
                                      ├── if (ret == -EPROBE_DEFER)
                                      │   └── driver_deferred_probe_add_trigger(dev, local_trigger_count);
                                      │       └── driver_deferred_probe_trigger();
                                      │           └── schedule_work(&amp;deferred_probe_work);// 用来调度相应的 work func 来执行 deferred probe 动作
                                      │               └── deferred_probe_work_func(struct work_struct *work)//Retry probing devices in the active list.
                                      │                   └── bus_probe_device(dev);
                                      ├── ret = pinctrl_bind_pins(dev); //当dts pinctrl为default时，自动匹配pinctrl 0007_pinctrl原理与基础.md 有讲
                                      ├── driver_sysfs_add(dev) //在sys/class下面创建驱动节点
                                      │   ├── sysfs_create_link(&amp;dev-&gt;driver-&gt;p-&gt;kobj, &amp;dev-&gt;kobj,kobject_name(&amp;dev-&gt;kobj));
                                      │   └── sysfs_create_link(&amp;dev-&gt;kobj, &amp;dev-&gt;driver-&gt;p-&gt;kobj,&quot;driver&quot;);
                                      ├── if (dev-&gt;bus-&gt;probe) ret = dev-&gt;bus-&gt;probe(dev);
                                      ├── else if (drv-&gt;probe) ret = drv-&gt;probe(dev);
                                      ├── pinctrl_init_done(dev);
                                      │   └── pinctrl_select_state(pins-&gt;p, pins-&gt;default_state); //配置pin脚为default的state
                                      └── driver_bound(dev);//通知总线绑定驱动，将设备添加到驱动的设备链表。
                                          ├── device_links_driver_bound(dev);
                                          │   └── dev-&gt;links.status = DL_DEV_DRIVER_BOUND; //状态标记为已绑定
                                          ├── driver_deferred_probe_trigger();
                                          └── blocking_notifier_call_chain(&amp;dev-&gt;bus-&gt;p-&gt;bus_notifier,BUS_NOTIFY_BOUND_DRIVER, dev);
</pre></div>
</div>
</section>
<section id="platform-driver-registerdevice">
<h1>platform_driver_register绑定device全过程<a class="headerlink" href="#platform-driver-registerdevice" title="此标题的永久链接"></a></h1>
<p>和上面i2c驱动注册都是一样的，这里不做过多分析</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span>* platform_driver_register(&amp;pax_charger_driver);
  └── driver_register(&amp;drv-&gt;driver);
</pre></div>
</div>
<ul class="simple">
<li><p>具体看一下<code class="docutils literal notranslate"><span class="pre">driver_match_device</span></code>函数匹配流程，platform驱动如下：</p></li>
</ul>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="c1">//match 函数</span>
<span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">driver_match_device</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">device_driver</span><span class="w"> </span><span class="o">*</span><span class="n">drv</span><span class="p">,</span><span class="k">struct</span><span class="w"> </span><span class="nc">device</span><span class="w"> </span><span class="o">*</span><span class="n">dev</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">drv</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">match</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">drv</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">match</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="n">drv</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="cm">/**</span>
<span class="cm"> * platform_match - bind platform device to platform driver.</span>
<span class="cm"> * @dev: device.</span>
<span class="cm"> * @drv: driver.</span>
<span class="cm"> *</span>
<span class="cm"> * Platform device IDs are assumed to be encoded like this:</span>
<span class="cm"> * &quot;&lt;name&gt;&lt;instance&gt;&quot;, where &lt;name&gt; is a short description of the type of</span>
<span class="cm"> * device, like &quot;pci&quot; or &quot;floppy&quot;, and &lt;instance&gt; is the enumerated</span>
<span class="cm"> * instance of the device, like &#39;0&#39; or &#39;42&#39;.  Driver IDs are simply</span>
<span class="cm"> * &quot;&lt;name&gt;&quot;.  So, extract the &lt;name&gt; from the platform_device structure,</span>
<span class="cm"> * and compare it against the name of the driver. Return whether they match</span>
<span class="cm"> * or not.</span>
<span class="cm"> */</span><span class="w"></span>
<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">platform_match</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">device</span><span class="w"> </span><span class="o">*</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">device_driver</span><span class="w"> </span><span class="o">*</span><span class="n">drv</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">platform_device</span><span class="w"> </span><span class="o">*</span><span class="n">pdev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">to_platform_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">platform_driver</span><span class="w"> </span><span class="o">*</span><span class="n">pdrv</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">to_platform_driver</span><span class="p">(</span><span class="n">drv</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="cm">/* When driver_override is set, only bind to the matching driver */</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">driver_override</span><span class="p">)</span><span class="w"></span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">driver_override</span><span class="p">,</span><span class="w"> </span><span class="n">drv</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="cm">/* Attempt an OF style match first */</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">of_driver_match_device</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="n">drv</span><span class="p">))</span><span class="w"></span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="cm">/* Then try ACPI style match */</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">acpi_driver_match_device</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="n">drv</span><span class="p">))</span><span class="w"></span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="cm">/* Then try to match against the id table */</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">pdrv</span><span class="o">-&gt;</span><span class="n">id_table</span><span class="p">)</span><span class="w"></span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="n">platform_match_id</span><span class="p">(</span><span class="n">pdrv</span><span class="o">-&gt;</span><span class="n">id_table</span><span class="p">,</span><span class="w"> </span><span class="n">pdev</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="cm">/* fall-back to driver name match */</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">drv</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>


<span class="k">struct</span><span class="w"> </span><span class="nc">bus_type</span><span class="w"> </span><span class="n">platform_bus_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="p">.</span><span class="n">name</span><span class="w">		</span><span class="o">=</span><span class="w"> </span><span class="s">&quot;platform&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">	</span><span class="p">.</span><span class="n">dev_attrs</span><span class="w">	</span><span class="o">=</span><span class="w"> </span><span class="n">platform_dev_attrs</span><span class="p">,</span><span class="w"></span>
<span class="w">	</span><span class="p">.</span><span class="n">match</span><span class="w">		</span><span class="o">=</span><span class="w"> </span><span class="n">platform_match</span><span class="p">,</span><span class="w"></span>
<span class="w">	</span><span class="p">.</span><span class="n">uevent</span><span class="w">		</span><span class="o">=</span><span class="w"> </span><span class="n">platform_uevent</span><span class="p">,</span><span class="w"></span>
<span class="w">	</span><span class="p">.</span><span class="n">pm</span><span class="w">		</span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">platform_dev_pm_ops</span><span class="p">,</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>i2c驱动的也一样的步骤：</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="c1">//i2c-core-base.c</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">bus_type</span><span class="w"> </span><span class="n">i2c_bus_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">name</span><span class="w">           </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;i2c&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">match</span><span class="w">          </span><span class="o">=</span><span class="w"> </span><span class="n">i2c_device_match</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">probe</span><span class="w">          </span><span class="o">=</span><span class="w"> </span><span class="n">i2c_device_probe</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">remove</span><span class="w">         </span><span class="o">=</span><span class="w"> </span><span class="n">i2c_device_remove</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">shutdown</span><span class="w">       </span><span class="o">=</span><span class="w"> </span><span class="n">i2c_device_shutdown</span><span class="p">,</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">i2c_bus_type</span><span class="p">);</span><span class="w"></span>

<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">i2c_device_match</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">device</span><span class="w"> </span><span class="o">*</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">device_driver</span><span class="w"> </span><span class="o">*</span><span class="n">drv</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">i2c_client</span><span class="w">       </span><span class="o">*</span><span class="n">client</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i2c_verify_client</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">i2c_driver</span><span class="w">       </span><span class="o">*</span><span class="n">driver</span><span class="p">;</span><span class="w"></span>


<span class="w">        </span><span class="cm">/* Attempt an OF style match */</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i2c_of_match_device</span><span class="p">(</span><span class="n">drv</span><span class="o">-&gt;</span><span class="n">of_match_table</span><span class="p">,</span><span class="w"> </span><span class="n">client</span><span class="p">))</span><span class="w"></span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="cm">/* Then ACPI style match */</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">acpi_driver_match_device</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="n">drv</span><span class="p">))</span><span class="w"></span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="n">driver</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">to_i2c_driver</span><span class="p">(</span><span class="n">drv</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="cm">/* Finally an I2C match */</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i2c_match_id</span><span class="p">(</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">id_table</span><span class="p">,</span><span class="w"> </span><span class="n">client</span><span class="p">))</span><span class="w"></span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="id4">
<h1>结论<a class="headerlink" href="#id4" title="此标题的永久链接"></a></h1>
<ol class="arabic simple">
<li><p>platform_driver_register注册时历遍总线上的驱动，每次都调用回调函数fn()（这里是__device_attach），如果fn()返回1则匹配成功，这里fn用drv-&gt;bus的match方法进行匹配。</p></li>
<li><p>match匹配方式有两种，分别是<code class="docutils literal notranslate"><span class="pre">i2c_of_match_device</span></code>和<code class="docutils literal notranslate"><span class="pre">i2c_match_id</span></code>，都是用来在设备树中和设备匹配，且都是通过<code class="docutils literal notranslate"><span class="pre">compatible</span></code>，前者优先级更高，后者则会在前者未匹配的情况下去掉compatible的供应商信息后再匹配，即id_table只匹配device名字。</p></li>
<li><p>如果成功就会继续调用driver_probe_device。</p></li>
<li><p>真正执行的really_probe只要干了三件事</p></li>
</ol>
<ul class="simple">
<li><p>配置dts pinctrl，当dts pinctrl为default时，自动匹配规则<a class="reference internal" href="0007_pinctrl%E5%8E%9F%E7%90%86%E4%B8%8E%E5%9F%BA%E7%A1%80.html"><span class="doc std std-doc">0007_pinctrl原理与基础.md</span></a>有讲</p></li>
<li><p>driver probe defer延迟机制，这里<a class="reference internal" href="0029_driver_probe_defer%E5%BB%B6%E8%BF%9F%E6%9C%BA%E5%88%B6.html"><span class="doc std std-doc">0029_driver_probe_defer延迟机制.md</span></a>有讲。</p></li>
<li><p>通知总线绑定驱动，将设备添加到驱动的设备链表。</p></li>
</ul>
</section>
<section id="id5">
<h1>打印<a class="headerlink" href="#id5" title="此标题的永久链接"></a></h1>
<p>利用<code class="docutils literal notranslate"><span class="pre">dump_stack</span></code>可以清晰的看到probe调用流程：</p>
<div class="highlight-log notranslate"><div class="highlight"><pre><span></span>[    4.681355] PAX_CHG: func:sgm41528_charger_probe:line:1544.
[    4.686977] CPU: 1 PID: 1 Comm: swapper/0 Tainted: G        W         4.19.157 #43
[    4.694566] Hardware name: Qualcomm Technologies, Inc. SCUBA (Flattened Device Tree)
[    4.702359] [&lt;c0111c78&gt;] (unwind_backtrace) from [&lt;c010d1b0&gt;] (show_stack+0x10/0x14)
[    4.710125] [&lt;c010d1b0&gt;] (show_stack) from [&lt;c1296398&gt;] (dump_stack+0x9c/0xe4)
[    4.717375] [&lt;c1296398&gt;] (dump_stack) from [&lt;c079b9d4&gt;] (sgm41528_charger_probe+0xe0/0xde4)
[    4.725759] [&lt;c079b9d4&gt;] (sgm41528_charger_probe) from [&lt;c095b4bc&gt;] (i2c_device_probe+0x1d8/0x2c8)
[    4.734744] [&lt;c095b4bc&gt;] (i2c_device_probe) from [&lt;c07567d4&gt;] (really_probe+0x158/0x3e8)
[    4.742856] [&lt;c07567d4&gt;] (really_probe) from [&lt;c0756544&gt;] (driver_probe_device+0x78/0x1b0)
[    4.751134] [&lt;c0756544&gt;] (driver_probe_device) from [&lt;c0754a70&gt;] (bus_for_each_drv+0x84/0xc4)
[    4.759677] [&lt;c0754a70&gt;] (bus_for_each_drv) from [&lt;c0756b64&gt;] (__device_attach+0xc0/0x174)
[    4.767955] [&lt;c0756b64&gt;] (__device_attach) from [&lt;c0754c0c&gt;] (bus_probe_device+0x2c/0x84)
[    4.776154] [&lt;c0754c0c&gt;] (bus_probe_device) from [&lt;c0752028&gt;] (device_add+0x638/0x74c)
[    4.784093] [&lt;c0752028&gt;] (device_add) from [&lt;c095b9bc&gt;] (i2c_new_device+0x27c/0x2e4)
[    4.791854] [&lt;c095b9bc&gt;] (i2c_new_device) from [&lt;c0960590&gt;] (of_i2c_register_devices+0xcc/0x188)
[    4.800655] [&lt;c0960590&gt;] (of_i2c_register_devices) from [&lt;c095c0dc&gt;] (i2c_register_adapter+0x24c/0x414)
[    4.810072] [&lt;c095c0dc&gt;] (i2c_register_adapter) from [&lt;c096344c&gt;] (geni_i2c_probe+0x650/0x6a0)
[    4.818706] [&lt;c096344c&gt;] (geni_i2c_probe) from [&lt;c0759108&gt;] (platform_drv_probe+0x50/0xa8)
[    4.826985] [&lt;c0759108&gt;] (platform_drv_probe) from [&lt;c07567d4&gt;] (really_probe+0x158/0x3e8)
[    4.835269] [&lt;c07567d4&gt;] (really_probe) from [&lt;c0756544&gt;] (driver_probe_device+0x78/0x1b0)
[    4.843547] [&lt;c0756544&gt;] (driver_probe_device) from [&lt;c0756d20&gt;] (__driver_attach+0xe8/0x144)
[    4.852094] [&lt;c0756d20&gt;] (__driver_attach) from [&lt;c07547a0&gt;] (bus_for_each_dev+0x78/0xa8)
[    4.860288] [&lt;c07547a0&gt;] (bus_for_each_dev) from [&lt;c0754edc&gt;] (bus_add_driver+0x14c/0x278)
[    4.868567] [&lt;c0754edc&gt;] (bus_add_driver) from [&lt;c0757dfc&gt;] (driver_register+0x6c/0x100)
[    4.876683] [&lt;c0757dfc&gt;] (driver_register) from [&lt;c0102ffc&gt;] (do_one_initcall+0x154/0x320)
[    4.884970] [&lt;c0102ffc&gt;] (do_one_initcall) from [&lt;c1d0145c&gt;] (kernel_init_freeable+0x378/0x420)
[    4.893694] [&lt;c1d0145c&gt;] (kernel_init_freeable) from [&lt;c12a9ce8&gt;] (kernel_init+0x8/0x11c)
[    4.901891] [&lt;c12a9ce8&gt;] (kernel_init) from [&lt;c01010b4&gt;] (ret_from_fork+0x14/0x20)
[    4.909480] Exception stack(0xf5cc1fb0 to 0xf5cc1ff8)
</pre></div>
</div>
</section>


           </div>
             <div class="articleComments">
                <comments>
  <script src="https://utteranc.es/client.js"
    repo="iswbm/magic-python"
    issue-term="pathname"
    theme="github-light"
    crossorigin="anonymous"
    async>
  </script>
</comments>
             </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; 版权所有 2022, wugn.</p>
  </div>

  利用 <a href="https://www.sphinx-doc.org/">Sphinx</a> 构建，使用了 
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">主题</a>
    由 <a href="https://readthedocs.org">Read the Docs</a>开发.
  

<script charset="UTF-8" id="LA_COLLECT" src="//sdk.51.la/js-sdk-pro.min.js"></script>
<script>LA.init({id: "JoV5csIHTGhHiGQ4",ck: "JoV5csIHTGhHiGQ4"})</script>

<br/>
<script id="LA-DATA-WIDGET" crossorigin="anonymous" charset="UTF-8" src="https://v6-widget.51.la/v6/JoV5csIHTGhHiGQ4/quote.js?theme=#4C8AC2,#BB2626,#040000,#333333,#AE3535,#1690FF,14&f=14"></script>



</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>