<!DOCTYPE html>
<html class="writer-html5" lang="zh-CN" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>wugn</title>

      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/default.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/translations.js"></script>
        <script src="../../../_static/js/baidutongji.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="索引" href="../../../genindex.html" />
    <link rel="search" title="搜索" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../index.html" class="icon icon-home"> wugn_note
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="在文档中搜索" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <!-- Local TOC -->
              <div class="local-toc"><ul>
<li><a class="reference internal" href="#">概述</a></li>
<li><a class="reference internal" href="#id2">参考</a></li>
<li><a class="reference internal" href="#id3">设备树由来</a></li>
<li><a class="reference internal" href="#id4">设备树的作用</a></li>
<li><a class="reference internal" href="#id5">设备树解耦目标</a></li>
<li><a class="reference internal" href="#id6">设备树解耦框架设计</a></li>
<li><a class="reference internal" href="#android-8dtb">Android 8以后dtb存放位置</a></li>
<li><a class="reference internal" href="#android-11-kernel-5-4dtb">Android 11以上+kernel-5.4以上dtb存放位置</a></li>
<li><a class="reference internal" href="#qcm2290">QCM2290</a><ul>
<li><a class="reference internal" href="#abldtbo">ABL加载dtbo</a></li>
<li><a class="reference internal" href="#header-versiondtb">header_version版本决定dtb存储位置</a></li>
<li><a class="reference internal" href="#dt">分割DT</a></li>
</ul>
</li>
<li><a class="reference internal" href="#mt6765">MT6765</a><ul>
<li><a class="reference internal" href="#id7">参考</a></li>
<li><a class="reference internal" href="#id8">实现流程</a></li>
<li><a class="reference internal" href="#lk">LK修改</a></li>
<li><a class="reference internal" href="#kernel">Kernel修改</a></li>
<li><a class="reference internal" href="#id9">结果验证</a></li>
<li><a class="reference internal" href="#id10">编译程序流程</a><ul>
<li><a class="reference internal" href="#dtbdtbo">dtb和dtbo定义</a></li>
<li><a class="reference internal" href="#build-dtbimage-mk-mt6765-dtb">build_dtbimage.mk分析（mt6765.dtb编译流程）</a><ul>
<li><a class="reference internal" href="#build-dtb-mk">build_dtb.mk分析</a></li>
</ul>
</li>
<li><a class="reference internal" href="#build-dtboimage-mk-dws-m50-dtb-merg-dtboimg-cfg">build_dtboimage.mk分析（dws M50.dtb.merg dtboimg.cfg编译流程）</a><ul>
<li><a class="reference internal" href="#id11">build_dtb.mk分析</a></li>
</ul>
</li>
<li><a class="reference internal" href="#dtbo-mk-dtbo-img-dtb-img">dtbo.mk (dtbo.img dtb.img生成)</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">wugn_note</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs"> 
<li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
<li>概述</li>
<li style="float: right;margin-left: 10px;"><a href="javascript:history.forward()">Forward</a></li>
<li style="float: right;margin-left: 10px;"><a href="javascript:history.back()">Go Back</a> | </li>
<li style="float: right;margin-left: 10px;"><a href="/index.html">Home</a> | </li>

      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="id1">
<h1>概述<a class="headerlink" href="#id1" title="此标题的永久链接"></a></h1>
<p>很多 SoC 供应商和 ODM 都支持在一台设备上使用多个 DT，从而使一个映像能够为多个 SKU/配置提供支持。</p>
<p>在这种情况下，引导加载程序会在运行时识别硬件，并加载相应的 DT：</p>
<p><img alt="0003_0000.png" src="../../../_images/0003_00001.png" /></p>
</section>
<section id="id2">
<h1>参考<a class="headerlink" href="#id2" title="此标题的永久链接"></a></h1>
<ul class="simple">
<li><p><a class="reference external" href="https://blog.csdn.net/weixin_30615531/article/details/117579207">android分区dtbo,使用多个 DT  |  Android 开源项目  |  Android Open Source Project</a></p></li>
<li><p><a class="reference external" href="https://blog.csdn.net/zhangdaxia2/article/details/100109684/">Android DTO和dtbo简介</a></p></li>
<li><p><a class="reference external" href="https://deepinout.com/android-system-analysis/android-kernel-related/easy-to-understand-linux-dts.html">深入浅出理解Linux设备树(DTS)</a></p></li>
<li><p><a class="reference external" href="https://blog.csdn.net/u013463707/article/details/119459687">MTK平台DTBO如何生成的以及DWS生成DTS</a></p></li>
<li><p><a class="reference external" href="http://codingsky.com/doc/2022/1/11/919.html">Android 设备树的匹配流程</a></p></li>
<li><p>Dts：DTS即Device Tree Source，是一个文本形式的文件，用于描述硬件信息。一般都是固定信息，无法变更，无法overlay。</p></li>
<li><p>Dtsi：可以理解为dts的公共部分，添加、变更非常灵活。Dtsi包含在dts中。</p></li>
<li><p>Dtb：Dtb编译出来的二进制</p></li>
<li><p>Dtbo：Overlay编译出来的二进制</p></li>
<li><p>dtbo-base：指定overlay是以哪个dtb为base来覆盖的。</p></li>
<li><p>Node：树的节点</p></li>
<li><p>Property：属性</p></li>
</ul>
</section>
<section id="id3">
<h1>设备树由来<a class="headerlink" href="#id3" title="此标题的永久链接"></a></h1>
<p>linux内核源码中，之前充斥着大量的平台相关（platform Device）配置，而这些代码大多是杂乱且重复的，这使得ARM体系结构的代码维护者和内核维护者在发布一个新的版本的时候有大量的工作要做，以至于LinusTorvalds 在2011年3月17日的ARM Linux邮件列表中宣称“Gaah.Guys,this whole ARM thing is a f*cking pain in the ass”这使得整个ARM社区不得不重新慎重考虑平台配置，于是设备树（Device Tree，DT）被ARM社区采用。需要说明的是，设备树最初是由开发固件（Open Firmware）使用的用来向客户程序（通常是一个操作系统）传递数据的通信方法中的一部分内容。在运行时，客户程序通过设备树发现设备的拓扑结构，这样就不需要把硬件信息硬编码到程序中。</p>
</section>
<section id="id4">
<h1>设备树的作用<a class="headerlink" href="#id4" title="此标题的永久链接"></a></h1>
<p>设备树是一个描述硬件的数据结构，甚至你可以将其看成一个大结构体（这个结构体就是平台，成员就是具体的设备），需要注意的是设备树并不能解决所有的硬件配置问题（例如：机器识别），它只是提供一种语言，将硬件的配置从linux内核的源码中提取出来。</p>
<p>Linux使用设备树的主要原因如下</p>
<ul class="simple">
<li><p>A:平台识别</p></li>
<li><p>B:实时配置</p></li>
<li><p>C:设备植入</p></li>
</ul>
</section>
<section id="id5">
<h1>设备树解耦目标<a class="headerlink" href="#id5" title="此标题的永久链接"></a></h1>
<ul class="simple">
<li><p>目标一 vendor相关修改，完全独立出来，禁止在soc原生的dtsi中修改，只允许以dtbo的方式存在；</p></li>
<li><p>目标二 同基线项目dtbo要共二进制</p></li>
</ul>
</section>
<section id="id6">
<h1>设备树解耦框架设计<a class="headerlink" href="#id6" title="此标题的永久链接"></a></h1>
<p><img alt="0003_0001.png" src="../../../_images/0003_00011.png" /></p>
</section>
<section id="android-8dtb">
<h1>Android 8以后dtb存放位置<a class="headerlink" href="#android-8dtb" title="此标题的永久链接"></a></h1>
<p>Android 8之后为了更好的解耦与升级，google引入了DTO，将DTS分成两部分，一部分是平台相关的DTS，仍是编译成dtb.img打包至boot.img，一部分是ODM/OEM根据硬件客制化修改的DTS，编译的产物放到dtbo分区。</p>
<p><img alt="0003_0004.png" src="../../../_images/0003_00045.png" /></p>
</section>
<section id="android-11-kernel-5-4dtb">
<h1>Android 11以上+kernel-5.4以上dtb存放位置<a class="headerlink" href="#android-11-kernel-5-4dtb" title="此标题的永久链接"></a></h1>
<p>Kernel-5.4以上由于GKI问题，dtb.img不再打包到boot.img，而是放入vendor_boot.img，加入vendor_boot分区，需要BOARD_BOOT_HEADER_VERSION等于3，bootloader加载也会使用到这个值。</p>
<p><img alt="0003_0005.png" src="../../../_images/0003_00055.png" /></p>
</section>
<section id="qcm2290">
<h1>QCM2290<a class="headerlink" href="#qcm2290" title="此标题的永久链接"></a></h1>
<p>在做Android 8时，发现在dts中引入了dto。设备树叠加层（DTO）可让主要的设备树（DTB）叠加到设备树上。使用DTO的引导程序可以维护系统芯片（SOC）DT,并动态叠加针对特定设备的DT，从而向树中添加节点并对先用树中的属性进行更改。也就是SOC的设备节点作为DTB，其他设备作为DTO，DTO可以对DTB中的节点进行引用和修改。实现DTO包括分割设备树，编译，分区和运行。</p>
<section id="abldtbo">
<h2>ABL加载dtbo<a class="headerlink" href="#abldtbo" title="此标题的永久链接"></a></h2>
<p>首先看一下dtb和dtbo里面的内容：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>dtbo:
m9200-scuba-iot-idp-overlay.dts
/dts-v1/<span class="p">;</span>
/plugin/<span class="p">;</span>

<span class="c1">#include &lt;dt-bindings/interrupt-controller/arm-gic.h&gt;</span>
<span class="c1">#include &quot;scuba-iot-idp.dtsi&quot;</span>
<span class="c1">#include &quot;fibo-lcd.dtsi&quot;  //modified by tfl for tfl for LCD bringup  20221108 </span>
<span class="c1">#include &quot;fibo-touchscreen.dtsi&quot; // modified by tfl for tfl for TP  20221108 </span>

/ <span class="o">{</span>
	<span class="nv">model</span> <span class="o">=</span> <span class="s2">&quot;Qualcomm Technologies, Inc. Scuba IOT IDP&quot;</span><span class="p">;</span>
	<span class="nv">compatible</span> <span class="o">=</span> <span class="s2">&quot;qcom,scuba-idp&quot;</span>, <span class="s2">&quot;qcom,scuba-iot&quot;</span>, <span class="s2">&quot;qcom,idp&quot;</span><span class="p">;</span>
	qcom,msm-id <span class="o">=</span> &lt;<span class="m">473</span> 0x10000&gt;, &lt;<span class="m">474</span> 0x10000&gt;<span class="p">;</span>
	qcom,board-id <span class="o">=</span> &lt;<span class="m">34</span> <span class="m">0</span>&gt;<span class="p">;</span>

	soc <span class="o">{</span>
		pax_board_info <span class="o">{</span>
			<span class="nv">compatible</span> <span class="o">=</span> <span class="s2">&quot;pax,board_info&quot;</span><span class="p">;</span>
			pax,main_board <span class="o">=</span> <span class="s2">&quot;V01&quot;</span><span class="p">;</span>
			pax,port_board <span class="o">=</span> <span class="s2">&quot;V01&quot;</span><span class="p">;</span>
			pax,terminal_name <span class="o">=</span> <span class="s2">&quot;M9200&quot;</span><span class="p">;</span>
		<span class="o">}</span><span class="p">;</span>
	<span class="o">}</span><span class="p">;</span>

<span class="o">}</span><span class="p">;</span>

dtb:
m9200-scuba-iot-idp.dts
/dts-v1/<span class="p">;</span>

<span class="c1">#include &quot;scuba-iot.dtsi&quot;</span>

/ <span class="o">{</span>
	<span class="nv">model</span> <span class="o">=</span> <span class="s2">&quot;Qualcomm Technologies, Inc. Scuba IOT SoC&quot;</span><span class="p">;</span>
	<span class="nv">compatible</span> <span class="o">=</span> <span class="s2">&quot;qcom,scuba-iot&quot;</span><span class="p">;</span>
	qcom,board-id <span class="o">=</span> &lt;<span class="m">34</span> <span class="m">0</span>&gt;<span class="p">;</span>

	soc <span class="o">{</span>
		pax_board_info <span class="o">{</span>
			<span class="nv">compatible</span> <span class="o">=</span> <span class="s2">&quot;pax,board_info&quot;</span><span class="p">;</span>
			pax,main_board <span class="o">=</span> <span class="s2">&quot;V01&quot;</span><span class="p">;</span>
			pax,port_board <span class="o">=</span> <span class="s2">&quot;V01&quot;</span><span class="p">;</span>
			pax,terminal_name <span class="o">=</span> <span class="s2">&quot;M9200&quot;</span><span class="p">;</span>
		<span class="o">}</span><span class="p">;</span>
	<span class="o">}</span><span class="p">;</span>
<span class="o">}</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>
</pre></div>
</div>
<p>ABL匹配dtbo和dtb流程如下：</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span>* LinuxLoaderEntry //ABL入口函数
  └── BootLinux (&amp;Info);
      └── Status = DTBImgCheckAndAppendDT (Info, &amp;BootParamlistPtr);
          ├── if (HeaderVersion &gt; BOOT_HEADER_VERSION_ONE)
          │   └── NumKernelPages =GetNumberOfPages (BootParamlistPtr-&gt;KernelSize,BootParamlistPtr-&gt;PageSize); //从boot.img中获取dtb
          │       ├── if (HeaderVersion  == BOOT_HEADER_VERSION_TWO)
          │       │   └── ImageBuffer = BootParamlistPtr-&gt;ImageBuffer;
          │       └── if (HeaderVersion  == BOOT_HEADER_VERSION_THREE)
          │           └── ImageBuffer = BootParamlistPtr-&gt;VendorImageBuffer; //从vendor_boot.img中获取dtb
          └── SocDtb = GetSocDtb (ImageBuffer,ImageSize,BootParamlistPtr-&gt;DtbOffset, (VOID *)BootParamlistPtr-&gt;DeviceTreeLoadAddr); //获取dtb
              ├── ReadDtbFindMatch (&amp;CurDtbInfo, &amp;BestDtbInfo, BIT(SOC_MATCH) | BIT(PAX_BOARD_INFO_MATCH) //匹配dtb
              │   ├── PlatProp = (CONST CHAR8 *)fdt_getprop (Dtb, RootOffset, &quot;qcom,msm-id&quot;,&amp;LenPlatId); //读取dtb中的qcom,msm-id
              │   ├── BoardProp = (CONST CHAR8 *)fdt_getprop (Dtb, RootOffset, &quot;qcom,board-id&quot;,&amp;LenBoardId);//读取dtb中的qcom,board-id
              │   ├── GetBoardMatchDtb (CurDtbInfo, BoardProp, LenBoardId); //和xbl中读出来的对比，Get the properties like variant id, subtype from Dtb then compare the dtb vs Board
              │   ├── (CONST CHAR8 *)fdt_getprop (Dtb, RootOffset, &quot;qcom,pmic-id&quot;, &amp;LenPmicId);
              │   ├── ReadBestPmicMatch (PmicProp, PmicMaxIdx, PmicEntCount, &amp;BestPmicInfo);// 对比qcom,pmic-id，dts中没这个
              │   └── GetPaxBoardInfoMatchDtb(CurDtbInfo); //pax加的
              │       ├── RootOffset = fdt_path_offset(Dtb, &quot;/soc/pax_board_info&quot;); //找到soc=pax_board_info的dtb
              │       ├── MainBoardProp = (CONST CHAR8 *)fdt_getprop(Dtb, RootOffset, &quot;pax,main_board&quot;,
              │       ├── PortBoardProp = (CONST CHAR8 *)fdt_getprop(Dtb, RootOffset, &quot;pax,port_board&quot;,
              │       ├── TerminalNameProp = (CONST CHAR8 *)fdt_getprop(Dtb, RootOffset, &quot;pax,terminal_name&quot;, //读取dts中三个dtb属性
              │       ├── if (getCfgTermialName(Buff) &lt; 0) //对比terminal_name
              │       │   └── return getCfgItemValStr(&quot;TERMINAL_NAME&quot;, buf); //pax_lib.c 我们terminal_name、port_board、main_board都是从sp配置文件中获取的
              │       ├── if (AsciiStrnCmp(Buff, TerminalName, TerminalNamePropLen))
              │       │   └── return EFI_NOT_FOUND;
              │       ├── if (getCfgMainBoard(Buff) &lt; 0)
              │       ├── if (AsciiStrnCmp(Buff, MainBoard, MainBoardPropLen)) //对比main_board
              │       ├── if (getCfgPortBoard(Buff) &lt; 0)
              │       └── if (AsciiStrnCmp(Buff, PortBoard, PortBoardPropLen)) //对比port_board
              └── return BestDtbInfo.Dtb; //
</pre></div>
</div>
</section>
<section id="header-versiondtb">
<h2>header_version版本决定dtb存储位置<a class="headerlink" href="#header-versiondtb" title="此标题的永久链接"></a></h2>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">BootImage.h</span></code>解释：</p></li>
</ul>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#define BOOT_HEADER_VERSION_ONE 1</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">boot_img_hdr_v1</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">UINT32</span><span class="w"> </span><span class="n">recovery_dtbo_size</span><span class="p">;</span><span class="w">   </span><span class="cm">/* size in bytes for recovery DTBO image */</span><span class="w"></span>
<span class="w">  </span><span class="n">UINT64</span><span class="w"> </span><span class="n">recovery_dtbo_offset</span><span class="p">;</span><span class="w"> </span><span class="cm">/* physical load addr */</span><span class="w"></span>
<span class="w">  </span><span class="n">UINT32</span><span class="w"> </span><span class="n">header_size</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"> </span><span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">));</span><span class="w"></span>

<span class="cm">/* When the boot image header has a version of BOOT_HEADER_VERSION_ONE,</span>
<span class="cm"> * the structure of the boot image is as follows:</span>
<span class="cm"> *</span>
<span class="cm"> * +-----------------+</span>
<span class="cm"> * | boot header     | 1 page</span>
<span class="cm"> * +-----------------+</span>
<span class="cm"> * | kernel          | n pages</span>
<span class="cm"> * +-----------------+</span>
<span class="cm"> * | ramdisk         | m pages</span>
<span class="cm"> * +-----------------+</span>
<span class="cm"> * | second stage    | o pages</span>
<span class="cm"> * +-----------------+</span>
<span class="cm"> * | recovery dtbo   | p pages</span>
<span class="cm"> * +-----------------+</span>
<span class="cm"> * n = (kernel_size + page_size - 1) / page_size</span>
<span class="cm"> * m = (ramdisk_size + page_size - 1) / page_size</span>
<span class="cm"> * o = (second_size + page_size - 1) / page_size</span>
<span class="cm"> * p = (recovery_dtbo_size + page_size - 1) / page_size</span>
<span class="cm"> *</span>
<span class="cm"> * 0. all entities are page_size aligned in flash</span>
<span class="cm"> * 1. kernel and ramdisk are required (size != 0)</span>
<span class="cm"> * 2. recovery_dtbo is required for recovery.img</span>
<span class="cm"> *    in non-A/B devices(recovery_dtbo_size != 0)</span>
<span class="cm"> * 3. second is optional (second_size == 0 -&gt; no second)</span>
<span class="cm"> * 4. load each element (kernel, ramdisk, second, recovery_dtbo) at</span>
<span class="cm"> *    the specified physical address (kernel_addr, etc)</span>
<span class="cm"> * 5. prepare tags at tag_addr.  kernel_args[] is</span>
<span class="cm"> *    appended to the kernel commandline in the tags.</span>
<span class="cm"> * 6. r0 = 0, r1 = MACHINE_TYPE, r2 = tags_addr</span>
<span class="cm"> * 7. if second_size != 0: jump to second_addr</span>
<span class="cm"> *    else: jump to kernel_addr</span>
<span class="cm"> */</span><span class="w"></span>

<span class="cp">#define BOOT_IMAGE_HEADER_V2_OFFSET sizeof (struct boot_img_hdr_v1)</span>
<span class="cp">#define BOOT_HEADER_VERSION_TWO 2</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">boot_img_hdr_v2</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">UINT32</span><span class="w"> </span><span class="n">dtb_size</span><span class="p">;</span><span class="w"> </span><span class="cm">/* size in bytes for DTB image */</span><span class="w"></span>
<span class="w">  </span><span class="n">UINT64</span><span class="w"> </span><span class="n">dtb_addr</span><span class="p">;</span><span class="w"> </span><span class="cm">/* physical load address for DTB image */</span><span class="w"></span>
<span class="p">}</span><span class="w"> </span><span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">));</span><span class="w"></span>

<span class="cm">/* When the boot image header has a version of BOOT_HEADER_VERSION_TWO,</span>
<span class="cm"> * the structure of the boot image is as follows:</span>
<span class="cm"> *</span>
<span class="cm"> * +-----------------+</span>
<span class="cm"> * | boot header     | 1 page</span>
<span class="cm"> * +-----------------+</span>
<span class="cm"> * | kernel          | n pages</span>
<span class="cm"> * +-----------------+</span>
<span class="cm"> * | ramdisk         | m pages</span>
<span class="cm"> * +-----------------+</span>
<span class="cm"> * | second stage    | o pages</span>
<span class="cm"> * +-----------------+</span>
<span class="cm"> * | recovery dtbo   | p pages</span>
<span class="cm"> * +-----------------+</span>
<span class="cm"> * | dtb.img         | q pages</span>
<span class="cm"> * +-----------------+</span>
<span class="cm"> *</span>
<span class="cm"> * n = (kernel_size + page_size - 1) / page_size</span>
<span class="cm"> * m = (ramdisk_size + page_size - 1) / page_size</span>
<span class="cm"> * o = (second_size + page_size - 1) / page_size</span>
<span class="cm"> * p = (recovery_dtbo_size + page_size - 1) / page_size</span>
<span class="cm"> * q = (dtb_size + page_size - 1) / page_size</span>
<span class="cm"> *</span>
<span class="cm"> * 0. all entities are page_size aligned in flash</span>
<span class="cm"> * 1. kernel and ramdisk are required (size != 0)</span>
<span class="cm"> * 2. recovery_dtbo is required for recovery.img (recovery_dtbo_size != 0)</span>
<span class="cm"> * 3. second is optional (second_size == 0 -&gt; no second)</span>
<span class="cm"> * 4. dtb.img has all the dtbs catted one after the other</span>
<span class="cm"> * 5. load each element (kernel, ramdisk, second, recovery_dtbo) at</span>
<span class="cm"> *    the specified physical address (kernel_addr, etc)</span>
<span class="cm"> * 6. prepare tags at tag_addr.  kernel_args[] is</span>
<span class="cm"> *    appended to the kernel commandline in the tags.</span>
<span class="cm"> * 7. r0 = 0, r1 = MACHINE_TYPE, r2 = tags_addr</span>
<span class="cm"> * 8. if second_size != 0: jump to second_addr</span>
<span class="cm"> *    else: jump to kernel_addr</span>
<span class="cm"> */</span><span class="w"></span>

<span class="cp">#define BOOT_HEADER_VERSION_THREE 3</span>

<span class="cm">/* When the boot image header has a version of 3, the structure of the boot</span>
<span class="cm"> * image is as follows:</span>
<span class="cm"> *</span>
<span class="cm"> * +---------------------+</span>
<span class="cm"> * | boot header         | 1 page</span>
<span class="cm"> * +---------------------+</span>
<span class="cm"> * | kernel              | m pages</span>
<span class="cm"> * +---------------------+</span>
<span class="cm"> * | ramdisk             | n pages</span>
<span class="cm"> * +---------------------+</span>
<span class="cm"> * m = (kernel_size + page_size - 1) / page_size</span>
<span class="cm"> * n = (ramdisk_size + page_size - 1) / page_size</span>
<span class="cm"> *</span>
<span class="cm"> * and the structure of the vendor boot image (introduced with version 3) is as</span>
<span class="cm"> * follows:</span>
<span class="cm"> *</span>
<span class="cm"> * +---------------------+</span>
<span class="cm"> * | vendor boot header  | 1 page</span>
<span class="cm"> * +---------------------+</span>
<span class="cm"> * | vendor ramdisk      | o pages</span>
<span class="cm"> * +---------------------+</span>
<span class="cm"> * | dtb                 | p pages</span>
<span class="cm"> * +---------------------+</span>
<span class="cm"> * o = (vendor_ramdisk_size + page_size - 1) / page_size</span>
<span class="cm"> * p = (dtb_size + page_size - 1) / page_size</span>
<span class="cm"> *</span>
<span class="cm"> * 0. all entities are page_size aligned in flash</span>
<span class="cm"> * 1. kernel, ramdisk, vendor ramdisk, and DTB are required (size != 0)</span>
<span class="cm"> * 2. load the kernel and DTB at the specified physical address (kernel_addr,</span>
<span class="cm"> *    dtb_addr)</span>
<span class="cm"> * 3. load the vendor ramdisk at ramdisk_addr</span>
<span class="cm"> * 4. load the generic ramdisk immediately following the vendor ramdisk in</span>
<span class="cm"> *    memory</span>
<span class="cm"> * 5. prepare tags at tag_addr.  kernel_args[] is appended to the kernel</span>
<span class="cm"> *    commandline in the tags.</span>
<span class="cm"> * 6. r0 = 0, r1 = MACHINE_TYPE, r2 = tags_addr</span>
<span class="cm"> * 7. if the platform has a second stage bootloader jump to it (must be</span>
<span class="cm"> *    contained outside boot and vendor boot partitions), otherwise</span>
<span class="cm"> *    jump to kernel_addr</span>
<span class="cm"> */</span><span class="w"></span>
</pre></div>
</div>
<p>可以看到当<code class="docutils literal notranslate"><span class="pre">BOOT_HEADER_VERSION_THREE</span> <span class="pre">3</span></code>时，表示内核版本是Kernel-5.4以上，由于GKI问题，dtb.img不再打包到boot.img，而是放入vendor_boot.img，加入vendor_boot分区，ABL加载也会使用到这个值，目前qcm2290没有这个分区，所有dtb还是放在boot.img，可见还是由内核版本决定的。</p>
<ul class="simple">
<li><p>目前ABL中<code class="docutils literal notranslate"><span class="pre">HEADER_VERSION</span></code>获取方式是从boot.img镜像中获取：</p></li>
</ul>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="n">EFI_STATUS</span><span class="w"></span>
<span class="nf">BootLinux</span><span class="w"> </span><span class="p">(</span><span class="n">BootInfo</span><span class="w"> </span><span class="o">*</span><span class="n">Info</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>

<span class="w">  </span><span class="n">Status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GetImage</span><span class="w"> </span><span class="p">(</span><span class="n">Info</span><span class="p">,</span><span class="w"></span>
<span class="w">                     </span><span class="o">&amp;</span><span class="n">BootParamlistPtr</span><span class="p">.</span><span class="n">ImageBuffer</span><span class="p">,</span><span class="w"></span>
<span class="w">                     </span><span class="p">(</span><span class="n">UINTN</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">BootParamlistPtr</span><span class="p">.</span><span class="n">ImageSize</span><span class="p">,</span><span class="w"></span>
<span class="w">                     </span><span class="p">((</span><span class="o">!</span><span class="n">Info</span><span class="o">-&gt;</span><span class="n">MultiSlotBoot</span><span class="w"> </span><span class="o">||</span><span class="w"></span>
<span class="w">                        </span><span class="n">IsDynamicPartitionSupport</span><span class="w"> </span><span class="p">())</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"></span>
<span class="w">                        </span><span class="p">(</span><span class="n">Recovery</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"></span>
<span class="w">                        </span><span class="o">!</span><span class="n">IsBuildUseRecoveryAsBoot</span><span class="w"> </span><span class="p">()))</span><span class="o">?</span><span class="w"></span>
<span class="w">                        </span><span class="s">&quot;recovery&quot;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="s">&quot;boot&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">Status</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">EFI_SUCCESS</span><span class="w"> </span><span class="o">||</span><span class="w"></span>
<span class="w">      </span><span class="n">BootParamlistPtr</span><span class="p">.</span><span class="n">ImageBuffer</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="o">||</span><span class="w"></span>
<span class="w">      </span><span class="n">BootParamlistPtr</span><span class="p">.</span><span class="n">ImageSize</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">DEBUG</span><span class="w"> </span><span class="p">((</span><span class="n">EFI_D_ERROR</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;BootLinux: Get%aImage failed!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="p">(</span><span class="o">!</span><span class="n">Info</span><span class="o">-&gt;</span><span class="n">MultiSlotBoot</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"></span>
<span class="w">             </span><span class="p">(</span><span class="n">Recovery</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"></span>
<span class="w">             </span><span class="o">!</span><span class="n">IsBuildUseRecoveryAsBoot</span><span class="w"> </span><span class="p">()))</span><span class="o">?</span><span class="w"> </span><span class="s">&quot;Recovery&quot;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="s">&quot;Boot&quot;</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">EFI_NOT_STARTED</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="n">Info</span><span class="o">-&gt;</span><span class="n">HeaderVersion</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">((</span><span class="n">boot_img_hdr</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"></span>
<span class="w">                         </span><span class="p">(</span><span class="n">BootParamlistPtr</span><span class="p">.</span><span class="n">ImageBuffer</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">header_version</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="dt">
<h2>分割DT<a class="headerlink" href="#dt" title="此标题的永久链接"></a></h2>
<p>首先将设备树分割成两部分：</p>
<ul class="simple">
<li><p>主DT。由SOC供应商提供的SOC公用部分和默认配置。</p></li>
<li><p>叠加DT。由原始设计制造商(ODM)/原始设备制造商(OEM)提供的设备专属配置。</p></li>
</ul>
</section>
</section>
<section id="mt6765">
<h1>MT6765<a class="headerlink" href="#mt6765" title="此标题的永久链接"></a></h1>
<p>目前使用的MT6762芯片使用的两个dtb，MTK标准dtb和客制化dtbo。MTK标准dtb存在于boot.img，保存在BOOT分区；客制化dtbo存在于dtbo.img中，保存在DTBO分区。在LK加载DTBO之前，需要处理当前的需要的DTBO索引，以下是lk中加载dtbo的逻辑。</p>
<section id="id7">
<h2>参考<a class="headerlink" href="#id7" title="此标题的永久链接"></a></h2>
<ul class="simple">
<li><p><a class="reference download internal" download="" href="../../../_downloads/a50d7d5ee7295b4c8ccf053e287502cc/0001-Title-board-id-M50-M8-dts.patch"><span class="xref download myst">0001-Title-board-id-M50-M8-dts.patch</span></a></p></li>
<li><p><a class="reference download internal" download="" href="../../../_downloads/8c4be613c60ebb9056d029d492bbaca1/0001-a800-dts%E5%85%BC%E5%AE%B9.patch"><span class="xref download myst">0001-a800-dts兼容.patch</span></a></p></li>
<li><p><a class="reference download internal" download="" href="../../../_downloads/4d758631362b2c0b64ec934e64809011/%E5%9F%BA%E4%BA%8EMTK6762%E5%B9%B3%E5%8F%B0Android%E9%80%82%E9%85%8D%E5%A4%9A%E6%9C%BA%E5%9E%8B%E6%96%B9%E6%A1%88v2.docx"><span class="xref download myst">基于MTK6762平台Android适配多机型方案v2.docx</span></a></p></li>
<li><p><a class="reference external" href="https://blog.csdn.net/zhangdaxia2/article/details/100109684/">Android DTO和dtbo简介</a></p></li>
</ul>
<p>A800是通过lk中向sp读取三个参数合成dtb命名，并merge dtb和dtbo</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>uuid = TERMINAL_NAME(1 byte) | MAIN_BOARD(1 byte) | PORT_BOARD(1 byte)\

dts命名规则：
TERMINAL_NAME+MAIN_BOARD+PORT_BOARD
A800_MT6761_V05_V03.dts
</pre></div>
</div>
</section>
<section id="id8">
<h2>实现流程<a class="headerlink" href="#id8" title="此标题的永久链接"></a></h2>
<ul class="simple">
<li><p>硬件兼容实现流程：</p>
<ul>
<li><p>编译过程中将多个硬件设备的设备树打包dtbo</p></li>
<li><p>硬件通过8个GPIO总线定义不同硬件产品</p></li>
<li><p>MTK LK模块启动过程中读取GPIO状态，判断当前硬件机型</p></li>
<li><p>根据机型选择对应机型的dtbo，在cmdline 中增加机型信息，将机型参数传入kernel</p></li>
<li><p>Kernel 加载init进程，init根据机器类型，加载不同的init.rc配置文件</p></li>
<li><p>Init根据配置，加载不同硬件服务，设置屏幕的分辨率，加载设备驱动</p></li>
</ul>
</li>
</ul>
<p><img alt="0003_0002.png" src="../../../_images/0003_00022.png" /></p>
<ul class="simple">
<li><p>通过dts overlay技术，将所有的dtbo合并到main dtb中：</p></li>
</ul>
<p><img alt="0003_0003.png" src="../../../_images/0003_00032.png" /></p>
</section>
<section id="lk">
<h2>LK修改<a class="headerlink" href="#lk" title="此标题的永久链接"></a></h2>
<ul class="simple">
<li><p>在lk引导加载程序中运行</p>
<ul>
<li><p>将 .dtb 从存储加载到内存中</p></li>
<li><p>根据<code class="docutils literal notranslate"><span class="pre">get_odm_mdtbo_index</span></code>选择正确的dtbo，并将 .dtbo 从存储加载到内存中</p></li>
<li><p>用 .dtbo 叠加 .dtb 以形成合并的 DT</p></li>
<li><p>启动内核（已给定合并 DT 的内存地址）</p></li>
</ul>
</li>
</ul>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>* arch/arm/crt0.S
  └── kernel/main.c
      └── thread_t *thread_bs2 = thread_create(&quot;bootstrap2&quot;, &amp;bootstrap2, NULL, DEFAULT_PRIORITY, DEFAULT_STACK_SIZE);
          └── bootstrap2(void *arg)
              ├── platform_init();
              ├── load_device_tree(void)
              │   └── lk_dtb_init(void) //platform/common/lk_main_dtb_loader/lk_builtin_dtb.c
              │       └── load_dtbo_buffer(void **dtbo_ptr, uint32_t *dtbo_size)
              │           └── parse_dtbo_tbl((struct dt_table_header *)dtbo_total_buffer, (uint32_t)get_odm_mdtbo_index(), //app/mt_boot/fdt_op.c 重要
              │               └── set_dtbo_index(dtbo_entry_idx);
              └── apps_init();
                  └── APP_START(mt_boot) .init = mt_boot_init, APP_END
                      └── mt_boot_init(const struct app_descriptor *app)
                          ├── boot_linux_from_storage(void)
                          ├── case NORMAL_BOOT:
                          │   └── load_vfy_boot(BOOTIMG_TYPE_BOOT, CFG_BOOTIMG_LOAD_ADDR);
                          │       └── boot_post_processing(&amp;ops, bootimg_type, slot_data);//platform/common/boot/avb20/load_vfy_boot.c
                          │           └── prepare_kernel_dtb(); 
                          │               └── dtb_overlay(main_dtb ? main_dtb : (void *)get_main_dtb_load_addr(), //app/mt_boot/fdt_op.c
                          │                   ├── load_overlay_dtbo() //app/mt_boot/odm_mdtbo.c
                          │                   └── merged_fdt = ufdt_apply_overlay(blob, blob_len, overlay_buf, overlay_len); // A buffer is allocated in load_overlay_dtbo() to store the loaded odm dtb
                          │                       └── load_dtb_from_multiple_dtbo(part_name, hdr2, &amp;ptr, (uint64_t)recovery_dtbo_offset);
                          │                           └── get_odm_mdtbo_index()
                          │                               ├── if (customized_get_odm_mdtbo_index) //用户定制
                          │                               └── odm_dtbo_index = customized_get_odm_mdtbo_index();
                          └── boot_linux((void *)kernel_target_addr,(unsigned *)tags_target_addr,board_machtype(),(void *)ramdisk_target_addr,ramdisk_real_sz);
                              └── boot_linux_fdt((void *)kernel, (unsigned *)tags, machtype,(void *)ramdisk, ramdisk_sz); // app/mt_boot/mt_boot.c
                                  ├── snprintf(tmpbuf, TMPBUF_SIZE, &quot;androidboot.dtb_idx=0 androidboot.dtbo_idx=%d&quot;, get_dtbo_index()); 
                                  └── cmdline_append(tmpbuf);//将androidboot.dtbo_idx以cmdline形式传给kernel
</pre></div>
</div>
<ul class="simple">
<li><p>以上流程如下：</p>
<ul>
<li><p>1.<code class="docutils literal notranslate"><span class="pre">platform_init-&gt;parse_dtbo_tbl</span></code>流程通过<code class="docutils literal notranslate"><span class="pre">get_odm_mdtbo_index</span></code>获取dtb_idx，并通过<code class="docutils literal notranslate"><span class="pre">set_dtbo_index</span></code>设置全局变量<code class="docutils literal notranslate"><span class="pre">hw_mdtbo_index</span></code>。</p></li>
<li><p>2.<code class="docutils literal notranslate"><span class="pre">apps_init-&gt;ufdt_apply_overlay</span></code>准备kernel dtb，主要是在<code class="docutils literal notranslate"><span class="pre">load_overlay_dtbo()</span></code>中分配了一个缓冲区来存储加载的<code class="docutils literal notranslate"><span class="pre">odm</span> <span class="pre">dtb</span></code>,将<code class="docutils literal notranslate"><span class="pre">.dtbo</span></code>和<code class="docutils literal notranslate"><span class="pre">.dtb</span></code>从存储加载到内存中，用<code class="docutils literal notranslate"><span class="pre">.dtbo</span></code>叠加<code class="docutils literal notranslate"><span class="pre">.dtb</span></code> 以形成合并的 DT。</p></li>
<li><p>3.<code class="docutils literal notranslate"><span class="pre">apps_init-&gt;cmdline_append</span></code>启动内核，通过<code class="docutils literal notranslate"><span class="pre">get_dtbo_index</span></code>获取全局变量<code class="docutils literal notranslate"><span class="pre">hw_mdtbo_index</span></code>，并将<code class="docutils literal notranslate"><span class="pre">dtbo_idx</span></code>以<code class="docutils literal notranslate"><span class="pre">cmdline</span></code>形式传给<code class="docutils literal notranslate"><span class="pre">kernel</span></code>。</p></li>
</ul>
</li>
<li><p>dts定制函数根据boardid，如果M8项目则idx=1则选择M8.dts：</p></li>
</ul>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span>platform/mt6765/custom_dtb_index.c：

#include &lt;odm_mdtbo.h&gt;                  // for customized_get_odm_mdtbo_index()
#include &lt;platform/mt_gpio.h&gt;           // for mt_get_gpio_in()


#define GPIO_163        (0x80000000 | 163)
#define GPIO_164        (0x80000000 | 164)
#define GPIO_HIGH       (1)
#define GPIO_LOW        (0)

/******************************************************************************
* NOTE: This function is for the internal projects of MT6771.
*        -----------------------------------------
*       |   ID4          ID5      PCB_ID          |
*       |   Low          Low      M50             |
*       |   Low          High     M8              |
*       |   High         Low      M8              |
*       |   High         High     M8              |
*        -----------------------------------------
*
*       Customers need to implement their own customized_get_odm_mdtbo_index()
*       function.
******************************************************************************/
int customized_get_odm_mdtbo_index(void)
{
        int idx = 0;
        int board_id = getBoardIDVals();

        /*[FEATURE]-Add-BEGIN by zengjianfeng@paxsz.com, 2021/05/13, for multi dts */
        dprintf(INFO, &quot;get board id vals: 0x%02x\n&quot;, board_id);

        if ((board_id &amp; (0x03 &lt;&lt; 3)) &gt; 0)
                idx = 1;
        dprintf(INFO, &quot;dtb index: 0x%02x\n&quot;, idx);
        /*[FEATURE]-Add-END by zengjianfeng@paxsz.com, 2021/05/13, for multi dts */

        return idx;
}
</pre></div>
</div>
</section>
<section id="kernel">
<h2>Kernel修改<a class="headerlink" href="#kernel" title="此标题的永久链接"></a></h2>
<p>修改<code class="docutils literal notranslate"><span class="pre">MTK_PROJECT_DTB_NAMES</span></code>，增加两个dtb。</p>
<div class="highlight-diff notranslate"><div class="highlight"><pre><span></span><span class="gd">--- a/device/mediateksample/k62v1_64_pax/ProjectConfig.mk</span><span class="w"></span>
<span class="gi">+++ b/device/mediateksample/k62v1_64_pax/ProjectConfig.mk</span><span class="w"></span>
<span class="gu">@@ -521,7 +521,7 @@ MTK_BT_HEARING_AID_SUPPORT = no</span><span class="w"></span>
<span class="w"> </span>MTK_CAM_VPU_DSDN = no<span class="w"></span>
<span class="w"> </span>MTK_AI_CAM_SUPPORT = no<span class="w"></span>
<span class="w"> </span>MTK_BIP_UICC_SERVER_MODE = no<span class="w"></span>
<span class="gd">-MTK_PROJECT_DTB_NAMES =</span><span class="w"></span>
<span class="gi">+MTK_PROJECT_DTB_NAMES = mediatek/M50 mediatek/M8</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="id9">
<h2>结果验证<a class="headerlink" href="#id9" title="此标题的永久链接"></a></h2>
<p>M8和M50的cmdline如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>M50:
cmdline:
androidboot.dtbo_idx=0

M8：
androidboot.dtbo_idx=1
</pre></div>
</div>
</section>
<section id="id10">
<h2>编译程序流程<a class="headerlink" href="#id10" title="此标题的永久链接"></a></h2>
<p>主要文件：</p>
<div class="highlight-log notranslate"><div class="highlight"><pre><span></span>编译脚本
device/mediatek/build/core：
wugn@jcrj-tf-compile:core$ tree
.
├── base_rule_hook.mk
├── base_rules.mk
├── build_dtbimage.mk
├── build_dtb.mk
├── build_dtboimage.mk
├── build_ko.mk
├── definitions.mk
├── executable.mk
├── mssi_fo.mk
├── override_config.mk
├── prebuilt.mk
├── sdk.atree
├── sdk_deps.mk
├── shared_library.mk
├── soong_config.mk
├── static_library.mk
└── target_brm_platform.mk


merge目录：
out/target/product/k62v1_64_pax/obj/KERNEL_OBJ/arch/arm64/boot/dts/mediatek
wugn@jcrj-tf-compile:mediatek$ tree
.
├── auto2712p1v1-ivi-boot.dtb
├── auto2712p1v1-ivi-nand-boot.dtb
├── M50.dtb
├── M50.dtb.merge
├── M50.dts
├── M8.dtb
├── M8.dtb.merge
├── M8.dts
├── modules.order
├── mt6765.dtb
└── mt6765.dts

mt6765.dtb及dtbo.img生成目录：
out/target/product/k62v1_64_pax/obj/PACKAGING/dtb
wugn@jcrj-tf-compile:PACKAGING$ tree dtb*
dtb
├── mtk_dtb
└── mtk.dtb
dtboimage
└── dtbo.img

</pre></div>
</div>
<section id="dtbdtbo">
<h3>dtb和dtbo定义<a class="headerlink" href="#dtbdtbo" title="此标题的永久链接"></a></h3>
<p>mtk中dtb和dtbo编译脚本如下，<code class="docutils literal notranslate"><span class="pre">MTK_DTBOIMAGE_DTS</span></code>是<code class="docutils literal notranslate"><span class="pre">mediatek/M50</span> <span class="pre">mediatek/M8</span></code>：</p>
<div class="highlight-makefile notranslate"><div class="highlight"><pre><span></span><span class="c">### DTB build template</span>
<span class="nv">MTK_DTBIMAGE_DTS</span> <span class="o">:=</span> <span class="k">$(</span>addsuffix .dts,<span class="k">$(</span>addprefix <span class="k">$(</span>KERNEL_DIR<span class="k">)</span>/arch/<span class="k">$(</span>KERNEL_TARGET_ARCH<span class="k">)</span>/boot/dts/,<span class="k">$(</span>PLATFORM_DTB_NAME<span class="k">)))</span>
<span class="cp">include device/mediatek/build/core/build_dtbimage.mk</span>

<span class="nv">MTK_DTBOIMAGE_DTS</span> <span class="o">:=</span> <span class="k">$(</span>addsuffix .dts,<span class="k">$(</span>addprefix <span class="k">$(</span>KERNEL_DIR<span class="k">)</span>/arch/<span class="k">$(</span>KERNEL_TARGET_ARCH<span class="k">)</span>/boot/dts/,<span class="k">$(</span>PROJECT_DTB_NAMES<span class="k">)))</span>
<span class="cp">include device/mediatek/build/core/build_dtboimage.mk</span>
</pre></div>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">device/mediatek/vendor/common/BoardConfig.mk``MTK_DTBIMAGE_DTS</span></code>是<code class="docutils literal notranslate"><span class="pre">mediatek/mt6765</span></code>，根据如下<code class="docutils literal notranslate"><span class="pre">TARGET_BOARD_PLATFORM</span></code>定义:</p></li>
</ul>
<div class="highlight-makefile notranslate"><div class="highlight"><pre><span></span>device/mediatek/mt6765/device.mk
5:TARGET_BOARD_PLATFORM ?= mt6765

ifeq ($(strip $(MTK_PLATFORM_DTB_NAME)),)
ifeq ($(MTK_K64_SUPPORT), yes)
PLATFORM_DTB_NAME ?= mediatek/$(TARGET_BOARD_PLATFORM)
else
PLATFORM_DTB_NAME ?= $(TARGET_BOARD_PLATFORM)
endif
else
PLATFORM_DTB_NAME ?= $(MTK_PLATFORM_DTB_NAME)
endif
</pre></div>
</div>
<p>以上得知dtb是mt6765.dts，dtbo是M8.dts。</p>
</section>
<section id="build-dtbimage-mk-mt6765-dtb">
<h3>build_dtbimage.mk分析（mt6765.dtb编译流程）<a class="headerlink" href="#build-dtbimage-mk-mt6765-dtb" title="此标题的永久链接"></a></h3>
<ul class="simple">
<li><p>该脚本主要生成dtb文件<code class="docutils literal notranslate"><span class="pre">mt6765.dtb</span></code>,然后改名为<code class="docutils literal notranslate"><span class="pre">mtk_dtb</span></code>,目录<code class="docutils literal notranslate"><span class="pre">out/target/product/k62v1_64_pax/obj/PACKAGING/dtb</span></code>，代码如下：</p></li>
</ul>
<div class="highlight-makefile notranslate"><div class="highlight"><pre><span></span>ifdef MTK_DTBIMAGE_DTS

ifneq (true,$(strip $(TARGET_NO_KERNEL)))
ifneq ($(LINUX_KERNEL_VERSION),)

ifeq (,$(KERNEL_OUT))
include $(LINUX_KERNEL_VERSION)/kenv.mk
endif

#这里MTK_DTBIMAGE_DTS是mediatek/mt6765，得知LOCAL_SRC_FILES也是 \
#功能是生成dtb文件mt6765.dtb
MTK_DTBIMAGE_DTB :=
$(foreach i,$(MTK_DTBIMAGE_DTS),\
  $(eval LOCAL_SRC_FILES := $(i))\
  $(eval include device/mediatek/build/core/build_dtb.mk)\
  $(eval MTK_DTBIMAGE_DTB += $(my_kernel_dtb))\
)
MTK_CHECK_DTBO_MAIN := $(MTK_DTBIMAGE_DTB)

my_dtb_id := 0
define mk_dtbimg_cfg
echo $(1) &gt;&gt;$(2);\
echo &quot; id=$(my_dtb_id)&quot; &gt;&gt;$(2);\
$(eval my_dtb_id := (call int_plus,$(my_dtb_id),1))
endef

ifdef BOARD_PREBUILT_DTBIMAGE_DIR
BOARD_PREBUILT_DTBIMAGE := $(BOARD_PREBUILT_DTBIMAGE_DIR)/mtk.dtb
$(shell if [ ! -f $(BOARD_PREBUILT_DTBIMAGE) ]; then mkdir -p $(dir $(BOARD_PREBUILT_DTBIMAGE)); touch $(BOARD_PREBUILT_DTBIMAGE); fi)

/*
#cat mt6765.dtb &gt; mtk_dtb \
#对比文件大小，确实一样 \
#wugn@jcrj-tf-compile:dtb$ ls -l
#total 224
#-rw-rw-r-- 1 wugn wugn 111374 Jul 11 22:24 mtk_dtb

#wugn@jcrj-tf-compile:mediatek$ ls -l
#-rw-rw-r-- 1 wugn wugn 111374 Jul 11 22:24 mt6765.dtb
*/
INSTALLED_MTK_DTB_TARGET := $(BOARD_PREBUILT_DTBIMAGE_DIR)/mtk_dtb
$(INSTALLED_MTK_DTB_TARGET): $(MTK_DTBIMAGE_DTB)
	$(hide) mkdir -p $(dir $@)
	$(hide) cat $^ &gt; $@

MTK_DTBIMAGE_CFG := $(KERNEL_OUT)/arch/$(KERNEL_TARGET_ARCH)/boot/dts/dtbimg.cfg
$(MTK_DTBIMAGE_CFG): PRIVATE_DTB := $(INSTALLED_MTK_DTB_TARGET)
$(MTK_DTBIMAGE_CFG): $(INSTALLED_MTK_DTB_TARGET)
	$(hide) rm -f $@.tmp
	$(hide) $(foreach f,$(PRIVATE_DTB),$(call mk_dtbimg_cfg,$(f),$@.tmp))
	if ! cmp -s $@.tmp $@; then \
		mv $@.tmp $@; \
	else \
		rm $@.tmp; \
	fi

endif#BOARD_PREBUILT_DTBIMAGE_DIR

endif#TARGET_NO_KERNEL
endif#LINUX_KERNEL_VERSION

endif#MTK_DTBIMAGE_DTS
</pre></div>
</div>
<p>其中<code class="docutils literal notranslate"><span class="pre">BOARD_PREBUILT_DTBIMAGE_DIR</span></code>定义如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>device/mediatek/mt6765/BoardConfig.mk
107:BOARD_PREBUILT_DTBIMAGE_DIR := $(MTK_PTGEN_PRODUCT_OUT)/obj/PACKAGING/dtb

wugn@jcrj-tf-compile:PACKAGING$ tree dtb*
dtb
├── mtk_dtb
└── mtk.dtb
dtboimage
└── dtbo.img
</pre></div>
</div>
<p>重要信息：<code class="docutils literal notranslate"><span class="pre">LOCAL_SRC_FILES</span> <span class="pre">=</span> <span class="pre">mediatek/mt6765</span></code></p>
<section id="build-dtb-mk">
<h4>build_dtb.mk分析<a class="headerlink" href="#build-dtb-mk" title="此标题的永久链接"></a></h4>
<p>该脚本功能是用make命令在kernel中生成mt6765.dtb:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">build_dtb.mk</span></code>:</p></li>
</ul>
<div class="highlight-makefile notranslate"><div class="highlight"><pre><span></span>my_kernel_dtb :=

ifneq ($(words $(LOCAL_SRC_FILES)),1)
$(error LOCAL_SRC_FILES $(LOCAL_SRC_FILES) should be one file)
endif

ifneq (true,$(strip $(TARGET_NO_KERNEL)))
ifneq ($(LINUX_KERNEL_VERSION),)

ifeq (,$(KERNEL_OUT))
include $(LINUX_KERNEL_VERSION)/kenv.mk
endif

ifeq ($(KERNEL_TARGET_ARCH),arm64) 
#目录out/target/product/k62v1_64_pax/obj/KERNEL_OBJ/arch/arm64/boot/dts/mediatek
#将目录下dts换成dtb后缀
# my_kernel_dtb_stem = mt6765.dtb
my_kernel_dtb_stem := mediatek/$(notdir $(patsubst %.dts,%.dtb,$(LOCAL_SRC_FILES)))
else
my_kernel_dtb_stem := $(notdir $(patsubst %.dts,%.dtb,$(LOCAL_SRC_FILES)))
endif

# my_kernel_dts = mt6765
ifeq ($(KERNEL_TARGET_ARCH),arm64)
my_kernel_dts := $(KERNEL_OUT)/arch/$(KERNEL_TARGET_ARCH)/boot/dts/mediatek/$(notdir $(LOCAL_SRC_FILES))
else
my_kernel_dts := $(KERNEL_OUT)/arch/$(KERNEL_TARGET_ARCH)/boot/dts/$(notdir $(LOCAL_SRC_FILES))
endif

# my_kernel_dtb = mt6765.dtb
my_kernel_dtb := $(KERNEL_OUT)/arch/$(KERNEL_TARGET_ARCH)/boot/dts/$(my_kernel_dtb_stem)

# cp $(LOCAL_SRC_FILES) $(my_kernel_dts)
$(my_kernel_dts): $(LOCAL_SRC_FILES)
	$(hide) mkdir -p $(dir $@)
	$(hide) cp -f $&lt; $@


# definitions.mk
#47:PREBUILT_MAKE_PREFIX := ./prebuilts/build-tools/linux-x86/bin/
#这里是用make命令在kernel中生成dtb
$(my_kernel_dtb): KOUT := $(KERNEL_OUT)
$(my_kernel_dtb): OPTS := $(KERNEL_MAKE_OPTION) $(my_kernel_dtb_stem)
$(my_kernel_dtb): $(KERNEL_ZIMAGE_OUT) $(my_kernel_dts) $(LOCAL_ADDITIONAL_DEPENDENCIES) | $(LOCAL_ADDITIONAL_DEPENDENCIES_D)
	$(PREBUILT_MAKE_PREFIX)$(MAKE) -C $(KOUT) $(OPTS)

#这里是用ufdt_apply_overlay工具生成xxxx.dtb.merge，但是MTK_CHECK_DTBO_MAIN是在include device/mediatek/build/core/build_dtb.mk之后定义的，不跑
UFDT_TOOL := $(LINUX_KERNEL_VERSION)/scripts/dtc/ufdt_apply_overlay
ifneq (,$(MTK_CHECK_DTBO_MAIN))
$(my_kernel_dtb).merge: private_my_platform_dtb := $(MTK_CHECK_DTBO_MAIN)
$(my_kernel_dtb).merge: private_my_kernel_dtb := $(my_kernel_dtb)
$(my_kernel_dtb).merge: $(UFDT_TOOL) $(MTK_CHECK_DTBO_MAIN) $(my_kernel_dtb)
	@echo &quot;dtbo_check: $@&quot;
	$(UFDT_TOOL) $(private_my_platform_dtb) $(private_my_kernel_dtb) $@
$(PRODUCT_OUT)/dtbo.img: $(my_kernel_dtb).merge
$(PRODUCT_OUT)/boot.img: $(my_kernel_dtb).merge
endif


endif#TARGET_NO_KERNEL
endif#LINUX_KERNEL_VERSION

LOCAL_ADDITIONAL_DEPENDENCIES :=
LOCAL_SRC_FILES :=
</pre></div>
</div>
</section>
</section>
<section id="build-dtboimage-mk-dws-m50-dtb-merg-dtboimg-cfg">
<h3>build_dtboimage.mk分析（dws M50.dtb.merg dtboimg.cfg编译流程）<a class="headerlink" href="#build-dtboimage-mk-dws-m50-dtb-merg-dtboimg-cfg" title="此标题的永久链接"></a></h3>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">build_dtboimage.mk</span></code>:</p></li>
</ul>
<p>1.利用DrvGen.py生成dws的dts：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">obj</span><span class="o">/</span><span class="n">KERNEL_OBJ</span><span class="o">/</span><span class="n">arch</span><span class="o">/</span><span class="n">arm64</span><span class="o">/</span><span class="n">boot</span><span class="o">/</span><span class="n">dts</span><span class="o">/</span><span class="n">k62v1_64_pax</span><span class="o">/</span><span class="n">M8</span><span class="o">/</span><span class="n">cust</span><span class="o">.</span><span class="n">dtsi</span>
<span class="n">obj</span><span class="o">/</span><span class="n">KERNEL_OBJ</span><span class="o">/</span><span class="n">arch</span><span class="o">/</span><span class="n">arm64</span><span class="o">/</span><span class="n">boot</span><span class="o">/</span><span class="n">dts</span><span class="o">/</span><span class="n">k62v1_64_pax</span><span class="o">/</span><span class="n">M50</span><span class="o">/</span><span class="n">cust</span><span class="o">.</span><span class="n">dtsi</span>
</pre></div>
</div>
<p>2.生成merge文件M50.dtb.merge（M50.dtb + mt6762.dtb）
3.生成cfg文件，这个文件指定了DTBO由哪个DTS文件生成，内容如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">dtboimg</span><span class="o">.</span><span class="n">cfg</span><span class="p">:</span>
<span class="n">out</span><span class="o">/</span><span class="n">target</span><span class="o">/</span><span class="n">product</span><span class="o">/</span><span class="n">k62v1_64_pax</span><span class="o">/</span><span class="n">obj</span><span class="o">/</span><span class="n">KERNEL_OBJ</span><span class="o">/</span><span class="n">arch</span><span class="o">/</span><span class="n">arm64</span><span class="o">/</span><span class="n">boot</span><span class="o">/</span><span class="n">dts</span><span class="o">/</span><span class="n">mediatek</span><span class="o">/</span><span class="n">M50</span><span class="o">.</span><span class="n">dtb</span>
 <span class="nb">id</span><span class="o">=</span><span class="mi">0</span>
<span class="n">out</span><span class="o">/</span><span class="n">target</span><span class="o">/</span><span class="n">product</span><span class="o">/</span><span class="n">k62v1_64_pax</span><span class="o">/</span><span class="n">obj</span><span class="o">/</span><span class="n">KERNEL_OBJ</span><span class="o">/</span><span class="n">arch</span><span class="o">/</span><span class="n">arm64</span><span class="o">/</span><span class="n">boot</span><span class="o">/</span><span class="n">dts</span><span class="o">/</span><span class="n">mediatek</span><span class="o">/</span><span class="n">M8</span><span class="o">.</span><span class="n">dtb</span>
 <span class="nb">id</span><span class="o">=</span><span class="mi">1</span>

<span class="n">dtbimg</span><span class="o">.</span><span class="n">cfg</span><span class="p">:</span>
<span class="n">out</span><span class="o">/</span><span class="n">target</span><span class="o">/</span><span class="n">product</span><span class="o">/</span><span class="n">k62v1_64_pax</span><span class="o">/</span><span class="n">obj</span><span class="o">/</span><span class="n">PACKAGING</span><span class="o">/</span><span class="n">dtb</span><span class="o">/</span><span class="n">mtk_dtb</span>
 <span class="nb">id</span><span class="o">=</span><span class="mi">0</span>
</pre></div>
</div>
<div class="highlight-makefile notranslate"><div class="highlight"><pre><span></span>ifdef MTK_DTBOIMAGE_DTS
#ifdef MTK_DTBOIMAGE_DWS

ifneq (true,$(strip $(TARGET_NO_KERNEL)))
ifneq ($(LINUX_KERNEL_VERSION),)

ifeq (,$(KERNEL_OUT))
include $(LINUX_KERNEL_VERSION)/kenv.mk
endif

#第一步，利用DrvGen.py将dws生成dts
DRVGEN_TOOL := vendor/mediatek/proprietary/tools/dct/python/DrvGen.py
DRVGEN_FIG := $(wildcard $(dir $(DRVGEN_TOOL))config/*.fig)
define drvgen_dws_to_dtsi
kernel: $(2)/cust.dtsi
$(2)/cust.dtsi: drvgen_tool := $(DRVGEN_TOOL)
$(2)/cust.dtsi: prj_path := $(2)
$(2)/cust.dtsi: $(DRVGEN_TOOL) $(1) $(DRVGEN_FIG)
	$(hide) mkdir -p $$(dir $$@)
	python $$(drvgen_tool) $(1) $$(prj_path) $$(prj_path) cust_dtsi
endef

#第二步：利用命令grep -m 1 &#39;#include [&lt;\&quot;].*\/cust\.dtsi[&gt;\&quot;]&#39; M50.dts | sed &#39;s/#include [&lt;&quot;]//g&#39; | sed &#39;s/\/cust\.dtsi[&gt;&quot;]//g&#39; | sed &#39;s/\/\*//g&#39; | sed &#39;s/\*\///g&#39; | sed &#39;s/ //g&#39; 输出base_prj = k62v1_64_pax/M50，将并生成M50.dtb.merge
MTK_DTBOIMAGE_DTB :=
MTK_DTBOIMAGE_DTSI :=
$(foreach i,$(MTK_DTBOIMAGE_DTS),\
  $(eval base_prj := $(shell grep -m 1 &#39;#include [&lt;\&quot;].*\/cust\.dtsi[&gt;\&quot;]&#39; $(i) | sed &#39;s/#include [&lt;&quot;]//g&#39; | sed &#39;s/\/cust\.dtsi[&gt;&quot;]//g&#39; | sed &#39;s/\/\*//g&#39; | sed &#39;s/\*\///g&#39; | sed &#39;s/ //g&#39;))\
  $(if $(strip $(base_prj)),\
    $(eval prj_path := $(KERNEL_OUT)/arch/$(KERNEL_TARGET_ARCH)/boot/dts/$(base_prj))\
    $(eval dws_path := $(KERNEL_DIR)/drivers/misc/mediatek/dws/$(MTK_PLATFORM_DIR)/$(basename $(notdir $(i))).dws)\
    $(if $(filter $(prj_path),$(MTK_DTBOIMAGE_DTSI)),,\
      $(eval $(call drvgen_dws_to_dtsi,$(dws_path),$(prj_path)))\
      $(eval MTK_DTBOIMAGE_DTSI += $(prj_path))\
      $(eval LOCAL_ADDITIONAL_DEPENDENCIES := $(prj_path)/cust.dtsi)\
    )\
  )\
  $(eval LOCAL_ADDITIONAL_DEPENDENCIES_D := $(MTK_DTBIMAGE_DTB))\
  $(eval LOCAL_ADDITIONAL_DEPENDENCIES_D += $(MTK_DTBOIMAGE_DTB))\
  $(eval LOCAL_SRC_FILES := $(i))\
  $(eval include device/mediatek/build/core/build_dtb.mk)\
  $(eval MTK_DTBOIMAGE_DTB += $(my_kernel_dtb))\
)

#这里是生成cfg文件
kernel: $(my_kernel_dtb).merge
my_dtbo_id := 0
define mk_dtboimg_cfg
echo $(1) &gt;&gt;$(2);\
echo &quot; id=$(my_dtbo_id)&quot; &gt;&gt;$(2);\
$(eval my_dtbo_id := $(call int_plus,$(my_dtbo_id),1))
endef

MTK_DTBOIMAGE_CFG := $(KERNEL_OUT)/arch/$(KERNEL_TARGET_ARCH)/boot/dts/dtboimg.cfg
$(MTK_DTBOIMAGE_CFG): PRIVATE_DTB := $(MTK_DTBOIMAGE_DTB)
$(MTK_DTBOIMAGE_CFG): $(MTK_DTBOIMAGE_DTB)
	$(hide) rm -f $@.tmp
	$(hide) $(foreach f,$(PRIVATE_DTB),$(call mk_dtboimg_cfg,$(f),$@.tmp))
	$(hide) if ! cmp -s $@.tmp $@; then \
		mv $@.tmp $@; \
	else \
		rm $@.tmp; \
	fi

endif#TARGET_NO_KERNEL
endif#LINUX_KERNEL_VERSION

#endif#MTK_DTBOIMAGE_DWS
endif#MTK_DTBOIMAGE_DTS
</pre></div>
</div>
<section id="id11">
<h4>build_dtb.mk分析<a class="headerlink" href="#id11" title="此标题的永久链接"></a></h4>
<p>该脚本功能是用make命令在kernel中生成M50.dtb和M50.dtb.merge（M50.dtb + mt6762.dtb）:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>160939 = 49565 + 111374
-rw-rw-r-- 1 wugn wugn 160939 Jul 11 22:24 M50.dtb.merge
-rw-rw-r-- 1 wugn wugn  49565 Jul 11 22:24 M50.dtb
-rw-rw-r-- 1 wugn wugn 111374 Jul 11 22:24 mt6765.dtb

编译log：
[ 19% 27973/140679] dtbo_check: 
out/target/product/k62v1_64_pax/obj/KERNEL_OBJ/arch/arm64/boot/dts/mediatek/M50.dtb.merge
</pre></div>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">build_dtb.mk</span></code>:</p></li>
</ul>
<div class="highlight-makefile notranslate"><div class="highlight"><pre><span></span>my_kernel_dtb :=

ifneq ($(words $(LOCAL_SRC_FILES)),1)
$(error LOCAL_SRC_FILES $(LOCAL_SRC_FILES) should be one file)
endif

ifneq (true,$(strip $(TARGET_NO_KERNEL)))
ifneq ($(LINUX_KERNEL_VERSION),)

ifeq (,$(KERNEL_OUT))
include $(LINUX_KERNEL_VERSION)/kenv.mk
endif

ifeq ($(KERNEL_TARGET_ARCH),arm64) 
#目录out/target/product/k62v1_64_pax/obj/KERNEL_OBJ/arch/arm64/boot/dts/mediatek \
#将目录下dts换成dtb后缀 \
# my_kernel_dtb_stem = M50.dtb
my_kernel_dtb_stem := mediatek/$(notdir $(patsubst %.dts,%.dtb,$(LOCAL_SRC_FILES)))
else
my_kernel_dtb_stem := $(notdir $(patsubst %.dts,%.dtb,$(LOCAL_SRC_FILES)))
endif

# my_kernel_dts = M50
ifeq ($(KERNEL_TARGET_ARCH),arm64)
my_kernel_dts := $(KERNEL_OUT)/arch/$(KERNEL_TARGET_ARCH)/boot/dts/mediatek/$(notdir $(LOCAL_SRC_FILES))
else
my_kernel_dts := $(KERNEL_OUT)/arch/$(KERNEL_TARGET_ARCH)/boot/dts/$(notdir $(LOCAL_SRC_FILES))
endif

# my_kernel_dtb = M50.dtb
my_kernel_dtb := $(KERNEL_OUT)/arch/$(KERNEL_TARGET_ARCH)/boot/dts/$(my_kernel_dtb_stem)

# cp $(LOCAL_SRC_FILES) $(my_kernel_dts)
$(my_kernel_dts): $(LOCAL_SRC_FILES)
	$(hide) mkdir -p $(dir $@)
	$(hide) cp -f $&lt; $@


# definitions.mk
#47:PREBUILT_MAKE_PREFIX := ./prebuilts/build-tools/linux-x86/bin/
#这里是用make命令在kernel中生成dtb
$(my_kernel_dtb): KOUT := $(KERNEL_OUT)
$(my_kernel_dtb): OPTS := $(KERNEL_MAKE_OPTION) $(my_kernel_dtb_stem)
$(my_kernel_dtb): $(KERNEL_ZIMAGE_OUT) $(my_kernel_dts) $(LOCAL_ADDITIONAL_DEPENDENCIES) | $(LOCAL_ADDITIONAL_DEPENDENCIES_D)
	$(PREBUILT_MAKE_PREFIX)$(MAKE) -C $(KOUT) $(OPTS)

#这里是用ufdt_apply_overlay工具生成xxxx.dtb.merge，但是MTK_CHECK_DTBO_MAIN是在build_dtbimage.mk中定义为mt6765.dtb，会跑
UFDT_TOOL := $(LINUX_KERNEL_VERSION)/scripts/dtc/ufdt_apply_overlay
ifneq (,$(MTK_CHECK_DTBO_MAIN))
$(my_kernel_dtb).merge: private_my_platform_dtb := $(MTK_CHECK_DTBO_MAIN)
$(my_kernel_dtb).merge: private_my_kernel_dtb := $(my_kernel_dtb)
$(my_kernel_dtb).merge: $(UFDT_TOOL) $(MTK_CHECK_DTBO_MAIN) $(my_kernel_dtb)
	@echo &quot;dtbo_check: $@&quot;
	$(UFDT_TOOL) $(private_my_platform_dtb) $(private_my_kernel_dtb) $@
$(PRODUCT_OUT)/dtbo.img: $(my_kernel_dtb).merge
$(PRODUCT_OUT)/boot.img: $(my_kernel_dtb).merge
endif


endif#TARGET_NO_KERNEL
endif#LINUX_KERNEL_VERSION

LOCAL_ADDITIONAL_DEPENDENCIES :=
LOCAL_SRC_FILES :=
</pre></div>
</div>
</section>
</section>
<section id="dtbo-mk-dtbo-img-dtb-img">
<h3>dtbo.mk (dtbo.img dtb.img生成)<a class="headerlink" href="#dtbo-mk-dtbo-img-dtb-img" title="此标题的永久链接"></a></h3>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">device/mediatek/build/tasks/dtbo.mk</span></code>:</p></li>
<li><p>使用mkdtimg工具配合dtbimg.cfg及mtk.dtb(mt6762.dtb-&gt;mtk_dtb)生成dtb.img</p></li>
<li><p>使用mkdtimg工具配合dtboimg.cfg生成dtbo.img</p></li>
</ul>
<div class="highlight-makefile notranslate"><div class="highlight"><pre><span></span>
DTBO生成：
device/mediatek/build/tasks/dtbo.mk
 
ifneq ($(filter $(OUT_DIR)/%,$(BOARD_PREBUILT_DTBOIMAGE)),)
ifdef KERNEL_DIR

ifndef MTK_DTBOIMAGE_CFG
MTK_DTBOIMAGE_CFG := $(KERNEL_OUT)/dtboimg.cfg
.KATI_RESTAT: $(MTK_DTBOIMAGE_CFG)
$(MTK_DTBOIMAGE_CFG): $(KERNEL_ZIMAGE_OUT) ;
endif

ifndef MTK_DTBIMAGE_CFG
MTK_DTBIMAGE_CFG := $(KERNEL_OUT)/dtbimg.cfg
.KATI_RESTAT: $(MTK_DTBIMAGE_CFG)
$(MTK_DTBIMAGE_CFG): $(KERNEL_ZIMAGE_OUT) ;
endif

# mkdtimg is from system/libufdt/utils/src
$(BOARD_PREBUILT_DTBOIMAGE): PRIVATE_TOOL := $(HOST_OUT_EXECUTABLES)/mkdtimg
$(BOARD_PREBUILT_DTBOIMAGE): PRIVATE_CFG := $(MTK_DTBOIMAGE_CFG)
$(BOARD_PREBUILT_DTBOIMAGE): $(HOST_OUT_EXECUTABLES)/mkdtimg
$(BOARD_PREBUILT_DTBOIMAGE): $(MTK_DTBOIMAGE_CFG)
	$(hide) mkdir -p $(dir $@)
	$(PRIVATE_TOOL) cfg_create $@ $(PRIVATE_CFG)

# dtb.img
BOARD_PREBUILT_DTBIMAGE := $(MTK_PTGEN_PRODUCT_OUT)/obj/PACKAGING/dtb/mtk.dtb
$(INSTALLED_DTBIMAGE_TARGET): $(BOARD_PREBUILT_DTBIMAGE)
$(BOARD_PREBUILT_DTBIMAGE): PRIVATE_TOOL := $(HOST_OUT_EXECUTABLES)/mkdtimg
$(BOARD_PREBUILT_DTBIMAGE): PRIVATE_CFG := $(MTK_DTBIMAGE_CFG)
$(BOARD_PREBUILT_DTBIMAGE): $(HOST_OUT_EXECUTABLES)/mkdtimg
$(BOARD_PREBUILT_DTBIMAGE): $(MTK_DTBIMAGE_CFG) $(INSTALLED_MTK_DTB_TARGET)
	$(hide) mkdir -p $(dir $@)
	$(PRIVATE_TOOL) cfg_create $@ $(PRIVATE_CFG)

ifeq ($(strip $(MTK_DTBO_UPGRADE_FROM_ANDROID_O)), yes)
.PHONY: odmdtboimage
droidcore: $(PRODUCT_OUT)/$(notdir $(BOARD_PREBUILT_DTBOIMAGE))
odmdtboimage: $(PRODUCT_OUT)/$(notdir $(BOARD_PREBUILT_DTBOIMAGE))
else
droidcore: $(PRODUCT_OUT)/dtbo.img
ifdef BOARD_PREBUILT_DTBIMAGE_DIR
droidcore: $(PRODUCT_OUT)/dtb.img
endif
.PHONY: dtboimage dtbimage
dtboimage: $(PRODUCT_OUT)/dtbo.img
dtbimage: $(PRODUCT_OUT)/dtb.img
endif

endif
endif#BOARD_PREBUILT_DTBOIMAGE

由此可见，此处使用mkdtimg工具根据dtboimg.cfg来生成dtbo.img
</pre></div>
</div>
<p>暂时先分析到dtbo.img dtb.img的生成，dtb.img不知道后续用来干嘛···</p>
</section>
</section>
</section>


           </div>
             <div class="articleComments">
                <comments>
  <script src="https://utteranc.es/client.js"
    repo="iswbm/magic-python"
    issue-term="pathname"
    theme="github-light"
    crossorigin="anonymous"
    async>
  </script>
</comments>
             </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; 版权所有 2022, wugn.</p>
  </div>

  利用 <a href="https://www.sphinx-doc.org/">Sphinx</a> 构建，使用了 
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">主题</a>
    由 <a href="https://readthedocs.org">Read the Docs</a>开发.
  

<script charset="UTF-8" id="LA_COLLECT" src="//sdk.51.la/js-sdk-pro.min.js"></script>
<script>LA.init({id: "JoV5csIHTGhHiGQ4",ck: "JoV5csIHTGhHiGQ4"})</script>

<br/>
<script id="LA-DATA-WIDGET" crossorigin="anonymous" charset="UTF-8" src="https://v6-widget.51.la/v6/JoV5csIHTGhHiGQ4/quote.js?theme=#4C8AC2,#BB2626,#040000,#333333,#AE3535,#1690FF,14&f=14"></script>



</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>