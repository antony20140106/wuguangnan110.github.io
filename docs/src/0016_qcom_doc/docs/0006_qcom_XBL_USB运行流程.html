<!DOCTYPE html>
<html class="writer-html5" lang="zh-CN" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>wugn</title>

      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/default.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/translations.js"></script>
        <script src="../../../_static/js/baidutongji.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="索引" href="../../../genindex.html" />
    <link rel="search" title="搜索" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../index.html" class="icon icon-home"> wugn_note
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="在文档中搜索" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <!-- Local TOC -->
              <div class="local-toc"><ul>
<li><a class="reference internal" href="#">概述</a></li>
<li><a class="reference internal" href="#usb">USB配置</a></li>
<li><a class="reference internal" href="#id2">代码流程</a></li>
<li><a class="reference internal" href="#id3">问题分析</a><ul>
<li><a class="reference internal" href="#fastbootusb">1.fastboot模式下不识别USB</a><ul>
<li><a class="reference internal" href="#micro-usb">1.尝试配置成micro usb</a></li>
<li><a class="reference internal" href="#usbnopmic">2.直接配置UsbNoPmic</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">wugn_note</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs"> 
<li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
<li>概述</li>
<li style="float: right;margin-left: 10px;"><a href="javascript:history.forward()">Forward</a></li>
<li style="float: right;margin-left: 10px;"><a href="javascript:history.back()">Go Back</a> | </li>
<li style="float: right;margin-left: 10px;"><a href="/index.html">Home</a> | </li>

      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="id1">
<h1>概述<a class="headerlink" href="#id1" title="此标题的永久链接"></a></h1>
<p>目前usb在fastboot模式下无法识别，跟进一下代码看看什么原因。</p>
</section>
<section id="usb">
<h1>USB配置<a class="headerlink" href="#usb" title="此标题的永久链接"></a></h1>
<ul class="simple">
<li><p>USB类型<code class="docutils literal notranslate"><span class="pre">QcomPkg/Include/Protocol/EFIUsbConfig.h</span></code>:</p></li>
</ul>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="cm">/** @addtogroup efi_usbConfig_data_types</span>
<span class="cm">@{ */</span><span class="w"></span>
<span class="cm">/**</span>
<span class="cm">  USB core id.</span>
<span class="cm">*/</span><span class="w"></span>
<span class="k">typedef</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">USB_CORE_0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">      </span><span class="cm">/**&lt; Core0. */</span><span class="w"></span>
<span class="w">  </span><span class="n">USB_CORE_1</span><span class="p">,</span><span class="w">          </span><span class="cm">/**&lt; Core1. */</span><span class="w"></span>
<span class="w">  </span><span class="n">USB_CORE_2</span><span class="p">,</span><span class="w">          </span><span class="cm">/**&lt; Core2. */</span><span class="w"></span>
<span class="w">  </span><span class="n">USB_CORE_3</span><span class="p">,</span><span class="w">          </span><span class="cm">/**&lt; Core3. */</span><span class="w"></span>
<span class="w">  </span><span class="n">USB_CORE_MAX_NUM</span><span class="w">     </span><span class="cm">/**&lt; Invalid Core. */</span><span class="w"></span>
<span class="p">}</span><span class="w"> </span><span class="n">QCOM_USB_CORE_NUM</span><span class="p">;</span><span class="w"></span>

<span class="cm">/**</span>
<span class="cm">  USB connector type.</span>
<span class="cm">*/</span><span class="w"></span>
<span class="k">typedef</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">USB_CONNECTOR_TYPE_A</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">  </span><span class="cm">/**&lt; Type-A Connector. */</span><span class="w"></span>
<span class="w">  </span><span class="n">USB_CONNECTOR_TYPE_C</span><span class="p">,</span><span class="w">      </span><span class="cm">/**&lt; Type-C Connector. */</span><span class="w"></span>
<span class="w">  </span><span class="n">USB_CONNECTOR_INVALID</span><span class="w">      </span><span class="cm">/**&lt; Invalid Connector. */</span><span class="w"></span>
<span class="p">}</span><span class="w"> </span><span class="n">QCOM_USB_CONNECTOR_TYPE</span><span class="p">;</span><span class="w"></span>


<span class="cm">/**</span>
<span class="cm">  USB mode</span>
<span class="cm">*/</span><span class="w"></span>
<span class="k">typedef</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="cm">/** USB mode type for existing USB Config APIs */</span><span class="w"></span>
<span class="w">  </span><span class="n">USB_HOST_MODE_EHCI</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000000</span><span class="p">,</span><span class="w">     </span><span class="cm">/**&lt; host controller supporting EHCI interface */</span><span class="w"></span>
<span class="w">  </span><span class="n">USB_HOST_MODE_XHCI</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000001</span><span class="p">,</span><span class="w">     </span><span class="cm">/**&lt; host controller supporting XHCI interface */</span><span class="w"></span>
<span class="w">  </span><span class="n">USB_DEVICE_MODE_HS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000002</span><span class="p">,</span><span class="w">     </span><span class="cm">/**&lt; device controller supporting ChipIdea device mode */</span><span class="w"></span>
<span class="w">  </span><span class="n">USB_DEVICE_MODE_SS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000004</span><span class="p">,</span><span class="w">     </span><span class="cm">/**&lt; device controller supporting SNPS device mode */</span><span class="w"></span>
<span class="w">  </span><span class="cm">/** USB mode type for client to select configuration */</span><span class="w"></span>
<span class="w">  </span><span class="n">USB_HOST_MODE</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000008</span><span class="p">,</span><span class="w">     </span><span class="cm">/**&lt; host mode */</span><span class="w"></span>
<span class="w">  </span><span class="n">USB_DEVICE_MODE</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000010</span><span class="p">,</span><span class="w">     </span><span class="cm">/**&lt; Device mode */</span><span class="w"></span>
<span class="w">  </span><span class="n">USB_DUAL_ROLE_MODE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000020</span><span class="p">,</span><span class="w">     </span><span class="cm">/**&lt; Dual Role */</span><span class="w"></span>
<span class="w">  </span><span class="cm">/** invalid mode, used for error condition */</span><span class="w"></span>
<span class="w">  </span><span class="n">USB_INVALID_MODE</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00010000</span><span class="p">,</span><span class="w">     </span><span class="cm">/**&lt; invalid USB mode */</span><span class="w"></span>
<span class="p">}</span><span class="w"> </span><span class="n">QCOM_USB_MODE_TYPE</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="id2">
<h1>代码流程<a class="headerlink" href="#id2" title="此标题的永久链接"></a></h1>
<ul class="simple">
<li><p>usb驱动入口函数：</p></li>
</ul>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="n">QcomPkg</span><span class="o">/</span><span class="n">Drivers</span><span class="o">/</span><span class="n">UsbConfigDxe</span><span class="o">/</span><span class="n">UsbConfigDxe</span><span class="p">.</span><span class="n">inf</span><span class="w"></span>
<span class="p">[</span><span class="n">Defines</span><span class="p">]</span><span class="w"></span>
<span class="w">  </span><span class="n">INF_VERSION</span><span class="w">                    </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00010005</span><span class="w"></span>
<span class="w">  </span><span class="n">BASE_NAME</span><span class="w">                      </span><span class="o">=</span><span class="w"> </span><span class="n">UsbConfigDxe</span><span class="w"></span>
<span class="w">  </span><span class="n">FILE_GUID</span><span class="w">                      </span><span class="o">=</span><span class="w"> </span><span class="n">CD823A4D</span><span class="mi">-7</span><span class="n">DEC</span><span class="mi">-4531</span><span class="o">-</span><span class="n">AE5D</span><span class="mi">-4134</span><span class="n">FA4127B8</span><span class="w"></span>
<span class="w">  </span><span class="n">MODULE_TYPE</span><span class="w">                    </span><span class="o">=</span><span class="w"> </span><span class="n">DXE_DRIVER</span><span class="w"></span>
<span class="w">  </span><span class="n">VERSION_STRING</span><span class="w">                 </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0</span><span class="w"></span>
<span class="w">  </span><span class="n">ENTRY_POINT</span><span class="w">                    </span><span class="o">=</span><span class="w"> </span><span class="n">UsbConfigDriverEntryPoint</span><span class="w"></span>
</pre></div>
</div>
<ul class="simple">
<li><p>usb配置：</p></li>
</ul>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="n">QcomPkg</span><span class="o">/</span><span class="n">SocPkg</span><span class="o">/</span><span class="n">AgattiPkg</span><span class="o">/</span><span class="n">LAA</span><span class="o">/</span><span class="n">Core</span><span class="p">.</span><span class="n">dsc</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="cp"># USB</span>
<span class="w">  </span><span class="n">gQcomTokenSpaceGuid</span><span class="p">.</span><span class="n">InitUsbControllerOnBoot</span><span class="o">|</span><span class="n">FALSE</span><span class="w">  </span><span class="c1">//开机初始化usb</span>
<span class="w">  </span><span class="n">gQcomTokenSpaceGuid</span><span class="p">.</span><span class="n">HostModeSupported</span><span class="o">|</span><span class="n">FALSE</span><span class="w"> </span><span class="c1">// 开机host模式</span>
<span class="w">  </span><span class="n">gQcomTokenSpaceGuid</span><span class="p">.</span><span class="n">USBSmmuStage1Supported</span><span class="o">|</span><span class="n">TRUE</span><span class="w"></span>
<span class="w">  </span><span class="cp"># U1U2 enablement results in SS and SSP instability</span>
<span class="w">  </span><span class="n">gQcomTokenSpaceGuid</span><span class="p">.</span><span class="n">USBU1U2Supported</span><span class="o">|</span><span class="n">FALSE</span><span class="w"></span>
<span class="w">  </span><span class="n">gQcomTokenSpaceGuid</span><span class="p">.</span><span class="n">UsbNoPmic</span><span class="o">|</span><span class="n">TRUE</span><span class="w"> </span><span class="c1">//无pmic模式，无usb cc识别，直接配置成device</span>
</pre></div>
</div>
<ul class="simple">
<li><p>识别流程如下：</p>
<ul>
<li><ol class="arabic simple">
<li><p>usb配置驱动将启动timer每1s轮询一次usb状态。</p></li>
</ol>
</li>
<li><ol class="arabic simple" start="2">
<li></li>
</ol>
</li>
</ul>
</li>
</ul>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span>* UsbConfigDriverEntryPoint // QcomPkg/Drivers/UsbConfigDxe/UsbConfig.c
  └── Status = UsbConfigInit(); // AgattiPkg/Library/UsbConfigLib/UsbConfigLib.c
      ├── if (!FeaturePcdGet(HostModeSupported)) // Check if host mode is supported in UEFI.
      │   └── gUsbConfigDevice[USB_CORE_0_NICOBAR].EnableStaticCfg.UsbMode = USB_DEVICE_MODE_SS; //默认配置成HOST
      ├── Status = gBS-&gt;CreateEvent(EVT_TIMER | EVT_NOTIFY_SIGNAL,TPL_CALLBACK,UsbPortStateChgCb, NULL,&amp;PortStateChgEvt);// Create a timer to poll USB Type-C CC Status
      ├──  gBS-&gt;SignalEvent(PortStateChgEvt); //立即出发timer
      ├── UsbPortStateChgCb // timer的处理函数
      │   ├── Status = UsbConfigPortsEventHandler（...）//AgattiPkg/Library/UsbConfigLib/UsbConfigUsbPorts.c
      │   │   └── Status = UsbConfigPortsQueryConnectionChange(...)
      │   │       ├── if(FeaturePcdGet(UsbNoPmic) //重要如果配置成UsbNoPmic，直接赋值状态Attach，UFP，接下来在HandlePortPartnerXtach继续获取充电类型
      │   │       │   └── if (UsbPort-&gt;ConnectState == FALSE)
      │   │       │       ├── UsbPort-&gt;ConnectState = TRUE;
      │   │       │       ├── Message = UsbCfgPortMsgPartnerAttach;
      │   │       │       ├── Payload-&gt;UsbTypeCPortMode = USB_TYPEC_PORT_MODE_UFP;
      │   │       │       └── goto ON_EXIT; //直接跳转到出来，下面的都不跑
      │   │       ├── Status = gPwrCtrlProtocol-&gt;GetHwInfo(&amp;UsbPortHwInfo); //获取硬件信息，看是支持typec还是micro usb
      │   │       ├── if( (EFI_SUCCESS == Status) &amp;&amp; (UsbPortHwInfo.ConnectorType[0] == EFI_USB_PWR_CTRL_USB_CONNECTOR_TYPE_TYPEC)) //如果硬件支持typec
      │   │       │   └── Status = gPwrCtrlProtocol-&gt;GetTypeCPortStatus(CoreNum, &amp;UsbPort-&gt;PortStatus); //重要，获取typec状态
      │   │       │       └── switch (UsbPort-&gt;PortStatus.DataRole) //
      │   │       │           └── case EFI_USB_PWR_CTRL_TYPEC_DATAROLE_UFP: //UFP连接，一般接电脑会走这
      │   │       │               ├── DBG(EFI_D_INFO, &quot;USB Type-C Device Mode(UFP mode)&quot;);
      │   │       │               ├── Message = UsbCfgPortMsgPartnerAttach;
      │   │       │               └── DBG(EFI_D_ERROR, &quot;UFP and Type-C&quot;);
      │   │       ├── else if(UsbPortHwInfo.ConnectorType[0] == EFI_USB_PWR_CTRL_USB_CONNECTOR_TYPE_uUSB) //支持micro usb
      │   │       │   ├── Status = gPwrCtrlProtocol-&gt;GetVbusDetectStatus(CoreNum, &amp;VbusStatus); //获取vbus状态
      │   │       │   │   └── EFI_UsbPwrCtrl_GetVbusDetectStatus() // Drivers/UsbPwrCtrlDxe/UsbPwrCtrl.c
      │   │       │   │       └── UsbPwrCtrlLib_GetVbusDetect(PortIndex, bVbusDetect);
      │   │       │   │           └── UsbPwrCtrlLibPmSchg_GetVbusDetect(pUsbPwrCtrlHwInfo-&gt;Ports[PortIndex].VbusDetect.HwInfo, bVbusDetect); // QcomPkg/Library/UsbPwrCtrlLib/UsbPwrCtrlLib.c
      │   │       │   │               └── PmicSchgProtocol-&gt;UsbinValid(HwInfo.ResourceIndex,bVbusDetect);
      │   │       │   │                   ├── errFlag = pm_schg_usb_irq_status(PmicDeviceIndex, PM_SCHG_USB_IRQ_USBIN_PLUGIN, PM_IRQ_STATUS_RT,(boolean*)&amp;UsbinPlugedIn); //跟到最后还是读取pmic是否有中断信号
      │   │       │   │                   └── Valid = (UsbinPlugedIn) ? TRUE : FALSE; // Drivers/PmicDxe/PmicSchgProtocol.c
      │   │       │   └── if(VbusStatus)
      │   │       │       └── if (UsbPort-&gt;ConnectState == USBC_STATE_DETACHED)
      │   │       │           ├── Message = UsbCfgPortMsgPartnerAttach;
      │   │       │           ├── Payload-&gt;UsbTypeCPortMode = USB_TYPEC_PORT_MODE_UFP;
      │   │       │           └── DBG(EFI_D_ERROR, &quot;UFP and micro-USB&quot;);
      │   │       └── UsbConfigPortsPrintPortStatus(EFI_D_WARN, UsbPort, *Message, CoreNum); //纯打印
      │   └── switch (Message) { case UsbCfgPortMsgPartnerAttach: case UsbCfgPortMsgPartnerDetach: //承接UsbConfigPortsEventHandler函数获取连接状态及主从模式后，继续获取充电类型。
      │       └── HandlePortPartnerXtach(Index, Message, Payload.UsbTypeCPortMode);
      │           ├── (FeaturePcdGet(UsbNoPmic))//如果配置成UsbNoPmic，这里直接赋值SDP device模式
      │           │   ├── ChargerType = EFI_USB_PWR_CTRL_HSUSB_CHGPORT_SDP;
      │           │   └── PortMode = USB_TYPEC_PORT_MODE_UFP; 
      │           └── if (Message == UsbCfgPortMsgPartnerAttach) { //Attach
      │               └── if (IS_HARDWARE_CONFIUGRED(gUsbConfigDevice[CoreNum].UsbConfig.modeType)) 
      │                   ├── if (IS_USB_PERIPHERAL_MODE(gUsbConfigDevice[CoreNum].UsbConfig.modeType)) 
      │                   │   ├── Status = GetChargerPortType(CoreNum, &amp;ChargerType); //BC1.2获取充电类型
      │                   │   │   ├── Status = gRT-&gt;GetVariable(L&quot;UsbfnForceComplianceMode&quot;, &amp;gQcomTokenSpaceGuid, NULL, &amp;UefiVarSize, &amp;UefiVar); //BC1.2获取接口
      │                   │   │   └── if (!EFI_ERROR(Status) &amp;&amp; (UefiVar != 0)) 
      │                   │   │       └── *ChargerPortType = EFI_USB_PWR_CTRL_HSUSB_CHGPORT_SDP;
      │                   │   └── if(FeaturePcdGet(UsbNoPmic)) //如果配置成UsbNoPmic，充电类型直接SDP
      │                   │       └── ChargerType = EFI_USB_PWR_CTRL_HSUSB_CHGPORT_SDP;
      │                   └── if (FeaturePcdGet(InitUsbControllerOnBoot)) //Pcd配置成启动初始化
      │                       └── if (gUsbConfigDevice[CoreNum].EnableStaticCfg.Enabled == TRUE &amp;&amp; gUsbConfigDevice[USB_CORE_0_NICOBAR].EnableStaticCfg.UsbMode == USB_HOST_MODE_XHCI) //如果默认是host模式，则开始使能usb Controller
      │                           └── Status = UsbStartController(CoreNum, UsbCfgMode); //使能usb host
      ├── Status = gBS-&gt;SetTimer(PortStateChgEvt,TimerPeriodic,USB_PORT_POLL_INTERVAL);// Set the polling period for the USB Type-C periodic event callback
      ├── if (!FeaturePcdGet(HostModeSupported))  //Pcd默认配置成host模式为false则配置成device
      │   ├── gUsbConfigDevice[USB_CORE_0_NICOBAR].EnableStaticCfg.Enabled = TRUE;
      │   └── gUsbConfigDevice[USB_CORE_0_NICOBAR].EnableStaticCfg.UsbMode = USB_DEVICE_MODE_SS;
      ├── else // // If the user plugs in the host cable during the boot time, configure the USB hardware in the host mode  
      │   └── Status = UsbPortGetRtConnectionMode(gUsbConfigDevice[USB_CORE_0_NICOBAR].UsbPortHandle, &amp;PortMode, USB_CORE_0_NICOBAR); //检测是否有ota线插入
      │       └── if (PortMode == USB_TYPEC_PORT_MODE_DFP)
      │           └── gUsbConfigDevice[USB_CORE_0_NICOBAR].UsbCoreInterface-&gt;ModeType = USB_HOST_MODE; //默认配置成host模式
      └── #define USB_PORT_POLL_INTERVAL (1000 * 1000U) //timer是1s轮询一次
</pre></div>
</div>
</section>
<section id="id3">
<h1>问题分析<a class="headerlink" href="#id3" title="此标题的永久链接"></a></h1>
<section id="fastbootusb">
<h2>1.fastboot模式下不识别USB<a class="headerlink" href="#fastbootusb" title="此标题的永久链接"></a></h2>
<p>由于a6650项目没有接CC脚到pm2250上面，而默认配置的又是typec功能，所有不会触发SNK ATTACH事件，正常开发板接了CC会有以下打印：</p>
<div class="highlight-log notranslate"><div class="highlight"><pre><span></span>连接USB:
connectionUsbConfigPortsQueryConnectionChange: UFP and Type-C
UsbConfigPortsQueryConnectionChange: usbport-&gt;connectstate: ATT

断开：
UsbConfigPortsQueryConnectionChange: Detach and Type-C
UsbConfigPortsQueryConnectionChange: usbport-&gt;connectstate: DEATT
</pre></div>
</div>
<section id="micro-usb">
<h3>1.尝试配置成micro usb<a class="headerlink" href="#micro-usb" title="此标题的永久链接"></a></h3>
<p>直接在获取状态时强制修改成<code class="docutils literal notranslate"><span class="pre">EFI_USB_PWR_CTRL_USB_CONNECTOR_TYPE_uUSB</span></code>，修改如下：</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="n">UsbConfigPortsQueryConnectionChange</span><span class="p">(</span><span class="w"></span>
<span class="w">  </span><span class="n">IN</span><span class="w">     </span><span class="n">QCOM_USB_PORT</span><span class="w">                   </span><span class="o">*</span><span class="n">UsbPort</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="n">OUT</span><span class="w">    </span><span class="n">USB_CFG_PORT_MESSAGE</span><span class="w">            </span><span class="o">*</span><span class="n">Message</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="n">IN</span><span class="w"> </span><span class="n">OUT</span><span class="w"> </span><span class="n">UINTN</span><span class="w">                           </span><span class="o">*</span><span class="n">PayloadSize</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="n">OUT</span><span class="w">    </span><span class="n">USB_TYPEC_PORT_MESSAGE_PAYLOAD</span><span class="w">     </span><span class="o">*</span><span class="n">Payload</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="n">IN</span><span class="w">     </span><span class="n">UINT8</span><span class="w">                              </span><span class="n">CoreNum</span><span class="w"></span>
<span class="w">  </span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">Status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">gPwrCtrlProtocol</span><span class="o">-&gt;</span><span class="n">GetHwInfo</span><span class="p">(</span><span class="o">&amp;</span><span class="n">UsbPortHwInfo</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">UsbPortHwInfo</span><span class="p">.</span><span class="n">ConnectorType</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">EFI_USB_PWR_CTRL_USB_CONNECTOR_TYPE_uUSB</span><span class="p">;</span><span class="c1">//wugn add</span>

<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="n">EFI_SUCCESS</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Status</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">UsbPortHwInfo</span><span class="p">.</span><span class="n">ConnectorType</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">EFI_USB_PWR_CTRL_USB_CONNECTOR_TYPE_TYPEC</span><span class="p">))</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>

<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">UsbPortHwInfo</span><span class="p">.</span><span class="n">ConnectorType</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">EFI_USB_PWR_CTRL_USB_CONNECTOR_TYPE_uUSB</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">Status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">gPwrCtrlProtocol</span><span class="o">-&gt;</span><span class="n">GetVbusDetectStatus</span><span class="p">(</span><span class="n">CoreNum</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">VbusStatus</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">//  DBG(EFI_D_ERROR,&quot;Failed to get VbusStatus&quot;);</span>
<span class="w">      </span><span class="c1">//DBG(EFI_D_ERROR, &quot;VbusStatus: %d&quot;, VbusStatus);</span>

<span class="w">      </span><span class="k">if</span><span class="p">(</span><span class="n">VbusStatus</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">UsbPort</span><span class="o">-&gt;</span><span class="n">ConnectState</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">USBC_STATE_ATTACHED</span><span class="p">)</span><span class="w"></span>
<span class="w">          </span><span class="k">goto</span><span class="w"> </span><span class="n">ON_EXIT</span><span class="p">;</span><span class="w"></span>

<span class="w">          </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">UsbPort</span><span class="o">-&gt;</span><span class="n">ConnectState</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">USBC_STATE_DETACHED</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="o">*</span><span class="n">Message</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">UsbCfgPortMsgPartnerAttach</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="o">*</span><span class="n">PayloadSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">USB_TYPEC_PORT_MODE</span><span class="p">);</span><span class="w"></span>
<span class="w">                        </span><span class="n">DBG</span><span class="p">(</span><span class="n">EFI_D_ERROR</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;UFP and micro-USB&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="n">Payload</span><span class="o">-&gt;</span><span class="n">UsbTypeCPortMode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">USB_TYPEC_PORT_MODE_UFP</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="n">UsbPort</span><span class="o">-&gt;</span><span class="n">PortStatus</span><span class="p">.</span><span class="n">DataRole</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">EFI_USB_PWR_CTRL_TYPEC_DATAROLE_UFP</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="k">else</span><span class="w"></span>
<span class="w">      </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">DBG</span><span class="p">(</span><span class="n">EFI_D_INFO</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Vbus FALSE %d&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">UsbPort</span><span class="o">-&gt;</span><span class="n">ConnectState</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">UsbPort</span><span class="o">-&gt;</span><span class="n">ConnectState</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">USBC_STATE_DETACHED</span><span class="p">)</span><span class="w"></span>
<span class="w">          </span><span class="k">goto</span><span class="w"> </span><span class="n">ON_EXIT</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">UsbPort</span><span class="o">-&gt;</span><span class="n">ConnectState</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">USBC_STATE_ATTACHED</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="o">*</span><span class="n">Message</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">UsbCfgPortMsgPartnerDetach</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="o">*</span><span class="n">PayloadSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">USB_TYPEC_PORT_MODE</span><span class="p">);</span><span class="w"></span>
<span class="w">                  </span><span class="n">DBG</span><span class="p">(</span><span class="n">EFI_D_ERROR</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Detach and micro-USB&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">          </span><span class="n">Payload</span><span class="o">-&gt;</span><span class="n">UsbTypeCPortMode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">USB_TYPEC_PORT_MODE_INVALID</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="n">UsbPort</span><span class="o">-&gt;</span><span class="n">PortStatus</span><span class="p">.</span><span class="n">DataRole</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">EFI_USB_PWR_CTRL_TYPEC_DATAROLE_UNKNOWN</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>能正常检测到vbus和连接状态，但就是没法识别usb，打印如下：
<img alt="0006_0000.png" src="../../../_images/0006_00002.png" /></p>
<p>我还以是bc1.2检测出错了。</p>
</section>
<section id="usbnopmic">
<h3>2.直接配置UsbNoPmic<a class="headerlink" href="#usbnopmic" title="此标题的永久链接"></a></h3>
<p>目前XBL中有UsbNoPmic配置，意思是不带pmic直接配置成device模式，检索如下：</p>
<div class="highlight-log notranslate"><div class="highlight"><pre><span></span>wugn@jcrj-tf-compile:boot_images$ ack UsbNoPmic QcomPkg/SocPkg/AgattiPkg/
QcomPkg/SocPkg/AgattiPkg/LAA/Core.dsc
816:  gQcomTokenSpaceGuid.UsbNoPmic|TRUE

QcomPkg/SocPkg/AgattiPkg/Library/UsbConfigLib/UsbConfigLib.inf
100:  gQcomTokenSpaceGuid.UsbNoPmic

QcomPkg/SocPkg/AgattiPkg/Library/UsbConfigLib/UsbConfigUsbPorts.c
210:  if(FeaturePcdGet(UsbNoPmic) ||

QcomPkg/SocPkg/AgattiPkg/Library/UsbConfigLib/UsbConfigLib.c
1183:       (FeaturePcdGet(UsbNoPmic)) ||
1231:        if(FeaturePcdGet(UsbNoPmic)) {
</pre></div>
</div>
<ul class="simple">
<li><p>获取状态直接赋值并跳过CC检测：</p></li>
</ul>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span>QcomPkg/SocPkg/AgattiPkg/Library/UsbConfigLib/UsbConfigUsbPorts.c：
UsbConfigPortsQueryConnectionChange(
  IN     QCOM_USB_PORT                   *UsbPort,
  OUT    USB_CFG_PORT_MESSAGE            *Message,
  IN OUT UINTN                           *PayloadSize,
  OUT    USB_TYPEC_PORT_MESSAGE_PAYLOAD     *Payload,
  IN     UINT8                              CoreNum
  )
{
  BOOLEAN    VbusStatus = FALSE;
  EFI_STATUS Status = EFI_SUCCESS;
  //Initialize Message value to UsbCfgPortMsgNone
  *Message = UsbCfgPortMsgNone;

  // Since there is no Type-C support for Pre-SI,
  // assume port in UFP mode and it is always attached.
  if(FeaturePcdGet(UsbNoPmic) ||
    (PlatformInfo.platform == EFI_PLATFORMINFO_TYPE_RUMI) ||
    (PlatformInfo.platform == EFI_PLATFORMINFO_TYPE_VIRTIO) ||
        (PlatformInfo.platform == EFI_PLATFORMINFO_TYPE_ADP) ||
    (PlatformInfo.platform == EFI_PLATFORMINFO_TYPE_UNKNOWN)) {
    DBG(EFI_D_VERBOSE, &quot;Pre-SI: Assume UFP and attached&quot;);

    if (UsbPort-&gt;ConnectState == FALSE) {
      UsbPort-&gt;ConnectState = TRUE;
      *Message = UsbCfgPortMsgPartnerAttach;
      *PayloadSize = sizeof(USB_TYPEC_PORT_MODE);
      Payload-&gt;UsbTypeCPortMode = USB_TYPEC_PORT_MODE_UFP;
      // set to CC1 for RUMI
      UsbPort-&gt;PortStatus.CCOrientation = EFI_USB_PWR_CTRL_TYPEC_ORIENTATION_CC1;
    }
    goto ON_EXIT;
  }
</pre></div>
</div>
<p>直接跳过bc1.2检测，赋值充电类型为SDP。</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="n">HandlePortPartnerXtach</span><span class="p">(</span><span class="w"></span>
<span class="w">  </span><span class="n">IN</span><span class="w"> </span><span class="n">QCOM_USB_CORE_NUM</span><span class="w">    </span><span class="n">CoreNum</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="n">IN</span><span class="w"> </span><span class="n">USB_CFG_PORT_MESSAGE</span><span class="w"> </span><span class="n">Message</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="n">IN</span><span class="w"> </span><span class="n">USB_TYPEC_PORT_MODE</span><span class="w">  </span><span class="n">PortMode</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">EFI_STATUS</span><span class="w"> </span><span class="n">Status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">EFI_SUCCESS</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">QCOM_USB_CORE_INTERFACE</span><span class="w"> </span><span class="o">*</span><span class="n">UsbCoreIfc</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">QCOM_USB_MODE_TYPE</span><span class="w"> </span><span class="n">UsbCfgMode</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">EFI_USB_PWR_CTRL_HSUSB_CHGPORT_TYPE</span><span class="w"> </span><span class="n">ChargerType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">EFI_USB_PWR_CTRL_HSUSB_CHGPORT_INVALID</span><span class="p">;;</span><span class="w"></span>

<span class="w">  </span><span class="n">FNC_ENTER_MSG</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Set the charger type to SDP for RUMI</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="n">PlatformInfo</span><span class="p">.</span><span class="n">platform</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">EFI_PLATFORMINFO_TYPE_RUMI</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"></span>
<span class="w">       </span><span class="p">(</span><span class="n">FeaturePcdGet</span><span class="p">(</span><span class="n">UsbNoPmic</span><span class="p">))</span><span class="w"> </span><span class="o">||</span><span class="w"></span>
<span class="w">       </span><span class="p">(</span><span class="n">PlatformInfo</span><span class="p">.</span><span class="n">platform</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">EFI_PLATFORMINFO_TYPE_ADP</span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">DBG</span><span class="p">(</span><span class="n">EFI_D_INFO</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Set Charger Type to SDP for RUMI&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">ChargerType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">EFI_USB_PWR_CTRL_HSUSB_CHGPORT_SDP</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">PortMode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">USB_TYPEC_PORT_MODE_UFP</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">FeaturePcdGet</span><span class="p">(</span><span class="n">UsbNoPmic</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="n">ChargerType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">EFI_USB_PWR_CTRL_HSUSB_CHGPORT_SDP</span><span class="p">;</span><span class="w"></span>
<span class="w">                </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
</section>


           </div>
             <div class="articleComments">
                <comments>
  <script src="https://utteranc.es/client.js"
    repo="iswbm/magic-python"
    issue-term="pathname"
    theme="github-light"
    crossorigin="anonymous"
    async>
  </script>
</comments>
             </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; 版权所有 2022, wugn.</p>
  </div>

  利用 <a href="https://www.sphinx-doc.org/">Sphinx</a> 构建，使用了 
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">主题</a>
    由 <a href="https://readthedocs.org">Read the Docs</a>开发.
  

<script charset="UTF-8" id="LA_COLLECT" src="//sdk.51.la/js-sdk-pro.min.js"></script>
<script>LA.init({id: "JoV5csIHTGhHiGQ4",ck: "JoV5csIHTGhHiGQ4"})</script>

<br/>
<script id="LA-DATA-WIDGET" crossorigin="anonymous" charset="UTF-8" src="https://v6-widget.51.la/v6/JoV5csIHTGhHiGQ4/quote.js?theme=#4C8AC2,#BB2626,#040000,#333333,#AE3535,#1690FF,14&f=14"></script>



</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>