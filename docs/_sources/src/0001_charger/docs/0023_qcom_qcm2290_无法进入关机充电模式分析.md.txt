# 概述

高通qcm2290代码拿过来，关机插入usb直接开机，应该进入关机充电。 

# 参考

* [高通uefi的abl增加新的kernel cmdlin标签经验分享](https://blog.csdn.net/qq_27629673/article/details/125471481)

# 软件分析

移远那边给过来修改如下可以进入：
```diff
 UM.9.15/bootable/bootloader/edk2/QcomModulePkg/Library/BootLib/UpdateCmdLine.c 
@@ -673,7 +673,9 @@ UpdateCmdLine (CONST CHAR8 *CmdLine,
     /* reduce kernel console messages to speed-up boot */
     CmdLineLen += AsciiStrLen (LogLevel);
   } else if (BatteryStatus &&
              IsChargingScreenEnable () &&
+//[feature]-del-begin xielianxiong@paxsz.com 20220830,for shutdown boot into charging mode
+             /*IsChargingScreenEnable () &&*/
+ //[feature]-del-end xielianxiong@paxsz.com 20220830,for shutdown boot into charging mode
              !Recovery) {
     DEBUG ((EFI_D_INFO, "Device will boot into off mode charging mode\n"));
     PauseAtBootUp = 1;
```

# 实现原理

以上可得知关机充电原理就是向上传一个`androidboot.mode=charger` kernel cmdline，healthd进程接收进入关机充电模式，最终要的是`IsChargingScreenEnable`接口。
```C++
* LinuxLoaderEntry (IN EFI_HANDLE ImageHandle, IN EFI_SYSTEM_TABLE *SystemTable) //ABL入口函数
  * BootLinux (&Info);
    * Status = DTBImgCheckAndAppendDT (Info, &BootParamlistPtr);
	  * BoardDtb = GetBoardDtb (Info, BootParamlistPtr->DtboImgBuffer);
	    * FindBestDtb = ReadDtbFindMatch (&CurDtbInfo, &BestDtbInfo, BIT(VARIANT_MATCH) | BIT(PAX_BOARD_INFO_MATCH)); //重要，读取sp信息
	    * if (FindBestDtb) DtboIdx = DtboCount;
    * Status = UpdateCmdLine (BootParamlistPtr.CmdLine, FfbmStr, Recovery,
	  * DtboIdx = GetDtboIdx ();
	  * if (BatteryStatus && IsChargingScreenEnable () && !Recovery)
	    * CmdLineLen += AsciiStrLen (BatteryChgPause);  
		* else CmdLineLen += AsciiStrLen (AlarmBootCmdLine);
```

```C++
STATIC CONST CHAR8 *BatteryChgPause = " androidboot.mode=charger";
STATIC CONST CHAR8 *AlarmBootCmdLine = " androidboot.alarmboot=true";

STATIC CHAR8 *AndroidBootDtboIdx = " androidboot.dtbo_idx=";
STATIC CHAR8 *AndroidBootDtbIdx = " androidboot.dtb_idx=";
```

# IsChargingScreenEnable原理

* `QcomModulePkg/Library/BootLib/DeviceInfo.c`中abl会在初始化中调用`DeviceInfoInit`接口获取devinfo：
```C++
EFI_STATUS DeviceInfoInit (VOID)
{
  EFI_STATUS Status = EFI_SUCCESS;

  if (FirstReadDevInfo) {
    Status =
        ReadWriteDeviceInfo (READ_CONFIG, (VOID *)&DevInfo, sizeof (DevInfo));
    if (Status != EFI_SUCCESS) {
      DEBUG ((EFI_D_ERROR, "Unable to Read Device Info: %r\n", Status));
      return Status;
    }

    FirstReadDevInfo = FALSE;
  }

  if (CompareMem (DevInfo.magic, DEVICE_MAGIC, DEVICE_MAGIC_SIZE)) {
    DEBUG ((EFI_D_ERROR, "Device Magic does not match\n"));
    gBS->SetMem (&DevInfo, sizeof (DevInfo), 0);
    gBS->CopyMem (DevInfo.magic, DEVICE_MAGIC, DEVICE_MAGIC_SIZE);
    DevInfo.user_public_key_length = 0;
    gBS->SetMem (DevInfo.rollback_index, sizeof (DevInfo.rollback_index), 0);
    gBS->SetMem (DevInfo.user_public_key, sizeof (DevInfo.user_public_key), 0);
    if (IsSecureBootEnabled ()) {
      DevInfo.is_unlocked = FALSE;
      DevInfo.is_unlock_critical = FALSE;
    } else {
      DevInfo.is_unlocked = TRUE;
      DevInfo.is_unlock_critical = TRUE;
    }
    DevInfo.is_charger_screen_enabled = FALSE; //初始化为不开
    DevInfo.verity_mode = TRUE;
    Status =
        ReadWriteDeviceInfo (WRITE_CONFIG, (VOID *)&DevInfo, sizeof (DevInfo));
    if (Status != EFI_SUCCESS) {
      DEBUG ((EFI_D_ERROR, "Unable to Write Device Info: %r\n", Status));
      return Status;
    }
  }

  return Status;
}

BOOLEAN IsChargingScreenEnable (VOID)
{
  return DevInfo.is_charger_screen_enabled;
}

EFI_STATUS
EnableChargingScreen (BOOLEAN IsEnabled) //提供fastboot命令调用
{
  EFI_STATUS Status = EFI_SUCCESS;

  if (IsChargingScreenEnable () != IsEnabled) {
    DevInfo.is_charger_screen_enabled = IsEnabled;
    Status = ReadWriteDeviceInfo (WRITE_CONFIG, &DevInfo, sizeof (DevInfo));
    if (Status != EFI_SUCCESS) {
      DEBUG ((EFI_D_ERROR, "Error %a charger screen: %r\n",
              (IsEnabled ? "Enabling" : "Disabling"), Status));
      return Status;
    }
  }

  return Status;
}
```

# fastboot命令

* `QcomModulePkg/Library/FastbootLib/FastbootCmds.c`fastboot命令支持开关关机充电模式:
```C++
  struct FastbootCmdDesc cmd_list[] = {
      /* By Default enable list is empty */
      {"", NULL},
/*CAUTION(High): Enabling these commands will allow changing the partitions
 *like system,userdata,cachec etc...
 */
#ifdef ENABLE_UPDATE_PARTITIONS_CMDS
      {"flash:", CmdFlash},
      {"erase:", CmdErase},
      {"set_active", CmdSetActive},
      {"flashing get_unlock_ability", CmdFlashingGetUnlockAbility},
      {"flashing unlock", CmdFlashingUnlock},
      {"flashing lock", CmdFlashingLock},
#endif
/*
 *CAUTION(CRITICAL): Enabling these commands will allow changes to bootimage.
 */
#ifdef ENABLE_DEVICE_CRITICAL_LOCK_UNLOCK_CMDS
      {"flashing unlock_critical", CmdFlashingUnLockCritical},
      {"flashing lock_critical", CmdFlashingLockCritical},
#endif
/*
 *CAUTION(CRITICAL): Enabling this command will allow boot with different
 *bootimage.
 */
#ifdef ENABLE_BOOT_CMD
      {"boot", CmdBoot},
#endif
      {"oem enable-charger-screen", CmdOemEnableChargerScreen},
      {"oem disable-charger-screen", CmdOemDisableChargerScreen},
  };

STATIC VOID
CmdOemEnableChargerScreen (CONST CHAR8 *Arg, VOID *Data, UINT32 Size)
{
  EFI_STATUS Status;
  DEBUG ((EFI_D_INFO, "Enabling Charger Screen\n"));

  Status = EnableChargingScreen (TRUE);
  if (Status != EFI_SUCCESS) {
    FastbootFail ("Failed to enable charger screen");
  } else {
    FastbootOkay ("");
  }
}

STATIC VOID
CmdOemDisableChargerScreen (CONST CHAR8 *Arg, VOID *Data, UINT32 Size)
{
  EFI_STATUS Status;
  DEBUG ((EFI_D_INFO, "Disabling Charger Screen\n"));

  Status = EnableChargingScreen (FALSE);
  if (Status != EFI_SUCCESS) {
    FastbootFail ("Failed to disable charger screen");
  } else {
    FastbootOkay ("");
  }
}

```

* 操作如下：
```shell
C:\Users\wugangnan>fastboot oem enable-charger-screen
                                                   OKAY [  0.011s]
Finished. Total time: 0.017s

C:\Users\wugangnan>fastboot getvar charger-screen-enabled
charger-screen-enabled: 1
Finished. Total time: 0.004s
```